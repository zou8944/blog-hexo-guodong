{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next-v6/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/avatar-dufu.gif","path":"images/avatar-dufu.gif","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/icon-dufu.png","path":"images/icon-dufu.png","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next-v6/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/canvas-nest/LICENSE","path":"lib/canvas-nest/LICENSE","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/canvas-nest/README.md","path":"lib/canvas-nest/README.md","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/canvas-nest/canvas-nest-nomobile.min.js","path":"lib/canvas-nest/canvas-nest-nomobile.min.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/canvas-ribbon/LICENSE","path":"lib/canvas-ribbon/LICENSE","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/canvas-ribbon/README.md","path":"lib/canvas-ribbon/README.md","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/LICENSE","path":"lib/three/LICENSE","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/README.md","path":"lib/three/README.md","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/gulpfile.js","path":"lib/three/gulpfile.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/renovate.json","path":"lib/three/renovate.json","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/package.json","path":"lib/three/package.json","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/lib/CanvasRenderer.js","path":"lib/three/lib/CanvasRenderer.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/src/canvas_lines.js","path":"lib/three/src/canvas_lines.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/lib/Projector.js","path":"lib/three/lib/Projector.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/src/canvas_sphere.js","path":"lib/three/src/canvas_sphere.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/src/three-waves.js","path":"lib/three/src/three-waves.js","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/package-lock.json","path":"lib/three/package-lock.json","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next-v6/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next-v6/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1567845240942},{"_id":"themes/next-v6/README.md","hash":"e0fcd99c0a6db47fe5739df32d6ab39c44c65196","modified":1567845240942},{"_id":"themes/next-v6/_config.yml","hash":"84468ea65d62b5b49029c86afd6fd1497678d198","modified":1567918259822},{"_id":"themes/next-v6/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1567845240942},{"_id":"themes/next-v6/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1567845240942},{"_id":"themes/next-v6/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1567845240942},{"_id":"themes/next-v6/gulpfile.coffee","hash":"25d1bf7f98ea03c647cb8caa19e109aaaacd6ad7","modified":1567845240946},{"_id":"themes/next-v6/package.json","hash":"4891972e0a53023164ed241966ba93cb0a8c05fc","modified":1567845240946},{"_id":"source/_posts/Common FileUpload介绍.md","hash":"048fb65cda2617ce5d205d0a9dc85e74322dd890","modified":1567911657182},{"_id":"source/_posts/Git基础知识.md","hash":"ca1a127621cb4067029558f4e74307abb058b95f","modified":1567911657182},{"_id":"source/_posts/Spring Webflow - EL表达式.md","hash":"4ebbf4a71a4bf27615d496e6bab904f6df7b1d31","modified":1567911657182},{"_id":"source/_posts/Spring Webflow - Action.md","hash":"79969c6097c2722f1bf70146c8c2748ea010db2c","modified":1567911657182},{"_id":"source/_posts/Spring Webflow - 前言.md","hash":"5dcc0b75c601ae54ed525e0de023ade336f6cf1c","modified":1567911657182},{"_id":"source/_posts/Spring Webflow - 基础.md","hash":"3424e418fb3d3e81a1e8201fc61f2f25bde2e78f","modified":1567911657182},{"_id":"source/_posts/Spring Webflow - 配置.md","hash":"42b6f8bac609c3e282cbe8844f212d7e05e9f1db","modified":1567937610331},{"_id":"source/_posts/Spring Webflow - 视图状态.md","hash":"974c6fab2d2ee89be12fe5a7eca4aabd07192076","modified":1567911657182},{"_id":"source/_posts/Spring-Webflow-第一个Flow.md","hash":"1692ba96511dff3385cde00b471aa81e392e2865","modified":1567937689621},{"_id":"source/_posts/使用Django从零搭建一个小型站点.md","hash":"79feb67dada34300cf2b39b904ca30abcd359ce5","modified":1567911657182},{"_id":"source/_posts/我有点想要写博客了.md","hash":"21e59027eafe59363d4eab19c086a9b6b6a9075c","modified":1567911657182},{"_id":"source/_posts/推荐系统-概述.md","hash":"a9c940c5da93665edece2e26cd2db97a99b5f432","modified":1567915520041},{"_id":"source/_posts/读书笔记-RxJava.md","hash":"fd9151552ff26c6765c49152b02d3322a80365b7","modified":1567912934657},{"_id":"source/_posts/通过几个问题了解Http协议.md","hash":"fc211dc7314343036e0e4e30ef66b8c9f96d4c60","modified":1567911657182},{"_id":"source/about/index.md","hash":"d8ef335b3dedd10c9b95c9ed9b719e77f9e9bbe7","modified":1567849815786},{"_id":"source/guestbook/index.md","hash":"71de83b51b71b838e67e5937fd95d265f8094687","modified":1567849989533},{"_id":"source/tags/index.md","hash":"e620b2d40dde2d2b39adae27ee3fe6b584d1521f","modified":1567849810642},{"_id":"source/categories/index.md","hash":"5f1ad6c3a21a35052b961a17b17946d6a9a5babb","modified":1567849812610},{"_id":"themes/next-v6/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1567845240942},{"_id":"themes/next-v6/docs/ALGOLIA-SEARCH.md","hash":"20f8a3d7db6e797a5a3ed8c84837315cb8e09e5b","modified":1567845240942},{"_id":"themes/next-v6/docs/AUTHORS.md","hash":"44c3b963d877c6cbc3a720ed4e266532db3c12ac","modified":1567845240942},{"_id":"themes/next-v6/docs/DATA-FILES.md","hash":"a85ae0f3a9655eea9acd3f6209b72eb002f2058d","modified":1567845240942},{"_id":"themes/next-v6/docs/INSTALLATION.md","hash":"5385246ab4756e3e26ec9fe1f6a6759812177cc4","modified":1567845240946},{"_id":"themes/next-v6/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"1fb2c852fad03b73882069f1ec0659db2e1f2da0","modified":1567845240946},{"_id":"themes/next-v6/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1567845240946},{"_id":"themes/next-v6/docs/MATH.md","hash":"aa90364b1ac069b4f8cfdb48b4879311856224e6","modified":1567845240946},{"_id":"themes/next-v6/docs/UPDATE-FROM-5.1.X.md","hash":"a07ca23c38f6e4dddd4b74016b30e88cd3796f75","modified":1567845240946},{"_id":"themes/next-v6/languages/de.yml","hash":"3d8920676d89494d7d1c74d4238680151ea6d9df","modified":1567845240946},{"_id":"themes/next-v6/languages/default.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1567845240946},{"_id":"themes/next-v6/languages/en.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1567845240946},{"_id":"themes/next-v6/languages/es.yml","hash":"7dc1d7d5ea1078ee3b9bc8e0e8d0f15f52a7a4aa","modified":1567845240946},{"_id":"themes/next-v6/languages/fa.yml","hash":"269b5cb70774485d7dbbcf98eec72c9e84e135b2","modified":1567845240946},{"_id":"themes/next-v6/languages/fr.yml","hash":"dfdcfa536c40d06125dff373d042c50e08fcafd8","modified":1567845240946},{"_id":"themes/next-v6/languages/hu.yml","hash":"e4a5f43fb45acd992def3de3b600aa4df4c95ed7","modified":1567845240946},{"_id":"themes/next-v6/languages/id.yml","hash":"5665dece8435964a27b5061d7283f339f84721f0","modified":1567845240946},{"_id":"themes/next-v6/languages/it.yml","hash":"311597c620059dbb99474f19b2110a4485ecf70b","modified":1567845240946},{"_id":"themes/next-v6/languages/ja.yml","hash":"4f929842b3d6aaed709ea99da679d3910ee184e5","modified":1567845240946},{"_id":"themes/next-v6/languages/ko.yml","hash":"5f5194dd0f5a3c8484e7668bce6fbe23340e531a","modified":1567845240946},{"_id":"themes/next-v6/languages/nl.yml","hash":"561c77ca68e9d51a5ce8c89d3361fdb033c96bba","modified":1567845240946},{"_id":"themes/next-v6/languages/pt-BR.yml","hash":"13b579911e44a8b213e1860f9a50c341be1bf95e","modified":1567845240946},{"_id":"themes/next-v6/languages/pt.yml","hash":"af9d9b581dca45ab9789ca41d3492883a911e383","modified":1567845240946},{"_id":"themes/next-v6/languages/ru.yml","hash":"b485c57dd7b447406dafd0dcfdfc9356266708c9","modified":1567845240946},{"_id":"themes/next-v6/languages/tr.yml","hash":"39caf8a3677fd6dfbd523e73f8482a509e87b603","modified":1567845240946},{"_id":"themes/next-v6/languages/uk.yml","hash":"4cbdbb0ed09487c9b435be21ac35f62182f53283","modified":1567845240946},{"_id":"themes/next-v6/languages/vi.yml","hash":"3c6bb816ee7278afcddac06998c9ebe47ee19aef","modified":1567845240946},{"_id":"themes/next-v6/languages/zh-CN.yml","hash":"5bbf85050fcb4ce73b9aa40743901bc9073ceec5","modified":1567850113123},{"_id":"themes/next-v6/languages/zh-HK.yml","hash":"93d10d6e448c519004b09b11fba980b5036c93af","modified":1567845240946},{"_id":"themes/next-v6/languages/zh-TW.yml","hash":"ae2aa1c6ec1a5a01a3a3bde17bcc3a82f9a35fa7","modified":1567845240946},{"_id":"themes/next-v6/layout/_layout.swig","hash":"aa94f42953d9ef363dd644ef9ea7571bddb0d4ca","modified":1567845240946},{"_id":"themes/next-v6/layout/archive.swig","hash":"72b4e0786668bc61c11eafa12da5d75272b93b61","modified":1567845240946},{"_id":"themes/next-v6/layout/category.swig","hash":"38433a9de15f019267c9130e243e14343fb9bc3d","modified":1567845240946},{"_id":"themes/next-v6/layout/index.swig","hash":"20e776e8863f662c154bb765aaa0a1a22bf78126","modified":1567845240946},{"_id":"themes/next-v6/layout/page.swig","hash":"f038deec70adfecb0a87256ba8c319d4781925a5","modified":1567845240946},{"_id":"themes/next-v6/layout/post.swig","hash":"0c3b34a6832b8e33574edc17095344f9e0bea74f","modified":1567845240946},{"_id":"themes/next-v6/layout/tag.swig","hash":"153fb65e710a9643634aea4813431e92c11d09fe","modified":1567845240946},{"_id":"source/_posts/Spring-Webflow-第一个Flow/20180906212548121.png","hash":"8e06b7660aa416ed2f5c52697abc4012d3af59c4","modified":1567937676657},{"_id":"source/_posts/Spring-Webflow-第一个Flow/20180906213226568.png","hash":"c41f9272e18766632ba10675e4c75e2900d6a0b8","modified":1567937676657},{"_id":"source/_posts/读书笔记-RxJava/1564822583394.png","hash":"1ce10d5c470cb6a597648e581c7917acb8e61e62","modified":1564822583420},{"_id":"source/_posts/读书笔记-RxJava/1564823342178.png","hash":"0077fdc1795f40f4ac40d76575327f83479a5584","modified":1564823342205},{"_id":"source/_posts/读书笔记-RxJava/1564823975876.png","hash":"c8d7b4ce7e10042f48bf52a37fd69b9ba86145b7","modified":1564823975895},{"_id":"source/_posts/读书笔记-RxJava/1564824218864.png","hash":"a9a51de5d2aa4e25ae21bff6df7064915b29e372","modified":1564824218889},{"_id":"source/_posts/读书笔记-RxJava/1564825542157.png","hash":"d5a36ade8dd2f56ce3986c68167765c1f77eb798","modified":1564825542180},{"_id":"themes/next-v6/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1567845240946},{"_id":"themes/next-v6/docs/ru/DATA-FILES.md","hash":"67d04e3e29a2675d1a9f87d1ae6ea0769e963ff1","modified":1567845240946},{"_id":"themes/next-v6/docs/ru/README.md","hash":"3ceab62de4db29e2257dd5a187c7f8731a207f84","modified":1567845240946},{"_id":"themes/next-v6/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"5ad2c2d0a11443a03b3fd912925bc0dcfbcda88c","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"0dfb458370a0ffbbe37c00f53c15e3aa3e79b125","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/CONTRIBUTING.md","hash":"ca39e510b43ea1efe7e5feeca2243375e55eff5c","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/DATA-FILES.md","hash":"c46f3f7496fc422207cc5954e10a2bc972b650aa","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/INSTALLATION.md","hash":"c13546dd70a99a7d2d409cddf5d59f2f4d4d44a4","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8ceaad956a1afedf179b2e0b98a67adee9afec08","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/MATH.md","hash":"a658a72589738e11aefaa3a714b188ffd5aac822","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/README.md","hash":"0981aaf68145a05b02cd10c95d38cbaf97622944","modified":1567845240946},{"_id":"themes/next-v6/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"4ee0607ddcfb2fe0e5868aced6d5814d1ada4405","modified":1567845240946},{"_id":"themes/next-v6/layout/_macro/post-collapse.swig","hash":"1bb927e0560d3d3c95369da461911cced5bd537b","modified":1567845240946},{"_id":"themes/next-v6/layout/_macro/sidebar.swig","hash":"ccef7a8cd704575cf7bfe63c0492fe43592b1a6d","modified":1567845240946},{"_id":"themes/next-v6/layout/_macro/post.swig","hash":"76788b119076b1f28e8bac453be3e6b66e169792","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/comments.swig","hash":"e0f59221b6010bd3e05d34fac915556f51b8a458","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/footer.swig","hash":"9d9a5d6a2f0d4f65fe57c3737c91ecaf276c1f5c","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/pagination.swig","hash":"769a983fe2f77908bfc8590ff37a0d8958b47598","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/post-edit.swig","hash":"4b0c972c44bfa7ab07604280563deb9cc3974657","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/widgets.swig","hash":"58f12810a730ba8e3129c9b0d1a7cce42ac6f2d2","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/noscript.swig","hash":"e08feac6f8904d7f2006e350514a2f07eb9fff44","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/pjax.swig","hash":"105004ddcc7fe9f4fd7ad1007b628ba8c08c1e27","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/three.swig","hash":"eee4d26b5c0bb7872a21346151c38612a9b76d0b","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/vendors.swig","hash":"d3448044776dd23abd42b09ef0f26827f95efdf5","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/facebook-sdk.swig","hash":"3cf1a1a83ceddef4033a2964150f81b979ced6ff","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/index.swig","hash":"32e4fe8dd8b3c40a17314569d1a14bde55251074","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/quicklink.swig","hash":"65f94b115c42d33e6a90b1f8e62075c6d4ac60c1","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/vkontakte-api.swig","hash":"e0d012bdbae5545d90143030116114c34219bd37","modified":1567845240946},{"_id":"themes/next-v6/scripts/events/index.js","hash":"a25690d8b03779f7e318108c8eace9baf6d4283a","modified":1567845240946},{"_id":"themes/next-v6/scripts/filters/default-injects.js","hash":"834599d2b83f06e90f8cf618cddc106fe900ba5c","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/excerpt.js","hash":"827c3733fa14b018dd1f07e41686c207880e823a","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/exturl.js","hash":"9c32675f64121ffbe454189b8e418b408f79d9c2","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/lazyload.js","hash":"51672320fff6b39f56fe6a2881c611afe4e79b8e","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1567845240950},{"_id":"themes/next-v6/scripts/helpers/engine.js","hash":"896a581feb9432e58a325ad04d66d6310a12374e","modified":1567845240950},{"_id":"themes/next-v6/scripts/helpers/font.js","hash":"53169e2d04f0c21e68beb07c212be0a6c2a9aaea","modified":1567845240950},{"_id":"themes/next-v6/scripts/helpers/next-inject.js","hash":"33eb6f38de575b973fed237032c34d878594fdc1","modified":1567845240950},{"_id":"themes/next-v6/scripts/helpers/next-js.js","hash":"b28a8ed6d033946acbb5b91f6d8b884857410dd9","modified":1567845240950},{"_id":"themes/next-v6/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1567845240950},{"_id":"themes/next-v6/scripts/helpers/next-vendors.js","hash":"d512f44195f68b0ff93f3c82afff9161cdf1b7d6","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/group-pictures.js","hash":"8fc05f22b88553bc1d96e0c925799cd97920fc6a","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/include-raw.js","hash":"60f880c1e11a7df1aee4f2e01d65451fecc0372c","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1567845240950},{"_id":"themes/next-v6/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1567845240950},{"_id":"themes/next-v6/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1567845240950},{"_id":"themes/next-v6/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1567845240950},{"_id":"themes/next-v6/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1567845240950},{"_id":"themes/next-v6/source/images/avatar-dufu.gif","hash":"7393d7ca4899f09724bbcb90729360287313186f","modified":1567848993976},{"_id":"themes/next-v6/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1567845240950},{"_id":"themes/next-v6/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1567845240950},{"_id":"themes/next-v6/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1567845240954},{"_id":"themes/next-v6/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1567845240954},{"_id":"themes/next-v6/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1567845240954},{"_id":"themes/next-v6/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1567845240954},{"_id":"themes/next-v6/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1567845240954},{"_id":"themes/next-v6/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1567845240954},{"_id":"themes/next-v6/source/images/favicon-16x16-next.png","hash":"fac7e1c64c9e5293f5fe05ce7aea8d15831c6d07","modified":1567914394489},{"_id":"themes/next-v6/source/images/favicon-32x32-next.png","hash":"950b95b8e165bdeff9f4b720312839defa380dd2","modified":1567914429377},{"_id":"themes/next-v6/source/images/icon-dufu.png","hash":"91580d7cb4ef524696cbca49d01b56e9e7c6dd5f","modified":1567849093819},{"_id":"themes/next-v6/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1567845240954},{"_id":"themes/next-v6/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1567845240954},{"_id":"themes/next-v6/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1567845240954},{"_id":"themes/next-v6/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1567845240954},{"_id":"themes/next-v6/source/js/bookmark.js","hash":"39b0022f8ee6c6d443affdbf8608a86155fbf8f4","modified":1567845240954},{"_id":"themes/next-v6/source/js/local-search.js","hash":"0579159bf994e3726b3ba063e5905f79465fdfb1","modified":1567845240954},{"_id":"themes/next-v6/source/js/motion.js","hash":"d52807a73efc34b1189c096477f348d05debf861","modified":1567845240954},{"_id":"themes/next-v6/source/js/next-boot.js","hash":"2294cdcc61f265388c02955e86ff74641d18915a","modified":1567845240954},{"_id":"themes/next-v6/source/js/utils.js","hash":"1647843f7923e66e2d196c4c6ec1975d6f051917","modified":1567845240954},{"_id":"themes/next-v6/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1567845240954},{"_id":"source/_posts/读书笔记-RxJava/1564823248295.png","hash":"4db03cf707a8509d4ae6ed417e07f20f1952d987","modified":1564823248331},{"_id":"source/_posts/读书笔记-RxJava/1564802038820.png","hash":"f207e2a2fc392e6630b4c10648c86adc4955cdb7","modified":1564802038857},{"_id":"source/_posts/读书笔记-RxJava/switch.c.png","hash":"2dec2df4de7ee8710eab47829f8b2b25e55f2b58","modified":1567913248977},{"_id":"themes/next-v6/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567845240950},{"_id":"themes/next-v6/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567845240950},{"_id":"themes/next-v6/layout/_macro/menu/menu-badge.swig","hash":"9e959646899a1dd381c0bea870408cd392c93c70","modified":1567845240946},{"_id":"themes/next-v6/layout/_macro/menu/menu-item.swig","hash":"1dc3875981923aee38b7b1e3ca3813b75ed6ab9c","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/analytics/busuanzi-counter.swig","hash":"b35b2bf2ce3d73cabe8c443a45c2a82d45baf151","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/analytics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/analytics/index.swig","hash":"ac6a3995c1330d2d73300b2427006509d0f8dba5","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/analytics/firestore.swig","hash":"67e63c25d509f02a6057ee9724f1b6efd647f72f","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/analytics/tencent-analytics.swig","hash":"493a1ef6c8f475d4dd3156a6ab37690dc75695ea","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/analytics/tencent-mta.swig","hash":"198813a3f382bda4278fe3759bf0f18a5769bb33","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/head/head-unique.swig","hash":"0edd29b972aceecccb65b3e63d79c01f6639d0c5","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/header/brand.swig","hash":"9718d372887f4b0ee952da42d10b2f736d0fc6de","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/analytics/lean-analytics.swig","hash":"fb7729b69ef443db1f3f2755506ee998cfe4b973","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/header/index.swig","hash":"e0767e09a632264f189570e95ccf70fb1dad9110","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/header/menu.swig","hash":"1ba4cd71b826186b7f782bd06258f2ec52a2b491","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/head/head.swig","hash":"6236a874b93ac1be56fc21df8534a7ae8acffcfc","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/header/sub-menu.swig","hash":"c3a484d7bb15b55e4e48d412b0b30981168be6f3","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/page/page-header.swig","hash":"d3c25d70f0fd76121e4cacb9f8af4ccbe2a3c74d","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/post/post-copyright.swig","hash":"b68ccb90e2ee42bd98c93fc030a29d38689dd55c","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/post/post-footer.swig","hash":"b654d63d2ed221a8b642223e220392e5172d8f4d","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/post/post-related.swig","hash":"f05225f7d0ada3853c425899b515056b96ca49bf","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/post/wechat-subscriber.swig","hash":"2edfaf1579ea58e15cb5583fb7962dfee9af2257","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/post/post-reward.swig","hash":"90a0869c6cc351d92fc97bf42fdc6e1bfa6bc513","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1567845240946},{"_id":"themes/next-v6/layout/_partials/sidebar/site-overview.swig","hash":"4e71b26d91ab750791f3be6035a946eb96ca7b34","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/pages/schedule.swig","hash":"9e44c795565837ba318fd739e42713de365673fd","modified":1567845240946},{"_id":"themes/next-v6/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/analytics/google-analytics.swig","hash":"9f73476ebcf5cd3b7f55525b3f35dc7e9f01e154","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/analytics/application-insights.swig","hash":"7fd0459d2f1cfe1254f2c2b8087dc094c8cb0e84","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/analytics/growingio.swig","hash":"42aa3022f7739a552c7a55de316d8c0994b2fdc1","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/analytics/index.swig","hash":"20fcbed44aede1b908bd17d7a0279b03639068b1","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/chat/index.swig","hash":"5ab4a8b4306c837d2f8c211a9d7fdaed76fa254d","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/comments/disqusjs.swig","hash":"df8413cba22deffca94cf4edd6d9f8d35d2bb58f","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/comments/gitalk.swig","hash":"261c4f1ab42f692279a310943b807ed34516df7c","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/comments/valine.swig","hash":"ab937195168a0e8a911bf5730307f680e6d521e9","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/comments/disqus.swig","hash":"86092b31761948486ecb379eb7445f66a158769d","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/math/katex.swig","hash":"b9d7a99534e9c2608765b958eae3b5c50f5e4889","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/math/index.swig","hash":"bc23c9eb9c06b0b377695f44373c14c5cde1d0e3","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/math/mathjax.swig","hash":"dff6835d0b03ecc2db6919ca27cfb7b63949e6a8","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/search/algolia-search.swig","hash":"ad7a22ee0f183481c7843ecd881b9f9e8e037e31","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/search/index.swig","hash":"b2fd17688f0433571b37704bc8df798e175e7811","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/tags/index.swig","hash":"83d0a8f71878c6b96a04ba08567b9064de6cce83","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/tags/mermaid.swig","hash":"a54308f934c33b12f6bf28e4ce90e517f38cab57","modified":1567845240946},{"_id":"themes/next-v6/layout/_third-party/tags/pdf.swig","hash":"7597800b6ce2f545baea797d95d1b8c7cf624299","modified":1567845240946},{"_id":"themes/next-v6/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1567845240950},{"_id":"themes/next-v6/scripts/events/lib/config.js","hash":"b710d896fccd34657a70244645470e476a4e069f","modified":1567845240950},{"_id":"themes/next-v6/scripts/events/lib/injects.js","hash":"2a5f7c7e507bb354ec05a881bc9a1f4f2f28197c","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/changyan.js","hash":"3ac62f5510f22e9d970089bb01f96ba2134ae161","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/disqusjs.js","hash":"178c4618b29a1e06221285146071e72e24c40499","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/disqus.js","hash":"ccfac51bde0063ab7ef88182f8cbc98c210e78c9","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/facebook-comments-plugin.js","hash":"e3c74b24f3818f2504fd0c7a954adaa6681bb969","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/livere.js","hash":"3c4bdc2a682f9889a532e1cb856bc5caeb4208e1","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/valine.js","hash":"e34d38aee93558b2c68a7fa6203c2e4806405d62","modified":1567845240950},{"_id":"themes/next-v6/scripts/filters/comment/vkontakte.js","hash":"031337c2e2157628a15a5f4d96fa6e3fcf2733fe","modified":1567845240950},{"_id":"themes/next-v6/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1567845240950},{"_id":"themes/next-v6/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1567845240950},{"_id":"themes/next-v6/source/css/_mixins/base.styl","hash":"59384f63e608b272e4c8679009bbe5e6594fd1b1","modified":1567845240950},{"_id":"themes/next-v6/source/css/_variables/Gemini.styl","hash":"d9a2eff154fafff547b3aca7321eee94b450c00a","modified":1567845240950},{"_id":"themes/next-v6/source/css/_variables/Mist.styl","hash":"14e4bd0bd702c7a7f83bf7d529fade2d0634c2f1","modified":1567845240950},{"_id":"themes/next-v6/source/css/_variables/Muse.styl","hash":"1e99dfbe7736acfee59d6f54dbd6b33ddfe2fe8a","modified":1567845240950},{"_id":"themes/next-v6/source/css/_variables/Pisces.styl","hash":"db52bce619bb848189e83b7bfabd1b2a06fd5578","modified":1567845240950},{"_id":"themes/next-v6/source/css/_variables/base.styl","hash":"639b65a486154cf1f70c31f3fff440ce022255c0","modified":1567845240950},{"_id":"themes/next-v6/source/js/schemes/pisces.js","hash":"1e47ffdda23f7f645a2a883a90e2e9d9ddbf9a46","modified":1567845240954},{"_id":"themes/next-v6/source/js/schemes/muse.js","hash":"be8471d4a84b773014b46a3650887ab55116ea68","modified":1567845240954},{"_id":"themes/next-v6/source/lib/canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1567868307474},{"_id":"themes/next-v6/source/lib/canvas-nest/README.md","hash":"86998073747aefa90ebdef4f66e812a453c05442","modified":1567868307474},{"_id":"themes/next-v6/source/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"956eada198babd00f028e8908767cb158926c3f3","modified":1567868307474},{"_id":"themes/next-v6/source/lib/canvas-ribbon/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1567867704362},{"_id":"themes/next-v6/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1567868307474},{"_id":"themes/next-v6/source/lib/canvas-ribbon/README.md","hash":"0b386471ee72649b00fd32dc9a9af8206e3bf094","modified":1567867704362},{"_id":"themes/next-v6/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1567845240954},{"_id":"themes/next-v6/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1567845240954},{"_id":"themes/next-v6/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"65b1a8f12d04b15d7ed6eeb9d11dec760a799c5f","modified":1567867704362},{"_id":"themes/next-v6/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1567845240954},{"_id":"themes/next-v6/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1567845240954},{"_id":"themes/next-v6/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1567845240954},{"_id":"themes/next-v6/source/lib/three/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1567867927042},{"_id":"themes/next-v6/source/lib/three/README.md","hash":"d910457aeef1498f1318f85ec402d1043e71047c","modified":1567867927042},{"_id":"themes/next-v6/source/lib/three/.gitignore","hash":"e691fe9e685cbd50bcd7e138f4ca3503e7b0eaa4","modified":1567867927042},{"_id":"themes/next-v6/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1567845240954},{"_id":"themes/next-v6/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1567845240954},{"_id":"themes/next-v6/source/lib/three/canvas_lines.min.js","hash":"ae6584edc0418d68731cab82c1494f26bd77c07d","modified":1567867927042},{"_id":"themes/next-v6/source/lib/three/canvas_sphere.min.js","hash":"186c3bd6ae352d336cdbd0e555ee76a844854c94","modified":1567867927042},{"_id":"themes/next-v6/source/lib/three/gulpfile.js","hash":"e0e9e7051d9d82a37c2aba1df396d8b3916323c4","modified":1567867927042},{"_id":"themes/next-v6/source/lib/three/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1567867927046},{"_id":"themes/next-v6/source/lib/three/three-waves.min.js","hash":"329483be97cdda030779da9a6cd1e3eae645cf4f","modified":1567867927046},{"_id":"themes/next-v6/source/lib/three/package.json","hash":"b8cd9b9c30b159a4a271e84b0ed11be5a98c2c7c","modified":1567867927046},{"_id":"themes/next-v6/source/css/_common/components/back-to-top.styl","hash":"e0db0d9205cd47c48edba81c7397e09ed24783fa","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/back-to-top-sidebar.styl","hash":"cda066b495a4b6b10c7bc88b2a9b82722156b66b","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/buttons.styl","hash":"060aeb5cff414014f7cdbb61e0ec7855cb0d4b32","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/components.styl","hash":"6c61a120d61dec145c8db3a244cae0e724f6f3ef","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/pagination.styl","hash":"674c32b6e9df4b2294df07c3966bf6555e0fb5ad","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/rainbow.styl","hash":"8e9deaf1e0a27d5bf5f0401bf04f5637df12b6c4","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/scrollbar.styl","hash":"202ee1f1f8e64d8292df16f40ee176ff4e5d7e71","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/reading-progress.styl","hash":"0dd11537a4b9a4d2faf3ad5cdae0f0f770a99ccf","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/outline/outline.styl","hash":"b6b9dc8a350e51ad7b8bb08141a61fc2fd7466fc","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/scaffolding/base.styl","hash":"cb25eed35117be256ea7a573fec2cdfb66901dbb","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/scaffolding/helpers.styl","hash":"0c60cf489cd083d3a1e3502a240a761b656241c2","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/scaffolding/mobile.styl","hash":"c4a5c52e30444602237530f379c1707ec864fa9a","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/scaffolding/scaffolding.styl","hash":"19a20393d266b21ee44ff07d6fa1e9ebbc39a5d9","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/scaffolding/normalize.styl","hash":"4f7140cc0db08b47a25c4c7aad71047d433051a1","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/scaffolding/tables.styl","hash":"4ddbc8b2dba6fad900c5eca793a31f18ba850f5a","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Mist/_base.styl","hash":"71d75fa309cf5b96d876da536f57c047e57afcff","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Mist/_header.styl","hash":"87d19a45db10689aae9a09736efd1eb896a35b3d","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Mist/_logo.styl","hash":"3462ffd270f3e218e0a8362262466e79d731f975","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Gemini/index.styl","hash":"c42802ecca44d4ea435c26700070a65375edfd7c","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Mist/_menu.styl","hash":"73fe940abb0787a19f505fb614aafe73c8a24f08","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Mist/_posts-expand.styl","hash":"dc2a3217f9b50cf42c4262c9e486281203eaef83","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Mist/index.styl","hash":"e859283440617f18f1ad298f7f1218aafa9b39d5","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Muse/_layout.styl","hash":"54c5e23ec3dcbbc77848ededba76e861cf0f4719","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Muse/_logo.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Muse/_sidebar.styl","hash":"eeab294e14abbae231107e1a327e907b25323136","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Muse/_menu.styl","hash":"b22583b7340c2686a46aefeeed086540b08324a3","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Muse/index.styl","hash":"41b1d10a530913908e026fd991216e234766d148","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Pisces/_brand.styl","hash":"d39c8ffdc65909c29d518d3ffdff22cff75ade54","modified":1567872917635},{"_id":"themes/next-v6/source/css/_schemes/Pisces/_layout.styl","hash":"2ab9e0499f241d1b91e2f7722072d23c95104e1f","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Pisces/_menu.styl","hash":"ac523812bebb13cde268dc3cde65d0b7c6862e30","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Pisces/_sidebar.styl","hash":"44ac3dff65c1bd3fe47feeed8e58aa00c9f2fb7b","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Pisces/_sub-menu.styl","hash":"3bcb47b9b9ea671e0a3cba6a821045d3434734cb","modified":1567845240950},{"_id":"themes/next-v6/source/css/_schemes/Pisces/index.styl","hash":"10b4794ba62726fc052c74d786d962ed79d0780b","modified":1567845240950},{"_id":"themes/next-v6/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1567845240954},{"_id":"themes/next-v6/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1567845240954},{"_id":"themes/next-v6/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1567845240954},{"_id":"themes/next-v6/source/lib/three/lib/CanvasRenderer.js","hash":"cf8e1ce6e884023ad0d692cf30f399862407fb40","modified":1567867927042},{"_id":"themes/next-v6/source/lib/three/src/canvas_lines.js","hash":"650310ff6783671f8ceccf01f840b20d9c87b491","modified":1567867927046},{"_id":"themes/next-v6/source/lib/three/lib/Projector.js","hash":"1ad16e96cea2a8a9155bb429c83ef9bdd341ce99","modified":1567867927042},{"_id":"themes/next-v6/source/lib/three/src/canvas_sphere.js","hash":"7614790c67d3e79e3390fe688f6b01afad7e3bb1","modified":1567867927046},{"_id":"themes/next-v6/source/lib/three/src/three-waves.js","hash":"e98e442f14920e9fb8691846dca3a2225d403048","modified":1567867927046},{"_id":"themes/next-v6/source/lib/three/package-lock.json","hash":"57c9bed50309a639b024f96a53c62e13e1fccca1","modified":1567867927046},{"_id":"themes/next-v6/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1567845240954},{"_id":"themes/next-v6/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1567845240954},{"_id":"themes/next-v6/source/css/_common/components/footer/footer.styl","hash":"caf2abcffa5674adea300046fd3dbee2e830b40e","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/header/github-banner.styl","hash":"386fce803e5240c2d6860ae53f38ae3aa2e8b680","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/header/header.styl","hash":"1bfa07d40ceb03b0b69a5752478ca555723f7a15","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/header/menu.styl","hash":"139c17e7d4aa3e1112340a26a270efe58c279f8e","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/header/site-meta.styl","hash":"dada73ae88f01fab2ab4d2c83eddfc558de2110a","modified":1567872831993},{"_id":"themes/next-v6/source/css/_common/components/header/site-nav.styl","hash":"4718d17fc4ee30802925890771a032d966133a31","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/highlight/copy-code.styl","hash":"2124abd41b69ff152f4bb39e78d8fbce96a45c65","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/highlight/highlight.styl","hash":"4efe9174369bfe2125bd167feac18a07271635d6","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/highlight/theme.styl","hash":"a67dc85f6d158dac20e951ab55988ff7e9e1739b","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/pages/schedule.styl","hash":"919cc9aaf60b03c2bf00aca3748127f38a2026cf","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-collapse.styl","hash":"db718eee14347f30ccabaa33bf6f9fbdea8b9462","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-copyright.styl","hash":"ac2105c5a7f581b1c0f2b59f2c0c3e87a7c28383","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-eof.styl","hash":"3abf46c513e92f3f36c14d90f032983b94f36488","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-expand.styl","hash":"602a3c3d2785965b23412b5c219dfe74b5fb0844","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-gallery.styl","hash":"caa9a78993d549117cdc8fa7a76c473a5e7f0f67","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-meta.styl","hash":"c60afb603d58cad3ad13e1a16c66832538510063","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-nav.styl","hash":"2e2a09dddd2a394a635bcefb6207b6cddcb784c7","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-reward.styl","hash":"541d6257023915a7caca7540f12cdf283ce025f3","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-title.styl","hash":"5da763d541540586ccd13868a36e3da55549eb22","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-tags.styl","hash":"469d5e4e188f484abff24eddd5640fa4d4d77ed1","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post-widgets.styl","hash":"8b6481a0ac60007cf3defa3c9d85a6e412c91d6e","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/post/post.styl","hash":"e77986ca3b914348b5c3c6b34c94b49ad53e4b9c","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2ef546b4cfa5038ebb050c592c5135bbeb51af41","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar-button.styl","hash":"41ccae779f918e6f9f5f625789a7360f1362454c","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"d055f8420583c7a009818dcdfaada592308bd628","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"f3108a247549fbdf11071d023add3f1b34ad2b23","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"db44ef2b99fc33d003010f38e64caad930c08ad0","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"782cf8847c9aca96f9194fcf1d910509e4073ce6","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/sidebar.styl","hash":"17c3f58fb84453603621d6a718fcc821c8d6bced","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/sidebar/site-state.styl","hash":"02e5a998748a67fa885fb06fae242bcf3f2786fb","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/tags/blockquote-center.styl","hash":"0527bc64708a9446dc7bbb2c7e39ab3a61251c26","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/tags/group-pictures.styl","hash":"514999bde116ef5cd5f7aedea80059b12a87a1ea","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/tags/label.styl","hash":"78d309e22206a4addda3c393282518dae02250ed","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/tags/note.styl","hash":"a1eed8fe7f97885a9234502a197abf2e90ba22b6","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/tags/tabs.styl","hash":"754f70161b7e810f582cc4755d177859dcbcfced","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/third-party/related-posts.styl","hash":"85b8606763f4177d2f9a11c1909a21ab1ae2011c","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/third-party/search.styl","hash":"38ce7d692b8bc6fde02e3271dfd50ad37e107e4e","modified":1567845240950},{"_id":"themes/next-v6/source/css/_common/components/third-party/third-party.styl","hash":"4525465f40f82bd66e5f34e986440c75a9e2d2b2","modified":1567845240950},{"_id":"themes/next-v6/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1567845240954},{"_id":"themes/next-v6/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1567867927054}],"Category":[{"name":"工具","_id":"ck0atmo93000400bn38felm9q"},{"name":"Spring Webflow","_id":"ck0atmo98000b00bn0uaz3awb"},{"name":"Git","_id":"ck0atmo9c000g00bnuo05sois"},{"name":"python","_id":"ck0atmo9i001100bnuj25cb53"},{"name":"随笔","_id":"ck0atmo9j001900bnz30zwhcz"},{"name":"推荐系统","_id":"ck0atmo9k001d00bn3e51iw7q"},{"name":"RxJava","_id":"ck0atmo9l001j00bn5lw17xrf"},{"name":"http","_id":"ck0atmo9l001m00bnaw2un142"}],"Data":[],"Page":[{"title":"关于","date":"2019-09-07T03:35:10.000Z","comments":0,"_content":"# 我?\n叫我: 果冻\n代号: floyd; guodong; gd; zou8944\nEmail: zou-guo-dong@163.com\n\n# 关于这里\n2015年, 我是硬件狗, 一直想要写点什么, 开始接触博客, 试着写了一两篇, 没什么感觉, 于是放弃\n\n\n2016年, 还是硬件狗, 开始自学软件, 断断续续在CSDN上更新自己的学习笔记\n\n\n2017年, 程序猿变身中, 一整年没写过一片博客, 忙于应付各种琐碎和心理斗争\n\n\n2018年, 程序猿变身完成, 再次开始断断续续更新博客, 尽管质量不高, 但一篇1.8W访问量的日志让我为之振奋, 有一丢丢成就感\n\n\n2019年, 买了域名zouguodong.top, 买了云主机, 搭建一个属于自己的地方. 放肆地撒野.\n> \\# 更新于2019-09-07\n\n# 干过啥\n- 花两年时间尝试了硬件狗的滋味, 发现其实不喜欢\n- 一年半外包公司后端程序员, 练就了坐冷板凳自我激励的心态\n\n# 在干啥\n- 积累技术, 努力工作, 坚持学习, 认真生活\n- 多学语言, 多学思想\n- Java, Kotlin, Python, 异步","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2019-09-07 11:35:10\ncomments: false\n---\n# 我?\n叫我: 果冻\n代号: floyd; guodong; gd; zou8944\nEmail: zou-guo-dong@163.com\n\n# 关于这里\n2015年, 我是硬件狗, 一直想要写点什么, 开始接触博客, 试着写了一两篇, 没什么感觉, 于是放弃\n\n\n2016年, 还是硬件狗, 开始自学软件, 断断续续在CSDN上更新自己的学习笔记\n\n\n2017年, 程序猿变身中, 一整年没写过一片博客, 忙于应付各种琐碎和心理斗争\n\n\n2018年, 程序猿变身完成, 再次开始断断续续更新博客, 尽管质量不高, 但一篇1.8W访问量的日志让我为之振奋, 有一丢丢成就感\n\n\n2019年, 买了域名zouguodong.top, 买了云主机, 搭建一个属于自己的地方. 放肆地撒野.\n> \\# 更新于2019-09-07\n\n# 干过啥\n- 花两年时间尝试了硬件狗的滋味, 发现其实不喜欢\n- 一年半外包公司后端程序员, 练就了坐冷板凳自我激励的心态\n\n# 在干啥\n- 积累技术, 努力工作, 坚持学习, 认真生活\n- 多学语言, 多学思想\n- Java, Kotlin, Python, 异步","updated":"2019-09-07T09:50:15.786Z","path":"about/index.html","layout":"page","_id":"ck0atmo8z000100bnw8mni2hu","content":"<h1 id=\"我\"><a href=\"#我\" class=\"headerlink\" title=\"我?\"></a>我?</h1><p>叫我: 果冻<br>代号: floyd; guodong; gd; zou8944<br>Email: <a href=\"mailto:zou-guo-dong@163.com\" target=\"_blank\" rel=\"noopener\">zou-guo-dong@163.com</a></p><h1 id=\"关于这里\"><a href=\"#关于这里\" class=\"headerlink\" title=\"关于这里\"></a>关于这里</h1><p>2015年, 我是硬件狗, 一直想要写点什么, 开始接触博客, 试着写了一两篇, 没什么感觉, 于是放弃</p><p>2016年, 还是硬件狗, 开始自学软件, 断断续续在CSDN上更新自己的学习笔记</p><a id=\"more\"></a>\n\n\n<p>2017年, 程序猿变身中, 一整年没写过一片博客, 忙于应付各种琐碎和心理斗争</p>\n<p>2018年, 程序猿变身完成, 再次开始断断续续更新博客, 尽管质量不高, 但一篇1.8W访问量的日志让我为之振奋, 有一丢丢成就感</p>\n<p>2019年, 买了域名zouguodong.top, 买了云主机, 搭建一个属于自己的地方. 放肆地撒野.</p>\n<blockquote>\n<p># 更新于2019-09-07</p>\n</blockquote>\n<h1 id=\"干过啥\"><a href=\"#干过啥\" class=\"headerlink\" title=\"干过啥\"></a>干过啥</h1><ul>\n<li>花两年时间尝试了硬件狗的滋味, 发现其实不喜欢</li>\n<li>一年半外包公司后端程序员, 练就了坐冷板凳自我激励的心态</li>\n</ul>\n<h1 id=\"在干啥\"><a href=\"#在干啥\" class=\"headerlink\" title=\"在干啥\"></a>在干啥</h1><ul>\n<li>积累技术, 努力工作, 坚持学习, 认真生活</li>\n<li>多学语言, 多学思想</li>\n<li>Java, Kotlin, Python, 异步</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"我\"><a href=\"#我\" class=\"headerlink\" title=\"我?\"></a>我?</h1><p>叫我: 果冻<br>代号: floyd; guodong; gd; zou8944<br>Email: <a href=\"mailto:zou-guo-dong@163.com\" target=\"_blank\" rel=\"noopener\">zou-guo-dong@163.com</a></p><h1 id=\"关于这里\"><a href=\"#关于这里\" class=\"headerlink\" title=\"关于这里\"></a>关于这里</h1><p>2015年, 我是硬件狗, 一直想要写点什么, 开始接触博客, 试着写了一两篇, 没什么感觉, 于是放弃</p><p>2016年, 还是硬件狗, 开始自学软件, 断断续续在CSDN上更新自己的学习笔记</p>","more":"\n\n\n<p>2017年, 程序猿变身中, 一整年没写过一片博客, 忙于应付各种琐碎和心理斗争</p>\n<p>2018年, 程序猿变身完成, 再次开始断断续续更新博客, 尽管质量不高, 但一篇1.8W访问量的日志让我为之振奋, 有一丢丢成就感</p>\n<p>2019年, 买了域名zouguodong.top, 买了云主机, 搭建一个属于自己的地方. 放肆地撒野.</p>\n<blockquote>\n<p># 更新于2019-09-07</p>\n</blockquote>\n<h1 id=\"干过啥\"><a href=\"#干过啥\" class=\"headerlink\" title=\"干过啥\"></a>干过啥</h1><ul>\n<li>花两年时间尝试了硬件狗的滋味, 发现其实不喜欢</li>\n<li>一年半外包公司后端程序员, 练就了坐冷板凳自我激励的心态</li>\n</ul>\n<h1 id=\"在干啥\"><a href=\"#在干啥\" class=\"headerlink\" title=\"在干啥\"></a>在干啥</h1><ul>\n<li>积累技术, 努力工作, 坚持学习, 认真生活</li>\n<li>多学语言, 多学思想</li>\n<li>Java, Kotlin, Python, 异步</li>\n</ul>\n"},{"title":"标签","date":"2019-09-06T11:09:33.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-09-06 19:09:33\ntype: tags\ncomments: false\n---\n","updated":"2019-09-07T09:50:10.642Z","path":"tags/index.html","layout":"page","_id":"ck0atmo91000300bn9hao1lep","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"留言板","date":"2019-09-07T09:52:36.000Z","_content":"","source":"guestbook/index.md","raw":"---\ntitle: 留言板\ndate: 2019-09-07 17:52:36\n---\n","updated":"2019-09-07T09:53:09.533Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"ck0atmo95000700bnsfyjm8jv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2019-09-06T11:09:55.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-09-06 19:09:55\ntype: categories\ncomments: false\n---\n","updated":"2019-09-07T09:50:12.610Z","path":"categories/index.html","layout":"page","_id":"ck0atmo96000900bn9cnzpd1d","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Common FileUpload介绍","date":"2019-09-07T14:31:33.000Z","_content":"\n> 这是一篇半翻译半笔记式的文章，如果你之前对Common FileUpload了解不多，本文可以快速了解如何使用方法，如果你有时间，推荐你看[官方文档](http://commons.apache.org/proper/commons-fileupload/using.html)\n\n# 概述\nFileUpload能够以多种不同的方式使用，具体取决于应用程序的要求。在最简单的情况下，您将调用单个方法来解析servlet请求，然后处理解析出来的Item集合。此外也可以自定义FileUpload以完全控制各个Item的存储方式，比如设置缓存目录、直接将接收到的Item以流的形式写入数据库等。\n\n> FileUpload依赖于Commons IO，因此类路径下要有Commons IO的jar包。当然采用Maven依赖的方式不用担心，maven会自动为我们下载Commons IO包\n\n# 工作原理\nFileUpload依据规范[RFC1867](http://www.ietf.org/rfc/rfc1867.txt)中\"基于表单的HTML文件上载\"对上传的文件数据进行解析，解析出来的每个项目对应一个FileItem对象。\n每个FileItem都有许多我们可能感兴趣的属性：获取contentType，获取原本的文件名，获取文件大小，获取FiledName(如果是表单域上传)，判断是否在内存中，判断是否属于表单域等。\nFileUpload使用**FileItemFactory**创建新的FileItem。该工厂可以控制每个项目的创建方式。目前提供的工厂实现可以将项目的数据存储临时存储在内存或磁盘上，具体取决于项目的大小（即数据字节，在指定的大小内时，存在内存中，超出范围，存在磁盘上）。\n# 开始之前的判断\n在处理上传项目前，最好是先解析一下当前请求是否属于文件上传请求，采用如下方式：\n\n```\n//检查我们是否有文件上传请求\nboolean isMultipart = ServletFileUpload.isMultipartContent(request);\n```\n该方法的原理也很简单，就是获取request的contentType以判断是否是multipart，源码如下：\n\n```\npublic static final boolean isMultipartContent(\n            HttpServletRequest request) {\n    if (!POST_METHOD.equalsIgnoreCase(request.getMethod())) {\n        return false;\n    }\n    return FileUploadBase.isMultipartContent(new ServletRequestContext(request));\n}\n```\n\n```\npublic static final String MULTIPART = \"multipart/\";\n... ...\n... ...\npublic static final boolean isMultipartContent(RequestContext ctx) {\n    String contentType = ctx.getContentType();\n    if (contentType == null) {\n        return false;\n    }\n    if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) {\n        return true;\n    }\n    return false;\n}\n```\n\n# 可用的最简配置\n有两种方式能够接收上传文件\n\n - 传统方式：首先创建FileItemFactory，创建ServletFileUpload时传入factory，再从upload对象获取FileItem，然后调用write(File)直接写入文件。这种方式将接收到的文件临时存储到内存或磁盘中，后续用户再进行处理，比较方便，但是占用时间和空间\n - 流方式：直接ServletFileUpload中获取FileItem，再从FileItem中获取输入流，从流中直接接收数据，没有临时缓存这一步。使用没那么方便，但是比较节省时间和空间\n\n如下演示两种方式\n## 使用传统API\n\n```\n// Create a factory for disk-based file items\nDiskFileItemFactory factory = new DiskFileItemFactory();\n\n// Configure a repository (to ensure a secure temp location is used)\nServletContext servletContext = this.getServletConfig().getServletContext();\nFile repository = (File) servletContext.getAttribute(\"javax.servlet.context.tempdir\");\nfactory.setRepository(repository);\n\n// Create a new file upload handler\nServletFileUpload upload = new ServletFileUpload(factory);\n\n// Parse the request\nList<FileItem> items = upload.parseRequest(request);\nIterator<FileItem> iter = items.iterator();\nwhile (iter.hasNext()) {\n    FileItem item = iter.next();\n    \n    // upload 是这里假定的上传文件的field name\n    if(\"upload\".equals(item.getFieldName)){\n\t    File uploadFile = new File(\"...\");\n\t    item.write(uploadFile);\n    }\n}\n```\nFileItemFctory可以设置的内容如下\n\n```\nfactory.setRepository(File dir); // 设置临时文件存储位置\nfactory.setSizeThreshold(long bytes); // 设置请求大小阈值，当请求大于该值时，接收到的数据是缓存在磁盘中的，否则直接缓存在内存中。\nfactory.setFileCleaningTracker(FileCleaningTracker pTracker); // 设置临时文件清理跟踪器，后面会讲到\n```\nServletFileUpload可以设置的内容如下：\n\n```\nupload.setMaxSize(long bytes); //设置整个请求的最大值，大于该值时，是不允许传送的\nupload.setFileMaxSize(long bytes); //设置单个文件的最大值，大于该值时，大于该值时，是不允许传送的\nupload.setHeaderEncoding(String charset); // 设置读取每个FileItem的头数据的字符编码，不设置时采用request的编码，也没有时采用系统默认编码\nupload.setProgressListener(ProgressListener pListener); // 设置上传进度监听器，后面会讲\n```\nFileItem能够获取的内容如下：\n\n```\nitem.getContentType(); // 获取单个Item的ContentType\nitem.getName(); // 获取item本来的文件名，如果不是文件则为null\nitem.getFieldName(); // 获取item的field名\nitem.getSize(); // 获取item的大小\nitem.get(); // 将item转换成字节数组返回\nitem.isInMemory(); // item目前是否存在内存中\nitem.isFormField(); // 是否是表单域\nitem.getInputStream(); // 获取输入流，用于读取item\n```\n\n## 使用流API\n这种方式其实说来应该是最好的选择，因为他也并不麻烦，而且节省了缓存的空间和时间，在性能上是最好的选择。只需要按照如下方式使用即可\n```\n// Create a new file upload handler\nServletFileUpload upload = new ServletFileUpload();\n\n// Parse the request\nFileItemIterator iter = upload.getItemIterator(request);\nwhile (iter.hasNext()) {\n    FileItemStream item = iter.next();\n    String fileName = item.getName();\n    InputStream stream = item.getInputStream();\n    FileOutputStream os = new FileOutputStream(new File(fileName));\n    /*\n\t *\t在这里将输入流的内容写入输出流即可\n\t */\n}\n```\n\n# 文件上传进度监听器\n当上传文件非常大时，进度监听器就能够排上用场了，使用方式也非常简单，创建监听器对象，设置到ServletFileUpload即可。\n\n```\nProgressListener listener = new ProgressListener() {\n    /*\n     * pBytesRead: 到目前为止总共读了多少个Byte\n     * pContentLength: 整个content的长度，按Byte计算，也有可能是未知的：-1\n     * pItems: 正在读取的item编号，0代表尚未开始读取，1代表第一个，以此类推\n     */\n    public void update(long pBytesRead, long pContentLength, int pItems) {\n        // 获取进度百分比，并放在session中\n        request.getSession().setAttribute(\"progress\", 1.0*pBytesRead/pContentLength);\n    }\n};\nupload.setProgressListener(progressListener);\n\n```\n此处有一个问题：监听器会被频繁调用，当其内部实现的逻辑较为简单时，可能无伤大雅，但当逻辑较为复杂或占用资源时，监听器就可能影响到程序的性能。\n解决方案：以某种方式减少监听器内部逻辑执行的次数，比如下面这种方式\n\n```\nProgressListener progressListener = new ProgressListener(){\n   private long megaBytes = -1;\n   public void update(long pBytesRead, long pContentLength, int pItems) {\n\t   // 每接收1M数据才执行一次后面的动作\n       long mBytes = pBytesRead / 1000000;\n       if (megaBytes == mBytes) {\n           return;\n       }\n       megaBytes = mBytes;\n       request.getSession().setAttribute(\"progress\", 1.0*pBytesRead/pContentLength);\n   }\n};\n```\n\n# 临时文件清理跟踪器\n文件清理跟踪器仅适用于传统方式: 传统方式在处理文件之前将文件写入临时文件，这样的临时文件在我们上传任务完成时就成了垃圾，需要进行自动回收。Cmmons FileUpload当然也提供了这个功能，其运行原理：org.apache.commons.io.FileCleanerTracker开启一个收割线程，在DiskFileItem被垃圾回收器回收时，自动清理掉对应的临时文件。\n要想开启文件自动清理功能，需要按照如下配置：\n\n - 在Servlet中我们应该在web.xml中配置一个Servlet监听器\n```\n<listener>\n  <listener-class>\n    org.apache.commons.fileupload.servlet.FileCleanerCleanup\n  </listener-class>\n</listener>\n```\n - 创建org.apache.commons.io.FileCleaningTracker对象，设置给DiskFileItemFactory。\n\n```\nFileCleaningTracker fileCleaningTracker = FileCleanerCleanup.getFileCleaningTracker(context);\nDiskFileItemFactory factory = new DiskFileItemFactory();\nfactory.setFileCleaningTracker(fileCleaningTracker);\n```\n - 然后就是按照我们之前学习的步骤正常操作即可\n\n要想禁用临时文件自动删除功能，可将FileCleaningTracker设置为null(其实默认就为null)\n\n```\nfactory.setFileCleaningTracker(null);\n```","source":"_posts/Common FileUpload介绍.md","raw":"---\ntitle: Common FileUpload介绍\ndate: 2019-09-07 22:31:33\ntags: \n    - fileupload\n    - apache\ncategories: \n    - 工具\n---\n\n> 这是一篇半翻译半笔记式的文章，如果你之前对Common FileUpload了解不多，本文可以快速了解如何使用方法，如果你有时间，推荐你看[官方文档](http://commons.apache.org/proper/commons-fileupload/using.html)\n\n# 概述\nFileUpload能够以多种不同的方式使用，具体取决于应用程序的要求。在最简单的情况下，您将调用单个方法来解析servlet请求，然后处理解析出来的Item集合。此外也可以自定义FileUpload以完全控制各个Item的存储方式，比如设置缓存目录、直接将接收到的Item以流的形式写入数据库等。\n\n> FileUpload依赖于Commons IO，因此类路径下要有Commons IO的jar包。当然采用Maven依赖的方式不用担心，maven会自动为我们下载Commons IO包\n\n# 工作原理\nFileUpload依据规范[RFC1867](http://www.ietf.org/rfc/rfc1867.txt)中\"基于表单的HTML文件上载\"对上传的文件数据进行解析，解析出来的每个项目对应一个FileItem对象。\n每个FileItem都有许多我们可能感兴趣的属性：获取contentType，获取原本的文件名，获取文件大小，获取FiledName(如果是表单域上传)，判断是否在内存中，判断是否属于表单域等。\nFileUpload使用**FileItemFactory**创建新的FileItem。该工厂可以控制每个项目的创建方式。目前提供的工厂实现可以将项目的数据存储临时存储在内存或磁盘上，具体取决于项目的大小（即数据字节，在指定的大小内时，存在内存中，超出范围，存在磁盘上）。\n# 开始之前的判断\n在处理上传项目前，最好是先解析一下当前请求是否属于文件上传请求，采用如下方式：\n\n```\n//检查我们是否有文件上传请求\nboolean isMultipart = ServletFileUpload.isMultipartContent(request);\n```\n该方法的原理也很简单，就是获取request的contentType以判断是否是multipart，源码如下：\n\n```\npublic static final boolean isMultipartContent(\n            HttpServletRequest request) {\n    if (!POST_METHOD.equalsIgnoreCase(request.getMethod())) {\n        return false;\n    }\n    return FileUploadBase.isMultipartContent(new ServletRequestContext(request));\n}\n```\n\n```\npublic static final String MULTIPART = \"multipart/\";\n... ...\n... ...\npublic static final boolean isMultipartContent(RequestContext ctx) {\n    String contentType = ctx.getContentType();\n    if (contentType == null) {\n        return false;\n    }\n    if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) {\n        return true;\n    }\n    return false;\n}\n```\n\n# 可用的最简配置\n有两种方式能够接收上传文件\n\n - 传统方式：首先创建FileItemFactory，创建ServletFileUpload时传入factory，再从upload对象获取FileItem，然后调用write(File)直接写入文件。这种方式将接收到的文件临时存储到内存或磁盘中，后续用户再进行处理，比较方便，但是占用时间和空间\n - 流方式：直接ServletFileUpload中获取FileItem，再从FileItem中获取输入流，从流中直接接收数据，没有临时缓存这一步。使用没那么方便，但是比较节省时间和空间\n\n如下演示两种方式\n## 使用传统API\n\n```\n// Create a factory for disk-based file items\nDiskFileItemFactory factory = new DiskFileItemFactory();\n\n// Configure a repository (to ensure a secure temp location is used)\nServletContext servletContext = this.getServletConfig().getServletContext();\nFile repository = (File) servletContext.getAttribute(\"javax.servlet.context.tempdir\");\nfactory.setRepository(repository);\n\n// Create a new file upload handler\nServletFileUpload upload = new ServletFileUpload(factory);\n\n// Parse the request\nList<FileItem> items = upload.parseRequest(request);\nIterator<FileItem> iter = items.iterator();\nwhile (iter.hasNext()) {\n    FileItem item = iter.next();\n    \n    // upload 是这里假定的上传文件的field name\n    if(\"upload\".equals(item.getFieldName)){\n\t    File uploadFile = new File(\"...\");\n\t    item.write(uploadFile);\n    }\n}\n```\nFileItemFctory可以设置的内容如下\n\n```\nfactory.setRepository(File dir); // 设置临时文件存储位置\nfactory.setSizeThreshold(long bytes); // 设置请求大小阈值，当请求大于该值时，接收到的数据是缓存在磁盘中的，否则直接缓存在内存中。\nfactory.setFileCleaningTracker(FileCleaningTracker pTracker); // 设置临时文件清理跟踪器，后面会讲到\n```\nServletFileUpload可以设置的内容如下：\n\n```\nupload.setMaxSize(long bytes); //设置整个请求的最大值，大于该值时，是不允许传送的\nupload.setFileMaxSize(long bytes); //设置单个文件的最大值，大于该值时，大于该值时，是不允许传送的\nupload.setHeaderEncoding(String charset); // 设置读取每个FileItem的头数据的字符编码，不设置时采用request的编码，也没有时采用系统默认编码\nupload.setProgressListener(ProgressListener pListener); // 设置上传进度监听器，后面会讲\n```\nFileItem能够获取的内容如下：\n\n```\nitem.getContentType(); // 获取单个Item的ContentType\nitem.getName(); // 获取item本来的文件名，如果不是文件则为null\nitem.getFieldName(); // 获取item的field名\nitem.getSize(); // 获取item的大小\nitem.get(); // 将item转换成字节数组返回\nitem.isInMemory(); // item目前是否存在内存中\nitem.isFormField(); // 是否是表单域\nitem.getInputStream(); // 获取输入流，用于读取item\n```\n\n## 使用流API\n这种方式其实说来应该是最好的选择，因为他也并不麻烦，而且节省了缓存的空间和时间，在性能上是最好的选择。只需要按照如下方式使用即可\n```\n// Create a new file upload handler\nServletFileUpload upload = new ServletFileUpload();\n\n// Parse the request\nFileItemIterator iter = upload.getItemIterator(request);\nwhile (iter.hasNext()) {\n    FileItemStream item = iter.next();\n    String fileName = item.getName();\n    InputStream stream = item.getInputStream();\n    FileOutputStream os = new FileOutputStream(new File(fileName));\n    /*\n\t *\t在这里将输入流的内容写入输出流即可\n\t */\n}\n```\n\n# 文件上传进度监听器\n当上传文件非常大时，进度监听器就能够排上用场了，使用方式也非常简单，创建监听器对象，设置到ServletFileUpload即可。\n\n```\nProgressListener listener = new ProgressListener() {\n    /*\n     * pBytesRead: 到目前为止总共读了多少个Byte\n     * pContentLength: 整个content的长度，按Byte计算，也有可能是未知的：-1\n     * pItems: 正在读取的item编号，0代表尚未开始读取，1代表第一个，以此类推\n     */\n    public void update(long pBytesRead, long pContentLength, int pItems) {\n        // 获取进度百分比，并放在session中\n        request.getSession().setAttribute(\"progress\", 1.0*pBytesRead/pContentLength);\n    }\n};\nupload.setProgressListener(progressListener);\n\n```\n此处有一个问题：监听器会被频繁调用，当其内部实现的逻辑较为简单时，可能无伤大雅，但当逻辑较为复杂或占用资源时，监听器就可能影响到程序的性能。\n解决方案：以某种方式减少监听器内部逻辑执行的次数，比如下面这种方式\n\n```\nProgressListener progressListener = new ProgressListener(){\n   private long megaBytes = -1;\n   public void update(long pBytesRead, long pContentLength, int pItems) {\n\t   // 每接收1M数据才执行一次后面的动作\n       long mBytes = pBytesRead / 1000000;\n       if (megaBytes == mBytes) {\n           return;\n       }\n       megaBytes = mBytes;\n       request.getSession().setAttribute(\"progress\", 1.0*pBytesRead/pContentLength);\n   }\n};\n```\n\n# 临时文件清理跟踪器\n文件清理跟踪器仅适用于传统方式: 传统方式在处理文件之前将文件写入临时文件，这样的临时文件在我们上传任务完成时就成了垃圾，需要进行自动回收。Cmmons FileUpload当然也提供了这个功能，其运行原理：org.apache.commons.io.FileCleanerTracker开启一个收割线程，在DiskFileItem被垃圾回收器回收时，自动清理掉对应的临时文件。\n要想开启文件自动清理功能，需要按照如下配置：\n\n - 在Servlet中我们应该在web.xml中配置一个Servlet监听器\n```\n<listener>\n  <listener-class>\n    org.apache.commons.fileupload.servlet.FileCleanerCleanup\n  </listener-class>\n</listener>\n```\n - 创建org.apache.commons.io.FileCleaningTracker对象，设置给DiskFileItemFactory。\n\n```\nFileCleaningTracker fileCleaningTracker = FileCleanerCleanup.getFileCleaningTracker(context);\nDiskFileItemFactory factory = new DiskFileItemFactory();\nfactory.setFileCleaningTracker(fileCleaningTracker);\n```\n - 然后就是按照我们之前学习的步骤正常操作即可\n\n要想禁用临时文件自动删除功能，可将FileCleaningTracker设置为null(其实默认就为null)\n\n```\nfactory.setFileCleaningTracker(null);\n```","slug":"Common FileUpload介绍","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo8w000000bn97j2objf","content":"<blockquote>\n<p>这是一篇半翻译半笔记式的文章，如果你之前对Common FileUpload了解不多，本文可以快速了解如何使用方法，如果你有时间，推荐你看<a href=\"http://commons.apache.org/proper/commons-fileupload/using.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n</blockquote><h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>FileUpload能够以多种不同的方式使用，具体取决于应用程序的要求。在最简单的情况下，您将调用单个方法来解析servlet请求，然后处理解析出来的Item集合。此外也可以自定义FileUpload以完全控制各个Item的存储方式，比如设置缓存目录、直接将接收到的Item以流的形式写入数据库等。</p><a id=\"more\"></a>\n\n<blockquote>\n<p>FileUpload依赖于Commons IO，因此类路径下要有Commons IO的jar包。当然采用Maven依赖的方式不用担心，maven会自动为我们下载Commons IO包</p>\n</blockquote>\n<h1 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h1><p>FileUpload依据规范<a href=\"http://www.ietf.org/rfc/rfc1867.txt\" target=\"_blank\" rel=\"noopener\">RFC1867</a>中”基于表单的HTML文件上载”对上传的文件数据进行解析，解析出来的每个项目对应一个FileItem对象。<br>每个FileItem都有许多我们可能感兴趣的属性：获取contentType，获取原本的文件名，获取文件大小，获取FiledName(如果是表单域上传)，判断是否在内存中，判断是否属于表单域等。<br>FileUpload使用<strong>FileItemFactory</strong>创建新的FileItem。该工厂可以控制每个项目的创建方式。目前提供的工厂实现可以将项目的数据存储临时存储在内存或磁盘上，具体取决于项目的大小（即数据字节，在指定的大小内时，存在内存中，超出范围，存在磁盘上）。</p>\n<h1 id=\"开始之前的判断\"><a href=\"#开始之前的判断\" class=\"headerlink\" title=\"开始之前的判断\"></a>开始之前的判断</h1><p>在处理上传项目前，最好是先解析一下当前请求是否属于文件上传请求，采用如下方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//检查我们是否有文件上传请求</span><br><span class=\"line\">boolean isMultipart = ServletFileUpload.isMultipartContent(request);</span><br></pre></td></tr></table></figure>\n\n<p>该方法的原理也很简单，就是获取request的contentType以判断是否是multipart，源码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final boolean isMultipartContent(</span><br><span class=\"line\">            HttpServletRequest request) &#123;</span><br><span class=\"line\">    if (!POST_METHOD.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return FileUploadBase.isMultipartContent(new ServletRequestContext(request));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final String MULTIPART = &quot;multipart/&quot;;</span><br><span class=\"line\">... ...</span><br><span class=\"line\">... ...</span><br><span class=\"line\">public static final boolean isMultipartContent(RequestContext ctx) &#123;</span><br><span class=\"line\">    String contentType = ctx.getContentType();</span><br><span class=\"line\">    if (contentType == null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可用的最简配置\"><a href=\"#可用的最简配置\" class=\"headerlink\" title=\"可用的最简配置\"></a>可用的最简配置</h1><p>有两种方式能够接收上传文件</p>\n<ul>\n<li>传统方式：首先创建FileItemFactory，创建ServletFileUpload时传入factory，再从upload对象获取FileItem，然后调用write(File)直接写入文件。这种方式将接收到的文件临时存储到内存或磁盘中，后续用户再进行处理，比较方便，但是占用时间和空间</li>\n<li>流方式：直接ServletFileUpload中获取FileItem，再从FileItem中获取输入流，从流中直接接收数据，没有临时缓存这一步。使用没那么方便，但是比较节省时间和空间</li>\n</ul>\n<p>如下演示两种方式</p>\n<h2 id=\"使用传统API\"><a href=\"#使用传统API\" class=\"headerlink\" title=\"使用传统API\"></a>使用传统API</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create a factory for disk-based file items</span><br><span class=\"line\">DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">// Configure a repository (to ensure a secure temp location is used)</span><br><span class=\"line\">ServletContext servletContext = this.getServletConfig().getServletContext();</span><br><span class=\"line\">File repository = (File) servletContext.getAttribute(&quot;javax.servlet.context.tempdir&quot;);</span><br><span class=\"line\">factory.setRepository(repository);</span><br><span class=\"line\"></span><br><span class=\"line\">// Create a new file upload handler</span><br><span class=\"line\">ServletFileUpload upload = new ServletFileUpload(factory);</span><br><span class=\"line\"></span><br><span class=\"line\">// Parse the request</span><br><span class=\"line\">List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class=\"line\">Iterator&lt;FileItem&gt; iter = items.iterator();</span><br><span class=\"line\">while (iter.hasNext()) &#123;</span><br><span class=\"line\">    FileItem item = iter.next();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // upload 是这里假定的上传文件的field name</span><br><span class=\"line\">    if(&quot;upload&quot;.equals(item.getFieldName))&#123;</span><br><span class=\"line\">\t    File uploadFile = new File(&quot;...&quot;);</span><br><span class=\"line\">\t    item.write(uploadFile);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FileItemFctory可以设置的内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factory.setRepository(File dir); // 设置临时文件存储位置</span><br><span class=\"line\">factory.setSizeThreshold(long bytes); // 设置请求大小阈值，当请求大于该值时，接收到的数据是缓存在磁盘中的，否则直接缓存在内存中。</span><br><span class=\"line\">factory.setFileCleaningTracker(FileCleaningTracker pTracker); // 设置临时文件清理跟踪器，后面会讲到</span><br></pre></td></tr></table></figure>\n\n<p>ServletFileUpload可以设置的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upload.setMaxSize(long bytes); //设置整个请求的最大值，大于该值时，是不允许传送的</span><br><span class=\"line\">upload.setFileMaxSize(long bytes); //设置单个文件的最大值，大于该值时，大于该值时，是不允许传送的</span><br><span class=\"line\">upload.setHeaderEncoding(String charset); // 设置读取每个FileItem的头数据的字符编码，不设置时采用request的编码，也没有时采用系统默认编码</span><br><span class=\"line\">upload.setProgressListener(ProgressListener pListener); // 设置上传进度监听器，后面会讲</span><br></pre></td></tr></table></figure>\n\n<p>FileItem能够获取的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item.getContentType(); // 获取单个Item的ContentType</span><br><span class=\"line\">item.getName(); // 获取item本来的文件名，如果不是文件则为null</span><br><span class=\"line\">item.getFieldName(); // 获取item的field名</span><br><span class=\"line\">item.getSize(); // 获取item的大小</span><br><span class=\"line\">item.get(); // 将item转换成字节数组返回</span><br><span class=\"line\">item.isInMemory(); // item目前是否存在内存中</span><br><span class=\"line\">item.isFormField(); // 是否是表单域</span><br><span class=\"line\">item.getInputStream(); // 获取输入流，用于读取item</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用流API\"><a href=\"#使用流API\" class=\"headerlink\" title=\"使用流API\"></a>使用流API</h2><p>这种方式其实说来应该是最好的选择，因为他也并不麻烦，而且节省了缓存的空间和时间，在性能上是最好的选择。只需要按照如下方式使用即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create a new file upload handler</span><br><span class=\"line\">ServletFileUpload upload = new ServletFileUpload();</span><br><span class=\"line\"></span><br><span class=\"line\">// Parse the request</span><br><span class=\"line\">FileItemIterator iter = upload.getItemIterator(request);</span><br><span class=\"line\">while (iter.hasNext()) &#123;</span><br><span class=\"line\">    FileItemStream item = iter.next();</span><br><span class=\"line\">    String fileName = item.getName();</span><br><span class=\"line\">    InputStream stream = item.getInputStream();</span><br><span class=\"line\">    FileOutputStream os = new FileOutputStream(new File(fileName));</span><br><span class=\"line\">    /*</span><br><span class=\"line\">\t *\t在这里将输入流的内容写入输出流即可</span><br><span class=\"line\">\t */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"文件上传进度监听器\"><a href=\"#文件上传进度监听器\" class=\"headerlink\" title=\"文件上传进度监听器\"></a>文件上传进度监听器</h1><p>当上传文件非常大时，进度监听器就能够排上用场了，使用方式也非常简单，创建监听器对象，设置到ServletFileUpload即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProgressListener listener = new ProgressListener() &#123;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * pBytesRead: 到目前为止总共读了多少个Byte</span><br><span class=\"line\">     * pContentLength: 整个content的长度，按Byte计算，也有可能是未知的：-1</span><br><span class=\"line\">     * pItems: 正在读取的item编号，0代表尚未开始读取，1代表第一个，以此类推</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void update(long pBytesRead, long pContentLength, int pItems) &#123;</span><br><span class=\"line\">        // 获取进度百分比，并放在session中</span><br><span class=\"line\">        request.getSession().setAttribute(&quot;progress&quot;, 1.0*pBytesRead/pContentLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">upload.setProgressListener(progressListener);</span><br></pre></td></tr></table></figure>\n\n<p>此处有一个问题：监听器会被频繁调用，当其内部实现的逻辑较为简单时，可能无伤大雅，但当逻辑较为复杂或占用资源时，监听器就可能影响到程序的性能。<br>解决方案：以某种方式减少监听器内部逻辑执行的次数，比如下面这种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProgressListener progressListener = new ProgressListener()&#123;</span><br><span class=\"line\">   private long megaBytes = -1;</span><br><span class=\"line\">   public void update(long pBytesRead, long pContentLength, int pItems) &#123;</span><br><span class=\"line\">\t   // 每接收1M数据才执行一次后面的动作</span><br><span class=\"line\">       long mBytes = pBytesRead / 1000000;</span><br><span class=\"line\">       if (megaBytes == mBytes) &#123;</span><br><span class=\"line\">           return;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       megaBytes = mBytes;</span><br><span class=\"line\">       request.getSession().setAttribute(&quot;progress&quot;, 1.0*pBytesRead/pContentLength);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"临时文件清理跟踪器\"><a href=\"#临时文件清理跟踪器\" class=\"headerlink\" title=\"临时文件清理跟踪器\"></a>临时文件清理跟踪器</h1><p>文件清理跟踪器仅适用于传统方式: 传统方式在处理文件之前将文件写入临时文件，这样的临时文件在我们上传任务完成时就成了垃圾，需要进行自动回收。Cmmons FileUpload当然也提供了这个功能，其运行原理：org.apache.commons.io.FileCleanerTracker开启一个收割线程，在DiskFileItem被垃圾回收器回收时，自动清理掉对应的临时文件。<br>要想开启文件自动清理功能，需要按照如下配置：</p>\n<ul>\n<li><p>在Servlet中我们应该在web.xml中配置一个Servlet监听器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;listener&gt;</span><br><span class=\"line\">  &lt;listener-class&gt;</span><br><span class=\"line\">    org.apache.commons.fileupload.servlet.FileCleanerCleanup</span><br><span class=\"line\">  &lt;/listener-class&gt;</span><br><span class=\"line\">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建org.apache.commons.io.FileCleaningTracker对象，设置给DiskFileItemFactory。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileCleaningTracker fileCleaningTracker = FileCleanerCleanup.getFileCleaningTracker(context);</span><br><span class=\"line\">DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class=\"line\">factory.setFileCleaningTracker(fileCleaningTracker);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后就是按照我们之前学习的步骤正常操作即可</li>\n</ul>\n<p>要想禁用临时文件自动删除功能，可将FileCleaningTracker设置为null(其实默认就为null)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factory.setFileCleaningTracker(null);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>这是一篇半翻译半笔记式的文章，如果你之前对Common FileUpload了解不多，本文可以快速了解如何使用方法，如果你有时间，推荐你看<a href=\"http://commons.apache.org/proper/commons-fileupload/using.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n</blockquote><h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>FileUpload能够以多种不同的方式使用，具体取决于应用程序的要求。在最简单的情况下，您将调用单个方法来解析servlet请求，然后处理解析出来的Item集合。此外也可以自定义FileUpload以完全控制各个Item的存储方式，比如设置缓存目录、直接将接收到的Item以流的形式写入数据库等。</p>","more":"\n\n<blockquote>\n<p>FileUpload依赖于Commons IO，因此类路径下要有Commons IO的jar包。当然采用Maven依赖的方式不用担心，maven会自动为我们下载Commons IO包</p>\n</blockquote>\n<h1 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h1><p>FileUpload依据规范<a href=\"http://www.ietf.org/rfc/rfc1867.txt\" target=\"_blank\" rel=\"noopener\">RFC1867</a>中”基于表单的HTML文件上载”对上传的文件数据进行解析，解析出来的每个项目对应一个FileItem对象。<br>每个FileItem都有许多我们可能感兴趣的属性：获取contentType，获取原本的文件名，获取文件大小，获取FiledName(如果是表单域上传)，判断是否在内存中，判断是否属于表单域等。<br>FileUpload使用<strong>FileItemFactory</strong>创建新的FileItem。该工厂可以控制每个项目的创建方式。目前提供的工厂实现可以将项目的数据存储临时存储在内存或磁盘上，具体取决于项目的大小（即数据字节，在指定的大小内时，存在内存中，超出范围，存在磁盘上）。</p>\n<h1 id=\"开始之前的判断\"><a href=\"#开始之前的判断\" class=\"headerlink\" title=\"开始之前的判断\"></a>开始之前的判断</h1><p>在处理上传项目前，最好是先解析一下当前请求是否属于文件上传请求，采用如下方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//检查我们是否有文件上传请求</span><br><span class=\"line\">boolean isMultipart = ServletFileUpload.isMultipartContent(request);</span><br></pre></td></tr></table></figure>\n\n<p>该方法的原理也很简单，就是获取request的contentType以判断是否是multipart，源码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final boolean isMultipartContent(</span><br><span class=\"line\">            HttpServletRequest request) &#123;</span><br><span class=\"line\">    if (!POST_METHOD.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return FileUploadBase.isMultipartContent(new ServletRequestContext(request));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final String MULTIPART = &quot;multipart/&quot;;</span><br><span class=\"line\">... ...</span><br><span class=\"line\">... ...</span><br><span class=\"line\">public static final boolean isMultipartContent(RequestContext ctx) &#123;</span><br><span class=\"line\">    String contentType = ctx.getContentType();</span><br><span class=\"line\">    if (contentType == null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可用的最简配置\"><a href=\"#可用的最简配置\" class=\"headerlink\" title=\"可用的最简配置\"></a>可用的最简配置</h1><p>有两种方式能够接收上传文件</p>\n<ul>\n<li>传统方式：首先创建FileItemFactory，创建ServletFileUpload时传入factory，再从upload对象获取FileItem，然后调用write(File)直接写入文件。这种方式将接收到的文件临时存储到内存或磁盘中，后续用户再进行处理，比较方便，但是占用时间和空间</li>\n<li>流方式：直接ServletFileUpload中获取FileItem，再从FileItem中获取输入流，从流中直接接收数据，没有临时缓存这一步。使用没那么方便，但是比较节省时间和空间</li>\n</ul>\n<p>如下演示两种方式</p>\n<h2 id=\"使用传统API\"><a href=\"#使用传统API\" class=\"headerlink\" title=\"使用传统API\"></a>使用传统API</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create a factory for disk-based file items</span><br><span class=\"line\">DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">// Configure a repository (to ensure a secure temp location is used)</span><br><span class=\"line\">ServletContext servletContext = this.getServletConfig().getServletContext();</span><br><span class=\"line\">File repository = (File) servletContext.getAttribute(&quot;javax.servlet.context.tempdir&quot;);</span><br><span class=\"line\">factory.setRepository(repository);</span><br><span class=\"line\"></span><br><span class=\"line\">// Create a new file upload handler</span><br><span class=\"line\">ServletFileUpload upload = new ServletFileUpload(factory);</span><br><span class=\"line\"></span><br><span class=\"line\">// Parse the request</span><br><span class=\"line\">List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class=\"line\">Iterator&lt;FileItem&gt; iter = items.iterator();</span><br><span class=\"line\">while (iter.hasNext()) &#123;</span><br><span class=\"line\">    FileItem item = iter.next();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // upload 是这里假定的上传文件的field name</span><br><span class=\"line\">    if(&quot;upload&quot;.equals(item.getFieldName))&#123;</span><br><span class=\"line\">\t    File uploadFile = new File(&quot;...&quot;);</span><br><span class=\"line\">\t    item.write(uploadFile);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FileItemFctory可以设置的内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factory.setRepository(File dir); // 设置临时文件存储位置</span><br><span class=\"line\">factory.setSizeThreshold(long bytes); // 设置请求大小阈值，当请求大于该值时，接收到的数据是缓存在磁盘中的，否则直接缓存在内存中。</span><br><span class=\"line\">factory.setFileCleaningTracker(FileCleaningTracker pTracker); // 设置临时文件清理跟踪器，后面会讲到</span><br></pre></td></tr></table></figure>\n\n<p>ServletFileUpload可以设置的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upload.setMaxSize(long bytes); //设置整个请求的最大值，大于该值时，是不允许传送的</span><br><span class=\"line\">upload.setFileMaxSize(long bytes); //设置单个文件的最大值，大于该值时，大于该值时，是不允许传送的</span><br><span class=\"line\">upload.setHeaderEncoding(String charset); // 设置读取每个FileItem的头数据的字符编码，不设置时采用request的编码，也没有时采用系统默认编码</span><br><span class=\"line\">upload.setProgressListener(ProgressListener pListener); // 设置上传进度监听器，后面会讲</span><br></pre></td></tr></table></figure>\n\n<p>FileItem能够获取的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item.getContentType(); // 获取单个Item的ContentType</span><br><span class=\"line\">item.getName(); // 获取item本来的文件名，如果不是文件则为null</span><br><span class=\"line\">item.getFieldName(); // 获取item的field名</span><br><span class=\"line\">item.getSize(); // 获取item的大小</span><br><span class=\"line\">item.get(); // 将item转换成字节数组返回</span><br><span class=\"line\">item.isInMemory(); // item目前是否存在内存中</span><br><span class=\"line\">item.isFormField(); // 是否是表单域</span><br><span class=\"line\">item.getInputStream(); // 获取输入流，用于读取item</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用流API\"><a href=\"#使用流API\" class=\"headerlink\" title=\"使用流API\"></a>使用流API</h2><p>这种方式其实说来应该是最好的选择，因为他也并不麻烦，而且节省了缓存的空间和时间，在性能上是最好的选择。只需要按照如下方式使用即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create a new file upload handler</span><br><span class=\"line\">ServletFileUpload upload = new ServletFileUpload();</span><br><span class=\"line\"></span><br><span class=\"line\">// Parse the request</span><br><span class=\"line\">FileItemIterator iter = upload.getItemIterator(request);</span><br><span class=\"line\">while (iter.hasNext()) &#123;</span><br><span class=\"line\">    FileItemStream item = iter.next();</span><br><span class=\"line\">    String fileName = item.getName();</span><br><span class=\"line\">    InputStream stream = item.getInputStream();</span><br><span class=\"line\">    FileOutputStream os = new FileOutputStream(new File(fileName));</span><br><span class=\"line\">    /*</span><br><span class=\"line\">\t *\t在这里将输入流的内容写入输出流即可</span><br><span class=\"line\">\t */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"文件上传进度监听器\"><a href=\"#文件上传进度监听器\" class=\"headerlink\" title=\"文件上传进度监听器\"></a>文件上传进度监听器</h1><p>当上传文件非常大时，进度监听器就能够排上用场了，使用方式也非常简单，创建监听器对象，设置到ServletFileUpload即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProgressListener listener = new ProgressListener() &#123;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * pBytesRead: 到目前为止总共读了多少个Byte</span><br><span class=\"line\">     * pContentLength: 整个content的长度，按Byte计算，也有可能是未知的：-1</span><br><span class=\"line\">     * pItems: 正在读取的item编号，0代表尚未开始读取，1代表第一个，以此类推</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void update(long pBytesRead, long pContentLength, int pItems) &#123;</span><br><span class=\"line\">        // 获取进度百分比，并放在session中</span><br><span class=\"line\">        request.getSession().setAttribute(&quot;progress&quot;, 1.0*pBytesRead/pContentLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">upload.setProgressListener(progressListener);</span><br></pre></td></tr></table></figure>\n\n<p>此处有一个问题：监听器会被频繁调用，当其内部实现的逻辑较为简单时，可能无伤大雅，但当逻辑较为复杂或占用资源时，监听器就可能影响到程序的性能。<br>解决方案：以某种方式减少监听器内部逻辑执行的次数，比如下面这种方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProgressListener progressListener = new ProgressListener()&#123;</span><br><span class=\"line\">   private long megaBytes = -1;</span><br><span class=\"line\">   public void update(long pBytesRead, long pContentLength, int pItems) &#123;</span><br><span class=\"line\">\t   // 每接收1M数据才执行一次后面的动作</span><br><span class=\"line\">       long mBytes = pBytesRead / 1000000;</span><br><span class=\"line\">       if (megaBytes == mBytes) &#123;</span><br><span class=\"line\">           return;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       megaBytes = mBytes;</span><br><span class=\"line\">       request.getSession().setAttribute(&quot;progress&quot;, 1.0*pBytesRead/pContentLength);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"临时文件清理跟踪器\"><a href=\"#临时文件清理跟踪器\" class=\"headerlink\" title=\"临时文件清理跟踪器\"></a>临时文件清理跟踪器</h1><p>文件清理跟踪器仅适用于传统方式: 传统方式在处理文件之前将文件写入临时文件，这样的临时文件在我们上传任务完成时就成了垃圾，需要进行自动回收。Cmmons FileUpload当然也提供了这个功能，其运行原理：org.apache.commons.io.FileCleanerTracker开启一个收割线程，在DiskFileItem被垃圾回收器回收时，自动清理掉对应的临时文件。<br>要想开启文件自动清理功能，需要按照如下配置：</p>\n<ul>\n<li><p>在Servlet中我们应该在web.xml中配置一个Servlet监听器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;listener&gt;</span><br><span class=\"line\">  &lt;listener-class&gt;</span><br><span class=\"line\">    org.apache.commons.fileupload.servlet.FileCleanerCleanup</span><br><span class=\"line\">  &lt;/listener-class&gt;</span><br><span class=\"line\">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建org.apache.commons.io.FileCleaningTracker对象，设置给DiskFileItemFactory。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileCleaningTracker fileCleaningTracker = FileCleanerCleanup.getFileCleaningTracker(context);</span><br><span class=\"line\">DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class=\"line\">factory.setFileCleaningTracker(fileCleaningTracker);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后就是按照我们之前学习的步骤正常操作即可</li>\n</ul>\n<p>要想禁用临时文件自动删除功能，可将FileCleaningTracker设置为null(其实默认就为null)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factory.setFileCleaningTracker(null);</span><br></pre></td></tr></table></figure>"},{"title":"Spring Webflow - EL表达式","date":"2018-09-08T12:00:00.000Z","_content":"\n> 1. 文章中内容并没有全部验证，仅作为参考\n> 2. 上下文一起看，才能明白其中的意思\n\n# Web Flow中EL表达式作用\nweb-flow使用EL表达式访问flow的model和调用方法。在web-flow中EL表达式主要有如下四种用途\n\n - 访问客户端(浏览器)数据，比如request的parameter\n - 访问web-flow的RequestContex，比如flowScope和currentEvent等\n - 调用Spring管理的bean的方法\n - 解析表达式(相对于普通表达式)可以解析注入子流程id，view的名称，\n##EL表达式分类\nweb-flow中EL表达式按照按使用形式分为两类\n\n - 标准表达式\n不需要加#{}，直接按照一般程序一样写就行了，如果硬要加#{}，则会报错\n\n```\n// 调用searchCriteria对象的nextPage()方法\n// searchCriteria对象可以是Spring中的一个bean，也可以是flow上下文中的一个变量\n<evaluate expression=\"searchCriteria.nextPage()\" />\n```\n\n - 模板表达式\n需要加#{}，这种表达式允许将常量和表达式写在一起，如下这种，最后的view名称是拼出来的\n\n```\n<view-state id=\"error\" view=\"error-#{externalContext.locale}.xhtml\" />\n```\n# Web Flow支持的EL表达式\nWeb Flow支持spring EL表达式，Unified表达式，以及OGNL表达式\n\n - Spring EL\n从web-flow 2.1开始就使用了Spring EL表达式，该表达式在Spring的全系列产品中都可以使用。使用它只需要在类路径下包含一个单独的jar包`org.springframework.expression`。 并且如果以前使用的EL表达式或者ognl的表达式，还需要将他们的包去除。\n - Unified EL\n在we-flow 2.0时期默认使用的是统一EL表达式，`org.jboss.el`提供，该包还需要j2ee提供的`el-api`(一般的容器都会自动提供)。虽然目前版本的Spring EL表达式是默认和推荐使用的，但也可以手动更换为Unified EL表达式。只需加上如下配置即可\n\n```\n// 该配置方法在前面讲配置时给过示例\n<webflow:flow-builder-services expression-parser=\"expressionParser\"/>\n<bean id=\"expressionParser\" class=\"org.springframework.webflow.expression.el.WebFlowELExpressionParser\">\n\t<constructor-arg>\n\t\t  <bean class=\"org.jboss.el.ExpressionFactoryImpl\" />\n\t</constructor-arg>\n</bean>\n```\n\n - OGNL\n2.4及以后的版本中，已经非常不推荐使用OGNL表达式了。那还是在web-flow 1.0时代标配的是OGNL表达式，如果硬要使用OGNL表达式，还是可以配置，方法请参考[教程](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-ognl)\n##EL表达式迁移(Unified EL -> Spring EL)\n从Unified EL表达式和OGNL表达式迁移到Spring EL表达式需要注意以下几点\n\n - EL表达式的符号从${ }变化成了#{ }\n - 针对current Event的比较由`#{currentEvent == 'submit'}` 要换成 `#{currentEvent.id == 'submit'}`\n - 直接解析属性如`#{currentUser.name}` 可能造成空指针异常，以前的检查方式是：`#{currentUser != null ? currentUser.name : null}` ， 目前更好的方式：`#{currentUser?.name}`\n\n更加详细的EL相关内容，看[这里](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html#expressions-language-ref)\n# 一些内建的Spring EL变量\n\n内建代表系统自动创建并管理，用户可以直接通过EL表达式访问\n## 重要原则\n\n只有当分配一个新的变量时才会用到默认存在的作用域变量(flowScope, viewScope, requestScope, etc), 后面使用时就不需要指定作用域变量了。\n\n```\n<!-- 声明modelMap变量，必须显式指定作用域 -->\n<evaluate expression=\"flowController.performSearch(searchForm)\" result=\"flashScope.modelMap\"/>\n... ...\n<!-- 使用modelMap变量不用指定作用域 -->\n<evaluate expression=\"flowController.performResult(modelMap)\"/>\n```\n## 作用域\n前面在讲变量时已经讲过作用域(看[这里](https://blog.csdn.net/zou8944/article/details/82502430))，这里提一下，不要忘了。\n\n## 内建变量穷举\n\n - requestParameters\n获取客户端的请求参数\n - currentEvent\n可以获取当前的Event对象\n - currentUser\n获取当前被授权的用户，即Principal对象\n - messageContext\n可以访问当前的上下文，包括错误和成功的信息，详见MessageContext的javaDoc\n - resourceBundle\n访问资源文件\n - flowRequestContext\n访问当前flow的RequestContext对象 ，它是当前flow的请求信息对象，详见RequestContext的javaDoc\n - flowExecutionContext\n访问FlowExecutionContext对象，存储了当前flow的状态\n - flowExecutionUrl\n访问当前view的相对路径，可以在view-state中指定的jsp中进行使用\n - externalContext\n可以获取客户端的环境信息，包括sessino属性，详见ExternalContext JavaDoc\n##Spring EL查找变量的逻辑\n当使用flow中声明的变量时，并不需要指定作用域，web flow会自动从各作用域，按照如下顺序进行查找，如果找不到，则报`EvaluationException`异常\n\n```\nrequestScope -> flashScope -> viewScope -> flowScope -> conversationScope\n```","source":"_posts/Spring Webflow - EL表达式.md","raw":"---\ntitle: Spring Webflow - EL表达式\ndate: 2018-09-08 20:00:00\ntags: \n    - Spring\n    - Webflow\ncategories: \n    - Spring Webflow\n---\n\n> 1. 文章中内容并没有全部验证，仅作为参考\n> 2. 上下文一起看，才能明白其中的意思\n\n# Web Flow中EL表达式作用\nweb-flow使用EL表达式访问flow的model和调用方法。在web-flow中EL表达式主要有如下四种用途\n\n - 访问客户端(浏览器)数据，比如request的parameter\n - 访问web-flow的RequestContex，比如flowScope和currentEvent等\n - 调用Spring管理的bean的方法\n - 解析表达式(相对于普通表达式)可以解析注入子流程id，view的名称，\n##EL表达式分类\nweb-flow中EL表达式按照按使用形式分为两类\n\n - 标准表达式\n不需要加#{}，直接按照一般程序一样写就行了，如果硬要加#{}，则会报错\n\n```\n// 调用searchCriteria对象的nextPage()方法\n// searchCriteria对象可以是Spring中的一个bean，也可以是flow上下文中的一个变量\n<evaluate expression=\"searchCriteria.nextPage()\" />\n```\n\n - 模板表达式\n需要加#{}，这种表达式允许将常量和表达式写在一起，如下这种，最后的view名称是拼出来的\n\n```\n<view-state id=\"error\" view=\"error-#{externalContext.locale}.xhtml\" />\n```\n# Web Flow支持的EL表达式\nWeb Flow支持spring EL表达式，Unified表达式，以及OGNL表达式\n\n - Spring EL\n从web-flow 2.1开始就使用了Spring EL表达式，该表达式在Spring的全系列产品中都可以使用。使用它只需要在类路径下包含一个单独的jar包`org.springframework.expression`。 并且如果以前使用的EL表达式或者ognl的表达式，还需要将他们的包去除。\n - Unified EL\n在we-flow 2.0时期默认使用的是统一EL表达式，`org.jboss.el`提供，该包还需要j2ee提供的`el-api`(一般的容器都会自动提供)。虽然目前版本的Spring EL表达式是默认和推荐使用的，但也可以手动更换为Unified EL表达式。只需加上如下配置即可\n\n```\n// 该配置方法在前面讲配置时给过示例\n<webflow:flow-builder-services expression-parser=\"expressionParser\"/>\n<bean id=\"expressionParser\" class=\"org.springframework.webflow.expression.el.WebFlowELExpressionParser\">\n\t<constructor-arg>\n\t\t  <bean class=\"org.jboss.el.ExpressionFactoryImpl\" />\n\t</constructor-arg>\n</bean>\n```\n\n - OGNL\n2.4及以后的版本中，已经非常不推荐使用OGNL表达式了。那还是在web-flow 1.0时代标配的是OGNL表达式，如果硬要使用OGNL表达式，还是可以配置，方法请参考[教程](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-ognl)\n##EL表达式迁移(Unified EL -> Spring EL)\n从Unified EL表达式和OGNL表达式迁移到Spring EL表达式需要注意以下几点\n\n - EL表达式的符号从${ }变化成了#{ }\n - 针对current Event的比较由`#{currentEvent == 'submit'}` 要换成 `#{currentEvent.id == 'submit'}`\n - 直接解析属性如`#{currentUser.name}` 可能造成空指针异常，以前的检查方式是：`#{currentUser != null ? currentUser.name : null}` ， 目前更好的方式：`#{currentUser?.name}`\n\n更加详细的EL相关内容，看[这里](http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html#expressions-language-ref)\n# 一些内建的Spring EL变量\n\n内建代表系统自动创建并管理，用户可以直接通过EL表达式访问\n## 重要原则\n\n只有当分配一个新的变量时才会用到默认存在的作用域变量(flowScope, viewScope, requestScope, etc), 后面使用时就不需要指定作用域变量了。\n\n```\n<!-- 声明modelMap变量，必须显式指定作用域 -->\n<evaluate expression=\"flowController.performSearch(searchForm)\" result=\"flashScope.modelMap\"/>\n... ...\n<!-- 使用modelMap变量不用指定作用域 -->\n<evaluate expression=\"flowController.performResult(modelMap)\"/>\n```\n## 作用域\n前面在讲变量时已经讲过作用域(看[这里](https://blog.csdn.net/zou8944/article/details/82502430))，这里提一下，不要忘了。\n\n## 内建变量穷举\n\n - requestParameters\n获取客户端的请求参数\n - currentEvent\n可以获取当前的Event对象\n - currentUser\n获取当前被授权的用户，即Principal对象\n - messageContext\n可以访问当前的上下文，包括错误和成功的信息，详见MessageContext的javaDoc\n - resourceBundle\n访问资源文件\n - flowRequestContext\n访问当前flow的RequestContext对象 ，它是当前flow的请求信息对象，详见RequestContext的javaDoc\n - flowExecutionContext\n访问FlowExecutionContext对象，存储了当前flow的状态\n - flowExecutionUrl\n访问当前view的相对路径，可以在view-state中指定的jsp中进行使用\n - externalContext\n可以获取客户端的环境信息，包括sessino属性，详见ExternalContext JavaDoc\n##Spring EL查找变量的逻辑\n当使用flow中声明的变量时，并不需要指定作用域，web flow会自动从各作用域，按照如下顺序进行查找，如果找不到，则报`EvaluationException`异常\n\n```\nrequestScope -> flashScope -> viewScope -> flowScope -> conversationScope\n```","slug":"Spring Webflow - EL表达式","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo90000200bnlyk0h98n","content":"<blockquote>\n<ol>\n<li>文章中内容并没有全部验证，仅作为参考</li>\n<li>上下文一起看，才能明白其中的意思</li>\n</ol>\n</blockquote><h1 id=\"Web-Flow中EL表达式作用\"><a href=\"#Web-Flow中EL表达式作用\" class=\"headerlink\" title=\"Web Flow中EL表达式作用\"></a>Web Flow中EL表达式作用</h1><p>web-flow使用EL表达式访问flow的model和调用方法。在web-flow中EL表达式主要有如下四种用途</p><ul>\n<li><p>访问客户端(浏览器)数据，比如request的parameter</p>\n</li>\n<li><p>访问web-flow的RequestContex，比如flowScope和currentEvent等</p>\n</li>\n<li><p>调用Spring管理的bean的方法</p>\n</li>\n<li><p>解析表达式(相对于普通表达式)可以解析注入子流程id，view的名称，<br>##EL表达式分类<br>web-flow中EL表达式按照按使用形式分为两类</p>\n</li>\n<li><p>标准表达式<br>不需要加#{}，直接按照一般程序一样写就行了，如果硬要加#{}，则会报错</p>\n</li>\n</ul><a id=\"more\"></a>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 调用searchCriteria对象的nextPage()方法</span><br><span class=\"line\">// searchCriteria对象可以是Spring中的一个bean，也可以是flow上下文中的一个变量</span><br><span class=\"line\">&lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>模板表达式<br>需要加#{}，这种表达式允许将常量和表达式写在一起，如下这种，最后的view名称是拼出来的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;error&quot; view=&quot;error-#&#123;externalContext.locale&#125;.xhtml&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Web-Flow支持的EL表达式\"><a href=\"#Web-Flow支持的EL表达式\" class=\"headerlink\" title=\"Web Flow支持的EL表达式\"></a>Web Flow支持的EL表达式</h1><p>Web Flow支持spring EL表达式，Unified表达式，以及OGNL表达式</p>\n<ul>\n<li>Spring EL<br>从web-flow 2.1开始就使用了Spring EL表达式，该表达式在Spring的全系列产品中都可以使用。使用它只需要在类路径下包含一个单独的jar包<code>org.springframework.expression</code>。 并且如果以前使用的EL表达式或者ognl的表达式，还需要将他们的包去除。</li>\n<li>Unified EL<br>在we-flow 2.0时期默认使用的是统一EL表达式，<code>org.jboss.el</code>提供，该包还需要j2ee提供的<code>el-api</code>(一般的容器都会自动提供)。虽然目前版本的Spring EL表达式是默认和推荐使用的，但也可以手动更换为Unified EL表达式。只需加上如下配置即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 该配置方法在前面讲配置时给过示例</span><br><span class=\"line\">&lt;webflow:flow-builder-services expression-parser=&quot;expressionParser&quot;/&gt;</span><br><span class=\"line\">&lt;bean id=&quot;expressionParser&quot; class=&quot;org.springframework.webflow.expression.el.WebFlowELExpressionParser&quot;&gt;</span><br><span class=\"line\">\t&lt;constructor-arg&gt;</span><br><span class=\"line\">\t\t  &lt;bean class=&quot;org.jboss.el.ExpressionFactoryImpl&quot; /&gt;</span><br><span class=\"line\">\t&lt;/constructor-arg&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>OGNL<br>2.4及以后的版本中，已经非常不推荐使用OGNL表达式了。那还是在web-flow 1.0时代标配的是OGNL表达式，如果硬要使用OGNL表达式，还是可以配置，方法请参考<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-ognl\" target=\"_blank\" rel=\"noopener\">教程</a><br>##EL表达式迁移(Unified EL -&gt; Spring EL)<br>从Unified EL表达式和OGNL表达式迁移到Spring EL表达式需要注意以下几点</p>\n</li>\n<li><p>EL表达式的符号从${ }变化成了#{ }</p>\n</li>\n<li><p>针对current Event的比较由<code>#{currentEvent == &#39;submit&#39;}</code> 要换成 <code>#{currentEvent.id == &#39;submit&#39;}</code></p>\n</li>\n<li><p>直接解析属性如<code>#{currentUser.name}</code> 可能造成空指针异常，以前的检查方式是：<code>#{currentUser != null ? currentUser.name : null}</code> ， 目前更好的方式：<code>#{currentUser?.name}</code></p>\n</li>\n</ul>\n<p>更加详细的EL相关内容，看<a href=\"http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html#expressions-language-ref\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h1 id=\"一些内建的Spring-EL变量\"><a href=\"#一些内建的Spring-EL变量\" class=\"headerlink\" title=\"一些内建的Spring EL变量\"></a>一些内建的Spring EL变量</h1><p>内建代表系统自动创建并管理，用户可以直接通过EL表达式访问</p>\n<h2 id=\"重要原则\"><a href=\"#重要原则\" class=\"headerlink\" title=\"重要原则\"></a>重要原则</h2><p>只有当分配一个新的变量时才会用到默认存在的作用域变量(flowScope, viewScope, requestScope, etc), 后面使用时就不需要指定作用域变量了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 声明modelMap变量，必须显式指定作用域 --&gt;</span><br><span class=\"line\">&lt;evaluate expression=&quot;flowController.performSearch(searchForm)&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class=\"line\">... ...</span><br><span class=\"line\">&lt;!-- 使用modelMap变量不用指定作用域 --&gt;</span><br><span class=\"line\">&lt;evaluate expression=&quot;flowController.performResult(modelMap)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>前面在讲变量时已经讲过作用域(看<a href=\"https://blog.csdn.net/zou8944/article/details/82502430\" target=\"_blank\" rel=\"noopener\">这里</a>)，这里提一下，不要忘了。</p>\n<h2 id=\"内建变量穷举\"><a href=\"#内建变量穷举\" class=\"headerlink\" title=\"内建变量穷举\"></a>内建变量穷举</h2><ul>\n<li>requestParameters<br>获取客户端的请求参数</li>\n<li>currentEvent<br>可以获取当前的Event对象</li>\n<li>currentUser<br>获取当前被授权的用户，即Principal对象</li>\n<li>messageContext<br>可以访问当前的上下文，包括错误和成功的信息，详见MessageContext的javaDoc</li>\n<li>resourceBundle<br>访问资源文件</li>\n<li>flowRequestContext<br>访问当前flow的RequestContext对象 ，它是当前flow的请求信息对象，详见RequestContext的javaDoc</li>\n<li>flowExecutionContext<br>访问FlowExecutionContext对象，存储了当前flow的状态</li>\n<li>flowExecutionUrl<br>访问当前view的相对路径，可以在view-state中指定的jsp中进行使用</li>\n<li>externalContext<br>可以获取客户端的环境信息，包括sessino属性，详见ExternalContext JavaDoc<br>##Spring EL查找变量的逻辑<br>当使用flow中声明的变量时，并不需要指定作用域，web flow会自动从各作用域，按照如下顺序进行查找，如果找不到，则报<code>EvaluationException</code>异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requestScope -&gt; flashScope -&gt; viewScope -&gt; flowScope -&gt; conversationScope</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<ol>\n<li>文章中内容并没有全部验证，仅作为参考</li>\n<li>上下文一起看，才能明白其中的意思</li>\n</ol>\n</blockquote><h1 id=\"Web-Flow中EL表达式作用\"><a href=\"#Web-Flow中EL表达式作用\" class=\"headerlink\" title=\"Web Flow中EL表达式作用\"></a>Web Flow中EL表达式作用</h1><p>web-flow使用EL表达式访问flow的model和调用方法。在web-flow中EL表达式主要有如下四种用途</p><ul>\n<li><p>访问客户端(浏览器)数据，比如request的parameter</p>\n</li>\n<li><p>访问web-flow的RequestContex，比如flowScope和currentEvent等</p>\n</li>\n<li><p>调用Spring管理的bean的方法</p>\n</li>\n<li><p>解析表达式(相对于普通表达式)可以解析注入子流程id，view的名称，<br>##EL表达式分类<br>web-flow中EL表达式按照按使用形式分为两类</p>\n</li>\n<li><p>标准表达式<br>不需要加#{}，直接按照一般程序一样写就行了，如果硬要加#{}，则会报错</p>\n</li>\n</ul>","more":"\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 调用searchCriteria对象的nextPage()方法</span><br><span class=\"line\">// searchCriteria对象可以是Spring中的一个bean，也可以是flow上下文中的一个变量</span><br><span class=\"line\">&lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>模板表达式<br>需要加#{}，这种表达式允许将常量和表达式写在一起，如下这种，最后的view名称是拼出来的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;error&quot; view=&quot;error-#&#123;externalContext.locale&#125;.xhtml&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Web-Flow支持的EL表达式\"><a href=\"#Web-Flow支持的EL表达式\" class=\"headerlink\" title=\"Web Flow支持的EL表达式\"></a>Web Flow支持的EL表达式</h1><p>Web Flow支持spring EL表达式，Unified表达式，以及OGNL表达式</p>\n<ul>\n<li>Spring EL<br>从web-flow 2.1开始就使用了Spring EL表达式，该表达式在Spring的全系列产品中都可以使用。使用它只需要在类路径下包含一个单独的jar包<code>org.springframework.expression</code>。 并且如果以前使用的EL表达式或者ognl的表达式，还需要将他们的包去除。</li>\n<li>Unified EL<br>在we-flow 2.0时期默认使用的是统一EL表达式，<code>org.jboss.el</code>提供，该包还需要j2ee提供的<code>el-api</code>(一般的容器都会自动提供)。虽然目前版本的Spring EL表达式是默认和推荐使用的，但也可以手动更换为Unified EL表达式。只需加上如下配置即可</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 该配置方法在前面讲配置时给过示例</span><br><span class=\"line\">&lt;webflow:flow-builder-services expression-parser=&quot;expressionParser&quot;/&gt;</span><br><span class=\"line\">&lt;bean id=&quot;expressionParser&quot; class=&quot;org.springframework.webflow.expression.el.WebFlowELExpressionParser&quot;&gt;</span><br><span class=\"line\">\t&lt;constructor-arg&gt;</span><br><span class=\"line\">\t\t  &lt;bean class=&quot;org.jboss.el.ExpressionFactoryImpl&quot; /&gt;</span><br><span class=\"line\">\t&lt;/constructor-arg&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>OGNL<br>2.4及以后的版本中，已经非常不推荐使用OGNL表达式了。那还是在web-flow 1.0时代标配的是OGNL表达式，如果硬要使用OGNL表达式，还是可以配置，方法请参考<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-ognl\" target=\"_blank\" rel=\"noopener\">教程</a><br>##EL表达式迁移(Unified EL -&gt; Spring EL)<br>从Unified EL表达式和OGNL表达式迁移到Spring EL表达式需要注意以下几点</p>\n</li>\n<li><p>EL表达式的符号从${ }变化成了#{ }</p>\n</li>\n<li><p>针对current Event的比较由<code>#{currentEvent == &#39;submit&#39;}</code> 要换成 <code>#{currentEvent.id == &#39;submit&#39;}</code></p>\n</li>\n<li><p>直接解析属性如<code>#{currentUser.name}</code> 可能造成空指针异常，以前的检查方式是：<code>#{currentUser != null ? currentUser.name : null}</code> ， 目前更好的方式：<code>#{currentUser?.name}</code></p>\n</li>\n</ul>\n<p>更加详细的EL相关内容，看<a href=\"http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html#expressions-language-ref\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h1 id=\"一些内建的Spring-EL变量\"><a href=\"#一些内建的Spring-EL变量\" class=\"headerlink\" title=\"一些内建的Spring EL变量\"></a>一些内建的Spring EL变量</h1><p>内建代表系统自动创建并管理，用户可以直接通过EL表达式访问</p>\n<h2 id=\"重要原则\"><a href=\"#重要原则\" class=\"headerlink\" title=\"重要原则\"></a>重要原则</h2><p>只有当分配一个新的变量时才会用到默认存在的作用域变量(flowScope, viewScope, requestScope, etc), 后面使用时就不需要指定作用域变量了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 声明modelMap变量，必须显式指定作用域 --&gt;</span><br><span class=\"line\">&lt;evaluate expression=&quot;flowController.performSearch(searchForm)&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class=\"line\">... ...</span><br><span class=\"line\">&lt;!-- 使用modelMap变量不用指定作用域 --&gt;</span><br><span class=\"line\">&lt;evaluate expression=&quot;flowController.performResult(modelMap)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>前面在讲变量时已经讲过作用域(看<a href=\"https://blog.csdn.net/zou8944/article/details/82502430\" target=\"_blank\" rel=\"noopener\">这里</a>)，这里提一下，不要忘了。</p>\n<h2 id=\"内建变量穷举\"><a href=\"#内建变量穷举\" class=\"headerlink\" title=\"内建变量穷举\"></a>内建变量穷举</h2><ul>\n<li>requestParameters<br>获取客户端的请求参数</li>\n<li>currentEvent<br>可以获取当前的Event对象</li>\n<li>currentUser<br>获取当前被授权的用户，即Principal对象</li>\n<li>messageContext<br>可以访问当前的上下文，包括错误和成功的信息，详见MessageContext的javaDoc</li>\n<li>resourceBundle<br>访问资源文件</li>\n<li>flowRequestContext<br>访问当前flow的RequestContext对象 ，它是当前flow的请求信息对象，详见RequestContext的javaDoc</li>\n<li>flowExecutionContext<br>访问FlowExecutionContext对象，存储了当前flow的状态</li>\n<li>flowExecutionUrl<br>访问当前view的相对路径，可以在view-state中指定的jsp中进行使用</li>\n<li>externalContext<br>可以获取客户端的环境信息，包括sessino属性，详见ExternalContext JavaDoc<br>##Spring EL查找变量的逻辑<br>当使用flow中声明的变量时，并不需要指定作用域，web flow会自动从各作用域，按照如下顺序进行查找，如果找不到，则报<code>EvaluationException</code>异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requestScope -&gt; flashScope -&gt; viewScope -&gt; flowScope -&gt; conversationScope</span><br></pre></td></tr></table></figure>"},{"title":"Git基础知识","date":"2018-02-15T14:31:33.000Z","_content":"## GIT简介\n1. 版本控制系统：即记录同一个文档在不同人和不同时间修改的各版本的系统，对于恢复文档、差异对比、协同工作有非常大的帮助。\n2. GIT是由linux创始人linus花费两周时间写成的，用于托管linux系统。目前已经有众多开源项目，如jQuery、PHP、Ruby等。\n<!-- more -->\n3. 集中式版本控制系统：以CVS、SVN为代表，版本库是集中存放在中央服务器的，在使用时候要先从服务器中取得最新版本，本地操作完成后还要上传给服务器，非常不方便，而且不安全。\n4. 分布式版本控制系统：以GIT为代表，没有集中式的中央服务器，每个人的电脑上都是一个完整的版本库，在工作完成之后只需要和其他同事交换修改的部分即可。具体工作方式还要实际体会。\n分布式在本地维护一个完整的库，因此不需要联网也可以工作，等有网络时再把本地库推送到远程库即可。\n\n## 基础知识\n1. 所有的版本控制系统只能跟踪文本文件的改动，如txt文件、网页、程序代码等，并且可以明确告诉你在什么地方改了什么。而图片、视频等二进制文件则没有办法跟踪其变化，只能告知文件的大小改变情况，但是不知道具体改了什么。而微软的word就是二进制格式，因此不能详细跟踪。\n基于以上原因，使用GIT时，就要以纯文本方式编写文件。\n2. 为了长久性和通用性考虑，编写文本时一定要通通使用UTF-8编码。\n3. 老司机寄语：千万不要用windows自带的记事本编辑任何文本文件。\n原因：记事本团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf字符，对程序的编译之类的会造成错误。推荐使用Ntepad++\n4. Git的版本会退速度很快，因为其内部有个指向当前版本的指针HEAD，回退或前进时只是改变了HEAD指向的位置。\n5. 工作区和暂存区\n工作区：就是电脑上能够看到的目录（working directory）\n版本库：工作区内有一个隐藏目录 .git，这是Gti的版本库\n暂存区：Git的版本库中存了很多东西，最重要的就是成为stage（或者叫index）的缓存区。还有自动创建的第一个分支master，以及指向master的一个指针HEAD，如下图所示：\n\n    ![工作区、缓存区、版本库的关系](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTU0OTA5ODgy?x-oss-process=image/format,png)\n\n    执行git add时，就是把文件修改添加到了缓存区；\n\n    执行git commit时，就是把缓存区的所有内容提交到当前分支。\n\n6. git每次提交的是修改，不是整个文件，因此执行“第一次修改 -> git add -> 第二次修改 -> git add -> git commit”这样的操作后，第二次修改是不会被提交的，因为第二次修改没有添加到暂存区。\n7. 在创建远程仓库之前，由于git和github之间是通过SSH加密传输的，因此要先创建SSH Key\n<font color=#0000ff><i>ssh-keygen -t rsa -C \"youremail@example.com\"</i></font>\n创建之后在用户主目录下面会生成两个文件：id_rsa、id_rsa.pub，其中id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以告诉任何人。\n为什么要SSH Key?\n因为github需要识别你推送的文件确实是你推送的，而不是别人冒充的，因此需要身份验证。也可任意添加多个Key，每个Key对应不同的电脑，添加之后你可以使用不同的电脑推送文件。\n本地生成SSH Key后，需要在github的个人账户中添加该公钥，这样才能正常使用。\n8. 添加远程库时，在创建一个repository后github会提示进行本地库的添加，按照提示来就好。\n9. 本地库在推送或从远程库提取东西时，支持两种协议：https和ssh，相比而言，ssh的速度更快。\n10. **分支的概念**\n分支就是科幻电影中的平行宇宙，当你在学习Git时，另一个你在另一个平行宇宙学习SVN，正常时两个宇宙互不干扰，但在某一个时间点，两个宇宙合并了，你就及学会了Git，又会了SVN。\n实际用途：开发新功能，需要两周，第一周写了50%，如果立刻提交，会导致代码库不完整，致使别人不能干活，如果等写完了再一起上传，又存在丢失每天进度的风险。有了分支后，可以创建一个专属于你的分支，别人看不到，你在自己的分支上工作，等工作完成后，再把你自己的分支一次性合并到原来的分支上。\ngit中维护方式：默认创建一个master分支，master分支指向提交，HEAD指向当前分支，默认是master，每次提交，master就向前移一步，随着不断提交，master分支的线越来越长。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNTA3OTcx?x-oss-process=image/format,png)\n    当创建新的分支时，Git新建一个指针dev，指向master相同指向的提交，再把HEAD指向dev，就表示当前分支在dev上。之后对工作区的修改和提交就是针对dev分支了，重新提交一次后，dev指针往前移动一步，而master指针不变。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjExNzA5?x-oss-process=image/format,png)\n    此时要把dev合并到master上，最简单的方法就是将master指向dev的当前提交，完成合并。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjUzMjM2?x-oss-process=image/format,png)\n    由于git的分支管理使用的是指针的方式，因此切换和合并起来操作非常快捷。同时<font color=red>鼓励使用分支进行工作</font>，工作完成后再合并到master上，这样有助于提升master的安全性。\n11. **分支冲突**\n当创建一个分支dev，并且提交了一个修改，同时切换到master上对同一文件进行了修改并提交，在合并分支时很可能会发生冲突，无法完成自动合并，此时只有手动解决冲突再提交才能继续合并。合并后时间线就变成如下。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwODM4ODg1?x-oss-process=image/format,png)\n12. **分支的非快速合并方式**\n分支合并时，会默认使用ff(fast forward)模式进行合并，但这样带来的坏处是会丢掉分支信息。此时可以禁用ff模式，在merge时生成新的提交。\n如下是ff模式\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMDAwMzg1?x-oss-process=image/format,png)\n    如下是非ff模式\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTM0Mzg5?x-oss-process=image/format,png)\n13. **分支策略**\n实际开发中管理分支的几个基本原则（还是要开发中实际应用才会有体会，现在体会不深）\n（1）master分支应该是稳定的，仅用来发布新版本，平时不能在上面干活\n（2）干活都在新建的dev分支上，dev是不稳定的，到版本发布时再将dev分支合并到master上\n（3）每个工作人员建立一个自己的分支，时不时在dev上进行合并就可以了。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTA5MjMw?x-oss-process=image/format,png)\n14. **BUG分支和feature分支**\n当我们临时解决一个BUG，或者增加一个新功能时，最好新建一个分支，待完成工作后再将该分支合并到工作分支中。\n15. 当你从远程仓库克隆时，Git自动把本地master分支和远程的master分支对应起来，并且远程仓库的默认名称是origin。可以把本地的分支往远程推送，推送完成后远程库的分支结构就基本和本地一样了，但是也可以不必把所有的分支推送，这个要看实际需求。\n16. **多人协作的情况（需要实际体会）**\n（1）首先，可以试图用<font color=green><i>git push origin branch-name</i></font>推送自己的修改；\n（2）如果推送失败，则因为远程分支比你的本地更新，需要先用<font color=green><i>git pull</i></font>抓取到本地试图合并；\n（3）如果合并有冲突，则解决冲突，并在本地提交；\n（4）没有冲突或者解决掉冲突后，再用<font color=green><i>git push origin branch-name</i></font>推送就能成功！\n注意：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<font color=green><i>git branch --set-upstream branch-name origin/branch-name。</i></font>\n17. 标签\n通常在版本库中打一个标签（tag），将来任何时候都可以按照标签名称来取某个时刻的历史版本。tag实际上是指向某个commit的指针，与分支不同的是，标签不能移动。可以理解为标签是固定在某一时刻的commit的指针。目的是能够很快地找到某一时刻的commit，而不用记复杂的commit id\n18. 在github上参与别人的开源项目\n    - 访问项目主页，点击fork，在自己的账号下克隆一个相同的仓库。\n    - 按照正常克隆的方式从自己的账号下克隆到本地，此时开源项目、你的远程库和本地库关系如下。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxODA4NDk0?x-oss-process=image/format,png)\n\n    - 本地修改后推送到自己账号的远程库\n    - 要想把自己修改的点推送给开源项目，可以在自己账号发起pull request。\n19. 忽略特殊文件\n有不想提交的文件时候，可以编写.gitignore文件，将不想提交的文件写到.gitignore文件中，这样在提交时候就会忽略该文件。注意文件名就是“.gitignore”，前面没有东西的。\n20. 添加.gitignore文件后没有效果解决办法\n原因：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决的办法就是先把本地缓存删除，改成未track状态，然后提交。\n（1）先将所有文件提交到Git\n（2）在Git根目录执行以下命令\n<font color=green><i>git rm -r --cached .</i></font>\n<font color=green><i>git add .</i></font>\n<font color=green><i>git commit -m \"fixed untracked files\".</i></font>\n1. 配置\n配置git时，加上--global是针对当前用户起作用的，如果不加就只对当前仓库起作用。\n每个仓库的配置文件都放在.git/config中，对整个仓库起作用。\n用户的配置恩见放在用户主目录下的一个隐藏文件/gitconfig中，对用户的所有仓库起作用\n可以直接修改配置文件，如果改错了可以删掉文件重新通过命令进行配置。\n<font color=red>鼓励进行别名的配置。</font>\n2. 自己搭建Git服务器\nGit功能强大，但是github并不是必须的，他只是作为一个一直开着的服务器而已，且兼有社区的作用。如果想要自己的代码不开源，又要用Git，那么可以自己搭建一个Git服务器。搭建方式[看这里](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000)\n3. 其它\n[Git官方网站](http://git-scm.com)\n[Git cheat sheet](https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit)","source":"_posts/Git基础知识.md","raw":"---\ntitle: Git基础知识\ndate: 2018-02-15 22:31:33\ntags: \n    - git\ncategories: \n    - Git\n---\n## GIT简介\n1. 版本控制系统：即记录同一个文档在不同人和不同时间修改的各版本的系统，对于恢复文档、差异对比、协同工作有非常大的帮助。\n2. GIT是由linux创始人linus花费两周时间写成的，用于托管linux系统。目前已经有众多开源项目，如jQuery、PHP、Ruby等。\n<!-- more -->\n3. 集中式版本控制系统：以CVS、SVN为代表，版本库是集中存放在中央服务器的，在使用时候要先从服务器中取得最新版本，本地操作完成后还要上传给服务器，非常不方便，而且不安全。\n4. 分布式版本控制系统：以GIT为代表，没有集中式的中央服务器，每个人的电脑上都是一个完整的版本库，在工作完成之后只需要和其他同事交换修改的部分即可。具体工作方式还要实际体会。\n分布式在本地维护一个完整的库，因此不需要联网也可以工作，等有网络时再把本地库推送到远程库即可。\n\n## 基础知识\n1. 所有的版本控制系统只能跟踪文本文件的改动，如txt文件、网页、程序代码等，并且可以明确告诉你在什么地方改了什么。而图片、视频等二进制文件则没有办法跟踪其变化，只能告知文件的大小改变情况，但是不知道具体改了什么。而微软的word就是二进制格式，因此不能详细跟踪。\n基于以上原因，使用GIT时，就要以纯文本方式编写文件。\n2. 为了长久性和通用性考虑，编写文本时一定要通通使用UTF-8编码。\n3. 老司机寄语：千万不要用windows自带的记事本编辑任何文本文件。\n原因：记事本团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf字符，对程序的编译之类的会造成错误。推荐使用Ntepad++\n4. Git的版本会退速度很快，因为其内部有个指向当前版本的指针HEAD，回退或前进时只是改变了HEAD指向的位置。\n5. 工作区和暂存区\n工作区：就是电脑上能够看到的目录（working directory）\n版本库：工作区内有一个隐藏目录 .git，这是Gti的版本库\n暂存区：Git的版本库中存了很多东西，最重要的就是成为stage（或者叫index）的缓存区。还有自动创建的第一个分支master，以及指向master的一个指针HEAD，如下图所示：\n\n    ![工作区、缓存区、版本库的关系](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTU0OTA5ODgy?x-oss-process=image/format,png)\n\n    执行git add时，就是把文件修改添加到了缓存区；\n\n    执行git commit时，就是把缓存区的所有内容提交到当前分支。\n\n6. git每次提交的是修改，不是整个文件，因此执行“第一次修改 -> git add -> 第二次修改 -> git add -> git commit”这样的操作后，第二次修改是不会被提交的，因为第二次修改没有添加到暂存区。\n7. 在创建远程仓库之前，由于git和github之间是通过SSH加密传输的，因此要先创建SSH Key\n<font color=#0000ff><i>ssh-keygen -t rsa -C \"youremail@example.com\"</i></font>\n创建之后在用户主目录下面会生成两个文件：id_rsa、id_rsa.pub，其中id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以告诉任何人。\n为什么要SSH Key?\n因为github需要识别你推送的文件确实是你推送的，而不是别人冒充的，因此需要身份验证。也可任意添加多个Key，每个Key对应不同的电脑，添加之后你可以使用不同的电脑推送文件。\n本地生成SSH Key后，需要在github的个人账户中添加该公钥，这样才能正常使用。\n8. 添加远程库时，在创建一个repository后github会提示进行本地库的添加，按照提示来就好。\n9. 本地库在推送或从远程库提取东西时，支持两种协议：https和ssh，相比而言，ssh的速度更快。\n10. **分支的概念**\n分支就是科幻电影中的平行宇宙，当你在学习Git时，另一个你在另一个平行宇宙学习SVN，正常时两个宇宙互不干扰，但在某一个时间点，两个宇宙合并了，你就及学会了Git，又会了SVN。\n实际用途：开发新功能，需要两周，第一周写了50%，如果立刻提交，会导致代码库不完整，致使别人不能干活，如果等写完了再一起上传，又存在丢失每天进度的风险。有了分支后，可以创建一个专属于你的分支，别人看不到，你在自己的分支上工作，等工作完成后，再把你自己的分支一次性合并到原来的分支上。\ngit中维护方式：默认创建一个master分支，master分支指向提交，HEAD指向当前分支，默认是master，每次提交，master就向前移一步，随着不断提交，master分支的线越来越长。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNTA3OTcx?x-oss-process=image/format,png)\n    当创建新的分支时，Git新建一个指针dev，指向master相同指向的提交，再把HEAD指向dev，就表示当前分支在dev上。之后对工作区的修改和提交就是针对dev分支了，重新提交一次后，dev指针往前移动一步，而master指针不变。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjExNzA5?x-oss-process=image/format,png)\n    此时要把dev合并到master上，最简单的方法就是将master指向dev的当前提交，完成合并。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjUzMjM2?x-oss-process=image/format,png)\n    由于git的分支管理使用的是指针的方式，因此切换和合并起来操作非常快捷。同时<font color=red>鼓励使用分支进行工作</font>，工作完成后再合并到master上，这样有助于提升master的安全性。\n11. **分支冲突**\n当创建一个分支dev，并且提交了一个修改，同时切换到master上对同一文件进行了修改并提交，在合并分支时很可能会发生冲突，无法完成自动合并，此时只有手动解决冲突再提交才能继续合并。合并后时间线就变成如下。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwODM4ODg1?x-oss-process=image/format,png)\n12. **分支的非快速合并方式**\n分支合并时，会默认使用ff(fast forward)模式进行合并，但这样带来的坏处是会丢掉分支信息。此时可以禁用ff模式，在merge时生成新的提交。\n如下是ff模式\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMDAwMzg1?x-oss-process=image/format,png)\n    如下是非ff模式\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTM0Mzg5?x-oss-process=image/format,png)\n13. **分支策略**\n实际开发中管理分支的几个基本原则（还是要开发中实际应用才会有体会，现在体会不深）\n（1）master分支应该是稳定的，仅用来发布新版本，平时不能在上面干活\n（2）干活都在新建的dev分支上，dev是不稳定的，到版本发布时再将dev分支合并到master上\n（3）每个工作人员建立一个自己的分支，时不时在dev上进行合并就可以了。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTA5MjMw?x-oss-process=image/format,png)\n14. **BUG分支和feature分支**\n当我们临时解决一个BUG，或者增加一个新功能时，最好新建一个分支，待完成工作后再将该分支合并到工作分支中。\n15. 当你从远程仓库克隆时，Git自动把本地master分支和远程的master分支对应起来，并且远程仓库的默认名称是origin。可以把本地的分支往远程推送，推送完成后远程库的分支结构就基本和本地一样了，但是也可以不必把所有的分支推送，这个要看实际需求。\n16. **多人协作的情况（需要实际体会）**\n（1）首先，可以试图用<font color=green><i>git push origin branch-name</i></font>推送自己的修改；\n（2）如果推送失败，则因为远程分支比你的本地更新，需要先用<font color=green><i>git pull</i></font>抓取到本地试图合并；\n（3）如果合并有冲突，则解决冲突，并在本地提交；\n（4）没有冲突或者解决掉冲突后，再用<font color=green><i>git push origin branch-name</i></font>推送就能成功！\n注意：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<font color=green><i>git branch --set-upstream branch-name origin/branch-name。</i></font>\n17. 标签\n通常在版本库中打一个标签（tag），将来任何时候都可以按照标签名称来取某个时刻的历史版本。tag实际上是指向某个commit的指针，与分支不同的是，标签不能移动。可以理解为标签是固定在某一时刻的commit的指针。目的是能够很快地找到某一时刻的commit，而不用记复杂的commit id\n18. 在github上参与别人的开源项目\n    - 访问项目主页，点击fork，在自己的账号下克隆一个相同的仓库。\n    - 按照正常克隆的方式从自己的账号下克隆到本地，此时开源项目、你的远程库和本地库关系如下。\n    ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxODA4NDk0?x-oss-process=image/format,png)\n\n    - 本地修改后推送到自己账号的远程库\n    - 要想把自己修改的点推送给开源项目，可以在自己账号发起pull request。\n19. 忽略特殊文件\n有不想提交的文件时候，可以编写.gitignore文件，将不想提交的文件写到.gitignore文件中，这样在提交时候就会忽略该文件。注意文件名就是“.gitignore”，前面没有东西的。\n20. 添加.gitignore文件后没有效果解决办法\n原因：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决的办法就是先把本地缓存删除，改成未track状态，然后提交。\n（1）先将所有文件提交到Git\n（2）在Git根目录执行以下命令\n<font color=green><i>git rm -r --cached .</i></font>\n<font color=green><i>git add .</i></font>\n<font color=green><i>git commit -m \"fixed untracked files\".</i></font>\n1. 配置\n配置git时，加上--global是针对当前用户起作用的，如果不加就只对当前仓库起作用。\n每个仓库的配置文件都放在.git/config中，对整个仓库起作用。\n用户的配置恩见放在用户主目录下的一个隐藏文件/gitconfig中，对用户的所有仓库起作用\n可以直接修改配置文件，如果改错了可以删掉文件重新通过命令进行配置。\n<font color=red>鼓励进行别名的配置。</font>\n2. 自己搭建Git服务器\nGit功能强大，但是github并不是必须的，他只是作为一个一直开着的服务器而已，且兼有社区的作用。如果想要自己的代码不开源，又要用Git，那么可以自己搭建一个Git服务器。搭建方式[看这里](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000)\n3. 其它\n[Git官方网站](http://git-scm.com)\n[Git cheat sheet](https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit)","slug":"Git基础知识","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo94000600bnic4csw6b","content":"<h2 id=\"GIT简介\"><a href=\"#GIT简介\" class=\"headerlink\" title=\"GIT简介\"></a>GIT简介</h2><ol>\n<li>版本控制系统：即记录同一个文档在不同人和不同时间修改的各版本的系统，对于恢复文档、差异对比、协同工作有非常大的帮助。</li>\n<li>GIT是由linux创始人linus花费两周时间写成的，用于托管linux系统。目前已经有众多开源项目，如jQuery、PHP、Ruby等。<a id=\"more\"></a></li>\n<li>集中式版本控制系统：以CVS、SVN为代表，版本库是集中存放在中央服务器的，在使用时候要先从服务器中取得最新版本，本地操作完成后还要上传给服务器，非常不方便，而且不安全。</li>\n<li>分布式版本控制系统：以GIT为代表，没有集中式的中央服务器，每个人的电脑上都是一个完整的版本库，在工作完成之后只需要和其他同事交换修改的部分即可。具体工作方式还要实际体会。<br>分布式在本地维护一个完整的库，因此不需要联网也可以工作，等有网络时再把本地库推送到远程库即可。</li>\n</ol>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><ol>\n<li><p>所有的版本控制系统只能跟踪文本文件的改动，如txt文件、网页、程序代码等，并且可以明确告诉你在什么地方改了什么。而图片、视频等二进制文件则没有办法跟踪其变化，只能告知文件的大小改变情况，但是不知道具体改了什么。而微软的word就是二进制格式，因此不能详细跟踪。<br>基于以上原因，使用GIT时，就要以纯文本方式编写文件。</p>\n</li>\n<li><p>为了长久性和通用性考虑，编写文本时一定要通通使用UTF-8编码。</p>\n</li>\n<li><p>老司机寄语：千万不要用windows自带的记事本编辑任何文本文件。<br>原因：记事本团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf字符，对程序的编译之类的会造成错误。推荐使用Ntepad++</p>\n</li>\n<li><p>Git的版本会退速度很快，因为其内部有个指向当前版本的指针HEAD，回退或前进时只是改变了HEAD指向的位置。</p>\n</li>\n<li><p>工作区和暂存区<br>工作区：就是电脑上能够看到的目录（working directory）<br>版本库：工作区内有一个隐藏目录 .git，这是Gti的版本库<br>暂存区：Git的版本库中存了很多东西，最重要的就是成为stage（或者叫index）的缓存区。还有自动创建的第一个分支master，以及指向master的一个指针HEAD，如下图所示：</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTU0OTA5ODgy?x-oss-process=image/format,png\" alt=\"工作区、缓存区、版本库的关系\"></p>\n<p> 执行git add时，就是把文件修改添加到了缓存区；</p>\n<p> 执行git commit时，就是把缓存区的所有内容提交到当前分支。</p>\n</li>\n<li><p>git每次提交的是修改，不是整个文件，因此执行“第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit”这样的操作后，第二次修改是不会被提交的，因为第二次修改没有添加到暂存区。</p>\n</li>\n<li><p>在创建远程仓库之前，由于git和github之间是通过SSH加密传输的，因此要先创建SSH Key<br><font color=\"#0000ff\"><i>ssh-keygen -t rsa -C “<a href=\"mailto:youremail@example.com\" target=\"_blank\" rel=\"noopener\">youremail@example.com</a>“</i></font><br>创建之后在用户主目录下面会生成两个文件：id_rsa、id_rsa.pub，其中id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以告诉任何人。<br>为什么要SSH Key?<br>因为github需要识别你推送的文件确实是你推送的，而不是别人冒充的，因此需要身份验证。也可任意添加多个Key，每个Key对应不同的电脑，添加之后你可以使用不同的电脑推送文件。<br>本地生成SSH Key后，需要在github的个人账户中添加该公钥，这样才能正常使用。</p>\n</li>\n<li><p>添加远程库时，在创建一个repository后github会提示进行本地库的添加，按照提示来就好。</p>\n</li>\n<li><p>本地库在推送或从远程库提取东西时，支持两种协议：https和ssh，相比而言，ssh的速度更快。</p>\n</li>\n<li><p><strong>分支的概念</strong><br>分支就是科幻电影中的平行宇宙，当你在学习Git时，另一个你在另一个平行宇宙学习SVN，正常时两个宇宙互不干扰，但在某一个时间点，两个宇宙合并了，你就及学会了Git，又会了SVN。<br>实际用途：开发新功能，需要两周，第一周写了50%，如果立刻提交，会导致代码库不完整，致使别人不能干活，如果等写完了再一起上传，又存在丢失每天进度的风险。有了分支后，可以创建一个专属于你的分支，别人看不到，你在自己的分支上工作，等工作完成后，再把你自己的分支一次性合并到原来的分支上。<br>git中维护方式：默认创建一个master分支，master分支指向提交，HEAD指向当前分支，默认是master，每次提交，master就向前移一步，随着不断提交，master分支的线越来越长。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNTA3OTcx?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>当创建新的分支时，Git新建一个指针dev，指向master相同指向的提交，再把HEAD指向dev，就表示当前分支在dev上。之后对工作区的修改和提交就是针对dev分支了，重新提交一次后，dev指针往前移动一步，而master指针不变。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjExNzA5?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>此时要把dev合并到master上，最简单的方法就是将master指向dev的当前提交，完成合并。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjUzMjM2?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>由于git的分支管理使用的是指针的方式，因此切换和合并起来操作非常快捷。同时<font color=\"red\">鼓励使用分支进行工作</font>，工作完成后再合并到master上，这样有助于提升master的安全性。</p>\n</li>\n<li><p><strong>分支冲突</strong><br>当创建一个分支dev，并且提交了一个修改，同时切换到master上对同一文件进行了修改并提交，在合并分支时很可能会发生冲突，无法完成自动合并，此时只有手动解决冲突再提交才能继续合并。合并后时间线就变成如下。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwODM4ODg1?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p><strong>分支的非快速合并方式</strong><br>分支合并时，会默认使用ff(fast forward)模式进行合并，但这样带来的坏处是会丢掉分支信息。此时可以禁用ff模式，在merge时生成新的提交。<br>如下是ff模式<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMDAwMzg1?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>如下是非ff模式<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTM0Mzg5?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p><strong>分支策略</strong><br>实际开发中管理分支的几个基本原则（还是要开发中实际应用才会有体会，现在体会不深）<br>（1）master分支应该是稳定的，仅用来发布新版本，平时不能在上面干活<br>（2）干活都在新建的dev分支上，dev是不稳定的，到版本发布时再将dev分支合并到master上<br>（3）每个工作人员建立一个自己的分支，时不时在dev上进行合并就可以了。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTA5MjMw?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p><strong>BUG分支和feature分支</strong><br>当我们临时解决一个BUG，或者增加一个新功能时，最好新建一个分支，待完成工作后再将该分支合并到工作分支中。</p>\n</li>\n<li><p>当你从远程仓库克隆时，Git自动把本地master分支和远程的master分支对应起来，并且远程仓库的默认名称是origin。可以把本地的分支往远程推送，推送完成后远程库的分支结构就基本和本地一样了，但是也可以不必把所有的分支推送，这个要看实际需求。</p>\n</li>\n<li><p><strong>多人协作的情况（需要实际体会）</strong><br>（1）首先，可以试图用<font color=\"green\"><i>git push origin branch-name</i></font>推送自己的修改；<br>（2）如果推送失败，则因为远程分支比你的本地更新，需要先用<font color=\"green\"><i>git pull</i></font>抓取到本地试图合并；<br>（3）如果合并有冲突，则解决冲突，并在本地提交；<br>（4）没有冲突或者解决掉冲突后，再用<font color=\"green\"><i>git push origin branch-name</i></font>推送就能成功！<br>注意：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<font color=\"green\"><i>git branch –set-upstream branch-name origin/branch-name。</i></font></p>\n</li>\n<li><p>标签<br>通常在版本库中打一个标签（tag），将来任何时候都可以按照标签名称来取某个时刻的历史版本。tag实际上是指向某个commit的指针，与分支不同的是，标签不能移动。可以理解为标签是固定在某一时刻的commit的指针。目的是能够很快地找到某一时刻的commit，而不用记复杂的commit id</p>\n</li>\n<li><p>在github上参与别人的开源项目</p>\n<ul>\n<li><p>访问项目主页，点击fork，在自己的账号下克隆一个相同的仓库。</p>\n</li>\n<li><p>按照正常克隆的方式从自己的账号下克隆到本地，此时开源项目、你的远程库和本地库关系如下。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxODA4NDk0?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p>本地修改后推送到自己账号的远程库</p>\n</li>\n<li><p>要想把自己修改的点推送给开源项目，可以在自己账号发起pull request。</p>\n</li>\n</ul>\n</li>\n<li><p>忽略特殊文件<br>有不想提交的文件时候，可以编写.gitignore文件，将不想提交的文件写到.gitignore文件中，这样在提交时候就会忽略该文件。注意文件名就是“.gitignore”，前面没有东西的。</p>\n</li>\n<li><p>添加.gitignore文件后没有效果解决办法<br>原因：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决的办法就是先把本地缓存删除，改成未track状态，然后提交。<br>（1）先将所有文件提交到Git<br>（2）在Git根目录执行以下命令<br><font color=\"green\"><i>git rm -r –cached .</i></font><br><font color=\"green\"><i>git add .</i></font><br><font color=\"green\"><i>git commit -m “fixed untracked files”.</i></font></p>\n</li>\n<li><p>配置<br>配置git时，加上–global是针对当前用户起作用的，如果不加就只对当前仓库起作用。<br>每个仓库的配置文件都放在.git/config中，对整个仓库起作用。<br>用户的配置恩见放在用户主目录下的一个隐藏文件/gitconfig中，对用户的所有仓库起作用<br>可以直接修改配置文件，如果改错了可以删掉文件重新通过命令进行配置。<br><font color=\"red\">鼓励进行别名的配置。</font></p>\n</li>\n<li><p>自己搭建Git服务器<br>Git功能强大，但是github并不是必须的，他只是作为一个一直开着的服务器而已，且兼有社区的作用。如果想要自己的代码不开源，又要用Git，那么可以自己搭建一个Git服务器。搭建方式<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000\" target=\"_blank\" rel=\"noopener\">看这里</a></p>\n</li>\n<li><p>其它<br><a href=\"http://git-scm.com\" target=\"_blank\" rel=\"noopener\">Git官方网站</a><br><a href=\"https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit\" target=\"_blank\" rel=\"noopener\">Git cheat sheet</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"GIT简介\"><a href=\"#GIT简介\" class=\"headerlink\" title=\"GIT简介\"></a>GIT简介</h2><ol>\n<li>版本控制系统：即记录同一个文档在不同人和不同时间修改的各版本的系统，对于恢复文档、差异对比、协同工作有非常大的帮助。</li>\n<li>GIT是由linux创始人linus花费两周时间写成的，用于托管linux系统。目前已经有众多开源项目，如jQuery、PHP、Ruby等。","more":"</li>\n<li>集中式版本控制系统：以CVS、SVN为代表，版本库是集中存放在中央服务器的，在使用时候要先从服务器中取得最新版本，本地操作完成后还要上传给服务器，非常不方便，而且不安全。</li>\n<li>分布式版本控制系统：以GIT为代表，没有集中式的中央服务器，每个人的电脑上都是一个完整的版本库，在工作完成之后只需要和其他同事交换修改的部分即可。具体工作方式还要实际体会。<br>分布式在本地维护一个完整的库，因此不需要联网也可以工作，等有网络时再把本地库推送到远程库即可。</li>\n</ol>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><ol>\n<li><p>所有的版本控制系统只能跟踪文本文件的改动，如txt文件、网页、程序代码等，并且可以明确告诉你在什么地方改了什么。而图片、视频等二进制文件则没有办法跟踪其变化，只能告知文件的大小改变情况，但是不知道具体改了什么。而微软的word就是二进制格式，因此不能详细跟踪。<br>基于以上原因，使用GIT时，就要以纯文本方式编写文件。</p>\n</li>\n<li><p>为了长久性和通用性考虑，编写文本时一定要通通使用UTF-8编码。</p>\n</li>\n<li><p>老司机寄语：千万不要用windows自带的记事本编辑任何文本文件。<br>原因：记事本团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf字符，对程序的编译之类的会造成错误。推荐使用Ntepad++</p>\n</li>\n<li><p>Git的版本会退速度很快，因为其内部有个指向当前版本的指针HEAD，回退或前进时只是改变了HEAD指向的位置。</p>\n</li>\n<li><p>工作区和暂存区<br>工作区：就是电脑上能够看到的目录（working directory）<br>版本库：工作区内有一个隐藏目录 .git，这是Gti的版本库<br>暂存区：Git的版本库中存了很多东西，最重要的就是成为stage（或者叫index）的缓存区。还有自动创建的第一个分支master，以及指向master的一个指针HEAD，如下图所示：</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTU0OTA5ODgy?x-oss-process=image/format,png\" alt=\"工作区、缓存区、版本库的关系\"></p>\n<p> 执行git add时，就是把文件修改添加到了缓存区；</p>\n<p> 执行git commit时，就是把缓存区的所有内容提交到当前分支。</p>\n</li>\n<li><p>git每次提交的是修改，不是整个文件，因此执行“第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit”这样的操作后，第二次修改是不会被提交的，因为第二次修改没有添加到暂存区。</p>\n</li>\n<li><p>在创建远程仓库之前，由于git和github之间是通过SSH加密传输的，因此要先创建SSH Key<br><font color=\"#0000ff\"><i>ssh-keygen -t rsa -C “<a href=\"mailto:youremail@example.com\" target=\"_blank\" rel=\"noopener\">youremail@example.com</a>“</i></font><br>创建之后在用户主目录下面会生成两个文件：id_rsa、id_rsa.pub，其中id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以告诉任何人。<br>为什么要SSH Key?<br>因为github需要识别你推送的文件确实是你推送的，而不是别人冒充的，因此需要身份验证。也可任意添加多个Key，每个Key对应不同的电脑，添加之后你可以使用不同的电脑推送文件。<br>本地生成SSH Key后，需要在github的个人账户中添加该公钥，这样才能正常使用。</p>\n</li>\n<li><p>添加远程库时，在创建一个repository后github会提示进行本地库的添加，按照提示来就好。</p>\n</li>\n<li><p>本地库在推送或从远程库提取东西时，支持两种协议：https和ssh，相比而言，ssh的速度更快。</p>\n</li>\n<li><p><strong>分支的概念</strong><br>分支就是科幻电影中的平行宇宙，当你在学习Git时，另一个你在另一个平行宇宙学习SVN，正常时两个宇宙互不干扰，但在某一个时间点，两个宇宙合并了，你就及学会了Git，又会了SVN。<br>实际用途：开发新功能，需要两周，第一周写了50%，如果立刻提交，会导致代码库不完整，致使别人不能干活，如果等写完了再一起上传，又存在丢失每天进度的风险。有了分支后，可以创建一个专属于你的分支，别人看不到，你在自己的分支上工作，等工作完成后，再把你自己的分支一次性合并到原来的分支上。<br>git中维护方式：默认创建一个master分支，master分支指向提交，HEAD指向当前分支，默认是master，每次提交，master就向前移一步，随着不断提交，master分支的线越来越长。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNTA3OTcx?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>当创建新的分支时，Git新建一个指针dev，指向master相同指向的提交，再把HEAD指向dev，就表示当前分支在dev上。之后对工作区的修改和提交就是针对dev分支了，重新提交一次后，dev指针往前移动一步，而master指针不变。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjExNzA5?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>此时要把dev合并到master上，最简单的方法就是将master指向dev的当前提交，完成合并。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwNjUzMjM2?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>由于git的分支管理使用的是指针的方式，因此切换和合并起来操作非常快捷。同时<font color=\"red\">鼓励使用分支进行工作</font>，工作完成后再合并到master上，这样有助于提升master的安全性。</p>\n</li>\n<li><p><strong>分支冲突</strong><br>当创建一个分支dev，并且提交了一个修改，同时切换到master上对同一文件进行了修改并提交，在合并分支时很可能会发生冲突，无法完成自动合并，此时只有手动解决冲突再提交才能继续合并。合并后时间线就变成如下。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYwODM4ODg1?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p><strong>分支的非快速合并方式</strong><br>分支合并时，会默认使用ff(fast forward)模式进行合并，但这样带来的坏处是会丢掉分支信息。此时可以禁用ff模式，在merge时生成新的提交。<br>如下是ff模式<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMDAwMzg1?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>如下是非ff模式<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTM0Mzg5?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p><strong>分支策略</strong><br>实际开发中管理分支的几个基本原则（还是要开发中实际应用才会有体会，现在体会不深）<br>（1）master分支应该是稳定的，仅用来发布新版本，平时不能在上面干活<br>（2）干活都在新建的dev分支上，dev是不稳定的，到版本发布时再将dev分支合并到master上<br>（3）每个工作人员建立一个自己的分支，时不时在dev上进行合并就可以了。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxMTA5MjMw?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p><strong>BUG分支和feature分支</strong><br>当我们临时解决一个BUG，或者增加一个新功能时，最好新建一个分支，待完成工作后再将该分支合并到工作分支中。</p>\n</li>\n<li><p>当你从远程仓库克隆时，Git自动把本地master分支和远程的master分支对应起来，并且远程仓库的默认名称是origin。可以把本地的分支往远程推送，推送完成后远程库的分支结构就基本和本地一样了，但是也可以不必把所有的分支推送，这个要看实际需求。</p>\n</li>\n<li><p><strong>多人协作的情况（需要实际体会）</strong><br>（1）首先，可以试图用<font color=\"green\"><i>git push origin branch-name</i></font>推送自己的修改；<br>（2）如果推送失败，则因为远程分支比你的本地更新，需要先用<font color=\"green\"><i>git pull</i></font>抓取到本地试图合并；<br>（3）如果合并有冲突，则解决冲突，并在本地提交；<br>（4）没有冲突或者解决掉冲突后，再用<font color=\"green\"><i>git push origin branch-name</i></font>推送就能成功！<br>注意：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<font color=\"green\"><i>git branch –set-upstream branch-name origin/branch-name。</i></font></p>\n</li>\n<li><p>标签<br>通常在版本库中打一个标签（tag），将来任何时候都可以按照标签名称来取某个时刻的历史版本。tag实际上是指向某个commit的指针，与分支不同的是，标签不能移动。可以理解为标签是固定在某一时刻的commit的指针。目的是能够很快地找到某一时刻的commit，而不用记复杂的commit id</p>\n</li>\n<li><p>在github上参与别人的开源项目</p>\n<ul>\n<li><p>访问项目主页，点击fork，在自己的账号下克隆一个相同的仓库。</p>\n</li>\n<li><p>按照正常克隆的方式从自己的账号下克隆到本地，此时开源项目、你的远程库和本地库关系如下。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjE1MTYxODA4NDk0?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n</li>\n<li><p>本地修改后推送到自己账号的远程库</p>\n</li>\n<li><p>要想把自己修改的点推送给开源项目，可以在自己账号发起pull request。</p>\n</li>\n</ul>\n</li>\n<li><p>忽略特殊文件<br>有不想提交的文件时候，可以编写.gitignore文件，将不想提交的文件写到.gitignore文件中，这样在提交时候就会忽略该文件。注意文件名就是“.gitignore”，前面没有东西的。</p>\n</li>\n<li><p>添加.gitignore文件后没有效果解决办法<br>原因：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决的办法就是先把本地缓存删除，改成未track状态，然后提交。<br>（1）先将所有文件提交到Git<br>（2）在Git根目录执行以下命令<br><font color=\"green\"><i>git rm -r –cached .</i></font><br><font color=\"green\"><i>git add .</i></font><br><font color=\"green\"><i>git commit -m “fixed untracked files”.</i></font></p>\n</li>\n<li><p>配置<br>配置git时，加上–global是针对当前用户起作用的，如果不加就只对当前仓库起作用。<br>每个仓库的配置文件都放在.git/config中，对整个仓库起作用。<br>用户的配置恩见放在用户主目录下的一个隐藏文件/gitconfig中，对用户的所有仓库起作用<br>可以直接修改配置文件，如果改错了可以删掉文件重新通过命令进行配置。<br><font color=\"red\">鼓励进行别名的配置。</font></p>\n</li>\n<li><p>自己搭建Git服务器<br>Git功能强大，但是github并不是必须的，他只是作为一个一直开着的服务器而已，且兼有社区的作用。如果想要自己的代码不开源，又要用Git，那么可以自己搭建一个Git服务器。搭建方式<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000\" target=\"_blank\" rel=\"noopener\">看这里</a></p>\n</li>\n<li><p>其它<br><a href=\"http://git-scm.com\" target=\"_blank\" rel=\"noopener\">Git官方网站</a><br><a href=\"https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit\" target=\"_blank\" rel=\"noopener\">Git cheat sheet</a></p>\n</li>\n</ol>"},{"title":"Spring Webflow - 前言","date":"2018-09-04T12:00:00.000Z","_content":"\n虽然之前没有听说过Spring Web Flow这个东西，听说之后上网查了一下又有很多人不屑于使用web flow，但自己目前工作上的项目要用到它，因此学习是很有必要的。当学习一项新技术时，最快捷的方式就是上网搜索速成教程，看了一些，总觉得有些不得要领，于是转向官方文档。又怕自己久了会忘，故此写一套学习笔记，详细地介绍使用方法。该笔记参考官方文档，自己加以整理而成。\n\n什么是web flow，这里也不免俗地引用一下百度百科的内容（也基本上是官方介绍的翻译。。。）：\n\n> Spring Web Flow (SWF) 是Spring Framework的一个脱离模块。这个模块是Spring Web应用开发模块栈的一部分，Spring Web包含Spring MVC。Spring Web Flow 的目标是成为管理Web应用页面流程的最佳方案。当你的应用需要复杂的导航控制，例如向导，在一个比较大的事务过程中去指导用户经过一连串的步骤的时候，SWF将会是一个功能强大的控制器。\n\n详细内容见本系列正文内容\n\n","source":"_posts/Spring Webflow - 前言.md","raw":"---\ntitle: Spring Webflow - 前言\ndate: 2018-09-04 20:00:00\ntags: \n    - Spring\n    - Webflow\ncategories: \n    - Spring Webflow\n---\n\n虽然之前没有听说过Spring Web Flow这个东西，听说之后上网查了一下又有很多人不屑于使用web flow，但自己目前工作上的项目要用到它，因此学习是很有必要的。当学习一项新技术时，最快捷的方式就是上网搜索速成教程，看了一些，总觉得有些不得要领，于是转向官方文档。又怕自己久了会忘，故此写一套学习笔记，详细地介绍使用方法。该笔记参考官方文档，自己加以整理而成。\n\n什么是web flow，这里也不免俗地引用一下百度百科的内容（也基本上是官方介绍的翻译。。。）：\n\n> Spring Web Flow (SWF) 是Spring Framework的一个脱离模块。这个模块是Spring Web应用开发模块栈的一部分，Spring Web包含Spring MVC。Spring Web Flow 的目标是成为管理Web应用页面流程的最佳方案。当你的应用需要复杂的导航控制，例如向导，在一个比较大的事务过程中去指导用户经过一连串的步骤的时候，SWF将会是一个功能强大的控制器。\n\n详细内容见本系列正文内容\n\n","slug":"Spring Webflow - 前言","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo96000800bnfzw8823r","content":"<p>虽然之前没有听说过Spring Web Flow这个东西，听说之后上网查了一下又有很多人不屑于使用web flow，但自己目前工作上的项目要用到它，因此学习是很有必要的。当学习一项新技术时，最快捷的方式就是上网搜索速成教程，看了一些，总觉得有些不得要领，于是转向官方文档。又怕自己久了会忘，故此写一套学习笔记，详细地介绍使用方法。该笔记参考官方文档，自己加以整理而成。</p><a id=\"more\"></a>\n<p>什么是web flow，这里也不免俗地引用一下百度百科的内容（也基本上是官方介绍的翻译。。。）：</p>\n<blockquote>\n<p>Spring Web Flow (SWF) 是Spring Framework的一个脱离模块。这个模块是Spring Web应用开发模块栈的一部分，Spring Web包含Spring MVC。Spring Web Flow 的目标是成为管理Web应用页面流程的最佳方案。当你的应用需要复杂的导航控制，例如向导，在一个比较大的事务过程中去指导用户经过一连串的步骤的时候，SWF将会是一个功能强大的控制器。</p>\n</blockquote>\n<p>详细内容见本系列正文内容</p>\n","site":{"data":{}},"excerpt":"<p>虽然之前没有听说过Spring Web Flow这个东西，听说之后上网查了一下又有很多人不屑于使用web flow，但自己目前工作上的项目要用到它，因此学习是很有必要的。当学习一项新技术时，最快捷的方式就是上网搜索速成教程，看了一些，总觉得有些不得要领，于是转向官方文档。又怕自己久了会忘，故此写一套学习笔记，详细地介绍使用方法。该笔记参考官方文档，自己加以整理而成。</p>","more":"\n<p>什么是web flow，这里也不免俗地引用一下百度百科的内容（也基本上是官方介绍的翻译。。。）：</p>\n<blockquote>\n<p>Spring Web Flow (SWF) 是Spring Framework的一个脱离模块。这个模块是Spring Web应用开发模块栈的一部分，Spring Web包含Spring MVC。Spring Web Flow 的目标是成为管理Web应用页面流程的最佳方案。当你的应用需要复杂的导航控制，例如向导，在一个比较大的事务过程中去指导用户经过一连串的步骤的时候，SWF将会是一个功能强大的控制器。</p>\n</blockquote>\n<p>详细内容见本系列正文内容</p>\n"},{"title":"Spring Webflow - Action","date":"2018-09-08T03:00:00.000Z","_content":"\n# action-state\n## 简单使用\n该状态只执行操作，然后根据操作的结果转移到其他state。可以有多个操作，他们依次执行\n\n```\n<action-state id=\"moreAnswersNeeded\">\n\t<evaluate expression=\"interview.moreAnswersNeeded()\" />\n\t<transition on=\"yes\" to=\"answerQuestions\" />\n\t<transition on=\"no\" to=\"finish\" />\n</action-state>\n```\n## 输出\n在action-state中调用普通java对象的方法，这些方法返回的只是一般的值，但是transition标签需要Event来触发，因此web-flow会将这个普通返回值转换为Event对象，具体转换情况如下:\n\n```\n方法返回值类型\t\t\t映射出来的EventId\njava.lang.String\t\t直接以字符串的值作为id\njava.lang.Boolean\t\tyes (for true), no (for false)\njava.lang.Enum\t\t\tthe Enum name\nany other type\t    \tsuccess\n```\n## action-state的操作\naction-state可以有三种方式进行执行操作\n\n - 调用POJO\n\n```\n<evaluate expression=\"pojoAction.method(flowRequestContext)\" />\n```\n\n```\npublic class PojoAction {\n\tpublic String method(RequestContext context) {\n\t\t...\n\t}\n}\n```\n\n - 实现Action接口，直接调用该action\n\n```\n<evaluate expression=\"customAction\" />\n```\n\n```\npublic class CustomAction implements Action {\n\tpublic Event execute(RequestContext context) {\n\t\t...\n\t}\n}\n```\n\n - 实现MultiAction接口，可以定义多个一连串的方法\n\n```\n<evaluate expression=\"multiAction.actionMethod1\" />\n```\n\n```\npublic class CustomMultiAction extends MultiAction {\n\tpublic Event actionMethod1(RequestContext context) {\n\t\t...\n\t}\n\n\tpublic Event actionMethod2(RequestContext context) {\n\t\t...\n\t}\n\t...\n}\n```\n## action的异常处理\n\n - POJO类action的处理方式\n发生异常时，返回相应的字符串，会映射成Event，在transition中响应就可以了，和普通方法正常返回一样\n - MultiAction的处理方式\n发生异常时，返回Event对象\n\n```\npublic class BookingAction extends MultiAction {\n\tpublic Event makeBooking(RequestContext context) {\n\t\t   try {\n\t\t\t   Booking booking = (Booking) context.getFlowScope().get(\"booking\");\n\t\t\t   BookingConfirmation confirmation = bookingService.make(booking);\n\t\t\t   context.getFlowScope().put(\"confirmation\", confirmation);\n\t\t\t   return success();\n\t\t   } catch (RoomNotAvailableException e) {\n\t\t\t   context.getMessageContext().addMessage(new MessageBuilder().error().\n\t\t\t\t   .defaultText(\"No room is available at this hotel\").build());\n\t\t\t   return error();\n\t\t   }\n\t}\n}\n```\n - 使用`exception-handler`属性，定义异常处理器\n\n## decision-state\ndecision-state是action-state的一种简单替代，在if/else情况时比较好用\n\n```\n<decision-state id=\"moreAnswersNeeded\">\n\t<if test=\"interview.moreAnswersNeeded()\" then=\"answerQuestions\" else=\"finish\" />\n</decision-state>\n```\n## action相关标签\n\n1) `<on-start>`\tflow开始时执行\n2) `<on-entry>`\tstate进入时执行\n3) `<on-exit>`\tstate退出时执行\n4) `<on-end>`\tflow结束时执行\n5) `<on-render>`view-state中使用，渲染前执行\n6) `<transition>`\t在转移前执行\n## 命名的action\n如下展示了一个action-state下多个操作执行，为每个操作命名，第二个操作成功后进行转移操作\n\n```\n<action-state id=\"doTwoThings\">\n\t<evaluate expression=\"service.thingOne()\">\n\t\t<attribute name=\"name\" value=\"thingOne\" />\n\t</evaluate>\n\t<evaluate expression=\"service.thingTwo()\">\n\t\t<attribute name=\"name\" value=\"thingTwo\" />\n\t</evaluate>\n\t<transition on=\"thingTwo.success\" to=\"showResults\" />\n</action-state>\n```\n# 向客户端发送流信息\n## 应用场景\n客户端请求一个图片文件，此时我们需要直接操作httpresponse进行图片的响应，而不是渲染view。\n## 解决方案\n通过ExternalContext获取HttpResponse，将图片写入，然后操作ExternalContext对象记录response完成，这样web-flow就不会再渲染view，而是直接返回给浏览器\n\n```\npublic class PrintBoardingPassAction extends AbstractAction {\n\n    @Override\n    protected Event doExecute(RequestContext context) throws Exception {\n        HttpServletResponse response = (HttpServletResponse)context.getExternalContext().getNativeResponse();\n        OutputStream os = response.getOutputStream();\n        // 在这里操作os，写入流数据\n        os.close();\n        context.getExternalContext().recordResponseComplete();\n        return success();\n    }\n\n}\n```","source":"_posts/Spring Webflow - Action.md","raw":"---\ntitle: Spring Webflow - Action\ndate: 2018-09-08 11:00:00\ntags: \n    - Spring\n    - Webflow\ncategories: \n    - Spring Webflow\n---\n\n# action-state\n## 简单使用\n该状态只执行操作，然后根据操作的结果转移到其他state。可以有多个操作，他们依次执行\n\n```\n<action-state id=\"moreAnswersNeeded\">\n\t<evaluate expression=\"interview.moreAnswersNeeded()\" />\n\t<transition on=\"yes\" to=\"answerQuestions\" />\n\t<transition on=\"no\" to=\"finish\" />\n</action-state>\n```\n## 输出\n在action-state中调用普通java对象的方法，这些方法返回的只是一般的值，但是transition标签需要Event来触发，因此web-flow会将这个普通返回值转换为Event对象，具体转换情况如下:\n\n```\n方法返回值类型\t\t\t映射出来的EventId\njava.lang.String\t\t直接以字符串的值作为id\njava.lang.Boolean\t\tyes (for true), no (for false)\njava.lang.Enum\t\t\tthe Enum name\nany other type\t    \tsuccess\n```\n## action-state的操作\naction-state可以有三种方式进行执行操作\n\n - 调用POJO\n\n```\n<evaluate expression=\"pojoAction.method(flowRequestContext)\" />\n```\n\n```\npublic class PojoAction {\n\tpublic String method(RequestContext context) {\n\t\t...\n\t}\n}\n```\n\n - 实现Action接口，直接调用该action\n\n```\n<evaluate expression=\"customAction\" />\n```\n\n```\npublic class CustomAction implements Action {\n\tpublic Event execute(RequestContext context) {\n\t\t...\n\t}\n}\n```\n\n - 实现MultiAction接口，可以定义多个一连串的方法\n\n```\n<evaluate expression=\"multiAction.actionMethod1\" />\n```\n\n```\npublic class CustomMultiAction extends MultiAction {\n\tpublic Event actionMethod1(RequestContext context) {\n\t\t...\n\t}\n\n\tpublic Event actionMethod2(RequestContext context) {\n\t\t...\n\t}\n\t...\n}\n```\n## action的异常处理\n\n - POJO类action的处理方式\n发生异常时，返回相应的字符串，会映射成Event，在transition中响应就可以了，和普通方法正常返回一样\n - MultiAction的处理方式\n发生异常时，返回Event对象\n\n```\npublic class BookingAction extends MultiAction {\n\tpublic Event makeBooking(RequestContext context) {\n\t\t   try {\n\t\t\t   Booking booking = (Booking) context.getFlowScope().get(\"booking\");\n\t\t\t   BookingConfirmation confirmation = bookingService.make(booking);\n\t\t\t   context.getFlowScope().put(\"confirmation\", confirmation);\n\t\t\t   return success();\n\t\t   } catch (RoomNotAvailableException e) {\n\t\t\t   context.getMessageContext().addMessage(new MessageBuilder().error().\n\t\t\t\t   .defaultText(\"No room is available at this hotel\").build());\n\t\t\t   return error();\n\t\t   }\n\t}\n}\n```\n - 使用`exception-handler`属性，定义异常处理器\n\n## decision-state\ndecision-state是action-state的一种简单替代，在if/else情况时比较好用\n\n```\n<decision-state id=\"moreAnswersNeeded\">\n\t<if test=\"interview.moreAnswersNeeded()\" then=\"answerQuestions\" else=\"finish\" />\n</decision-state>\n```\n## action相关标签\n\n1) `<on-start>`\tflow开始时执行\n2) `<on-entry>`\tstate进入时执行\n3) `<on-exit>`\tstate退出时执行\n4) `<on-end>`\tflow结束时执行\n5) `<on-render>`view-state中使用，渲染前执行\n6) `<transition>`\t在转移前执行\n## 命名的action\n如下展示了一个action-state下多个操作执行，为每个操作命名，第二个操作成功后进行转移操作\n\n```\n<action-state id=\"doTwoThings\">\n\t<evaluate expression=\"service.thingOne()\">\n\t\t<attribute name=\"name\" value=\"thingOne\" />\n\t</evaluate>\n\t<evaluate expression=\"service.thingTwo()\">\n\t\t<attribute name=\"name\" value=\"thingTwo\" />\n\t</evaluate>\n\t<transition on=\"thingTwo.success\" to=\"showResults\" />\n</action-state>\n```\n# 向客户端发送流信息\n## 应用场景\n客户端请求一个图片文件，此时我们需要直接操作httpresponse进行图片的响应，而不是渲染view。\n## 解决方案\n通过ExternalContext获取HttpResponse，将图片写入，然后操作ExternalContext对象记录response完成，这样web-flow就不会再渲染view，而是直接返回给浏览器\n\n```\npublic class PrintBoardingPassAction extends AbstractAction {\n\n    @Override\n    protected Event doExecute(RequestContext context) throws Exception {\n        HttpServletResponse response = (HttpServletResponse)context.getExternalContext().getNativeResponse();\n        OutputStream os = response.getOutputStream();\n        // 在这里操作os，写入流数据\n        os.close();\n        context.getExternalContext().recordResponseComplete();\n        return success();\n    }\n\n}\n```","slug":"Spring Webflow - Action","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo97000a00bn2m4e2akf","content":"<h1 id=\"action-state\"><a href=\"#action-state\" class=\"headerlink\" title=\"action-state\"></a>action-state</h1><h2 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h2><p>该状态只执行操作，然后根据操作的结果转移到其他state。可以有多个操作，他们依次执行</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;moreAnswersNeeded&quot;&gt;</span><br><span class=\"line\">\t&lt;evaluate expression=&quot;interview.moreAnswersNeeded()&quot; /&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;yes&quot; to=&quot;answerQuestions&quot; /&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;no&quot; to=&quot;finish&quot; /&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n\n\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p>在action-state中调用普通java对象的方法，这些方法返回的只是一般的值，但是transition标签需要Event来触发，因此web-flow会将这个普通返回值转换为Event对象，具体转换情况如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法返回值类型\t\t\t映射出来的EventId</span><br><span class=\"line\">java.lang.String\t\t直接以字符串的值作为id</span><br><span class=\"line\">java.lang.Boolean\t\tyes (for true), no (for false)</span><br><span class=\"line\">java.lang.Enum\t\t\tthe Enum name</span><br><span class=\"line\">any other type\t    \tsuccess</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"action-state的操作\"><a href=\"#action-state的操作\" class=\"headerlink\" title=\"action-state的操作\"></a>action-state的操作</h2><p>action-state可以有三种方式进行执行操作</p>\n<ul>\n<li>调用POJO</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;evaluate expression=&quot;pojoAction.method(flowRequestContext)&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PojoAction &#123;</span><br><span class=\"line\">\tpublic String method(RequestContext context) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实现Action接口，直接调用该action</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;evaluate expression=&quot;customAction&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomAction implements Action &#123;</span><br><span class=\"line\">\tpublic Event execute(RequestContext context) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实现MultiAction接口，可以定义多个一连串的方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;evaluate expression=&quot;multiAction.actionMethod1&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomMultiAction extends MultiAction &#123;</span><br><span class=\"line\">\tpublic Event actionMethod1(RequestContext context) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Event actionMethod2(RequestContext context) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"action的异常处理\"><a href=\"#action的异常处理\" class=\"headerlink\" title=\"action的异常处理\"></a>action的异常处理</h2><ul>\n<li>POJO类action的处理方式<br>发生异常时，返回相应的字符串，会映射成Event，在transition中响应就可以了，和普通方法正常返回一样</li>\n<li>MultiAction的处理方式<br>发生异常时，返回Event对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookingAction extends MultiAction &#123;</span><br><span class=\"line\">\tpublic Event makeBooking(RequestContext context) &#123;</span><br><span class=\"line\">\t\t   try &#123;</span><br><span class=\"line\">\t\t\t   Booking booking = (Booking) context.getFlowScope().get(&quot;booking&quot;);</span><br><span class=\"line\">\t\t\t   BookingConfirmation confirmation = bookingService.make(booking);</span><br><span class=\"line\">\t\t\t   context.getFlowScope().put(&quot;confirmation&quot;, confirmation);</span><br><span class=\"line\">\t\t\t   return success();</span><br><span class=\"line\">\t\t   &#125; catch (RoomNotAvailableException e) &#123;</span><br><span class=\"line\">\t\t\t   context.getMessageContext().addMessage(new MessageBuilder().error().</span><br><span class=\"line\">\t\t\t\t   .defaultText(&quot;No room is available at this hotel&quot;).build());</span><br><span class=\"line\">\t\t\t   return error();</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>exception-handler</code>属性，定义异常处理器</li>\n</ul>\n<h2 id=\"decision-state\"><a href=\"#decision-state\" class=\"headerlink\" title=\"decision-state\"></a>decision-state</h2><p>decision-state是action-state的一种简单替代，在if/else情况时比较好用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;decision-state id=&quot;moreAnswersNeeded&quot;&gt;</span><br><span class=\"line\">\t&lt;if test=&quot;interview.moreAnswersNeeded()&quot; then=&quot;answerQuestions&quot; else=&quot;finish&quot; /&gt;</span><br><span class=\"line\">&lt;/decision-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"action相关标签\"><a href=\"#action相关标签\" class=\"headerlink\" title=\"action相关标签\"></a>action相关标签</h2><p>1) <code>&lt;on-start&gt;</code>    flow开始时执行<br>2) <code>&lt;on-entry&gt;</code>    state进入时执行<br>3) <code>&lt;on-exit&gt;</code>    state退出时执行<br>4) <code>&lt;on-end&gt;</code>    flow结束时执行<br>5) <code>&lt;on-render&gt;</code>view-state中使用，渲染前执行<br>6) <code>&lt;transition&gt;</code>    在转移前执行</p>\n<h2 id=\"命名的action\"><a href=\"#命名的action\" class=\"headerlink\" title=\"命名的action\"></a>命名的action</h2><p>如下展示了一个action-state下多个操作执行，为每个操作命名，第二个操作成功后进行转移操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;doTwoThings&quot;&gt;</span><br><span class=\"line\">\t&lt;evaluate expression=&quot;service.thingOne()&quot;&gt;</span><br><span class=\"line\">\t\t&lt;attribute name=&quot;name&quot; value=&quot;thingOne&quot; /&gt;</span><br><span class=\"line\">\t&lt;/evaluate&gt;</span><br><span class=\"line\">\t&lt;evaluate expression=&quot;service.thingTwo()&quot;&gt;</span><br><span class=\"line\">\t\t&lt;attribute name=&quot;name&quot; value=&quot;thingTwo&quot; /&gt;</span><br><span class=\"line\">\t&lt;/evaluate&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;thingTwo.success&quot; to=&quot;showResults&quot; /&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"向客户端发送流信息\"><a href=\"#向客户端发送流信息\" class=\"headerlink\" title=\"向客户端发送流信息\"></a>向客户端发送流信息</h1><h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>客户端请求一个图片文件，此时我们需要直接操作httpresponse进行图片的响应，而不是渲染view。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>通过ExternalContext获取HttpResponse，将图片写入，然后操作ExternalContext对象记录response完成，这样web-flow就不会再渲染view，而是直接返回给浏览器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PrintBoardingPassAction extends AbstractAction &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Event doExecute(RequestContext context) throws Exception &#123;</span><br><span class=\"line\">        HttpServletResponse response = (HttpServletResponse)context.getExternalContext().getNativeResponse();</span><br><span class=\"line\">        OutputStream os = response.getOutputStream();</span><br><span class=\"line\">        // 在这里操作os，写入流数据</span><br><span class=\"line\">        os.close();</span><br><span class=\"line\">        context.getExternalContext().recordResponseComplete();</span><br><span class=\"line\">        return success();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"action-state\"><a href=\"#action-state\" class=\"headerlink\" title=\"action-state\"></a>action-state</h1><h2 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h2><p>该状态只执行操作，然后根据操作的结果转移到其他state。可以有多个操作，他们依次执行</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;moreAnswersNeeded&quot;&gt;</span><br><span class=\"line\">\t&lt;evaluate expression=&quot;interview.moreAnswersNeeded()&quot; /&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;yes&quot; to=&quot;answerQuestions&quot; /&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;no&quot; to=&quot;finish&quot; /&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>","more":"\n\n\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p>在action-state中调用普通java对象的方法，这些方法返回的只是一般的值，但是transition标签需要Event来触发，因此web-flow会将这个普通返回值转换为Event对象，具体转换情况如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法返回值类型\t\t\t映射出来的EventId</span><br><span class=\"line\">java.lang.String\t\t直接以字符串的值作为id</span><br><span class=\"line\">java.lang.Boolean\t\tyes (for true), no (for false)</span><br><span class=\"line\">java.lang.Enum\t\t\tthe Enum name</span><br><span class=\"line\">any other type\t    \tsuccess</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"action-state的操作\"><a href=\"#action-state的操作\" class=\"headerlink\" title=\"action-state的操作\"></a>action-state的操作</h2><p>action-state可以有三种方式进行执行操作</p>\n<ul>\n<li>调用POJO</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;evaluate expression=&quot;pojoAction.method(flowRequestContext)&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PojoAction &#123;</span><br><span class=\"line\">\tpublic String method(RequestContext context) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实现Action接口，直接调用该action</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;evaluate expression=&quot;customAction&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomAction implements Action &#123;</span><br><span class=\"line\">\tpublic Event execute(RequestContext context) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实现MultiAction接口，可以定义多个一连串的方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;evaluate expression=&quot;multiAction.actionMethod1&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomMultiAction extends MultiAction &#123;</span><br><span class=\"line\">\tpublic Event actionMethod1(RequestContext context) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Event actionMethod2(RequestContext context) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"action的异常处理\"><a href=\"#action的异常处理\" class=\"headerlink\" title=\"action的异常处理\"></a>action的异常处理</h2><ul>\n<li>POJO类action的处理方式<br>发生异常时，返回相应的字符串，会映射成Event，在transition中响应就可以了，和普通方法正常返回一样</li>\n<li>MultiAction的处理方式<br>发生异常时，返回Event对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookingAction extends MultiAction &#123;</span><br><span class=\"line\">\tpublic Event makeBooking(RequestContext context) &#123;</span><br><span class=\"line\">\t\t   try &#123;</span><br><span class=\"line\">\t\t\t   Booking booking = (Booking) context.getFlowScope().get(&quot;booking&quot;);</span><br><span class=\"line\">\t\t\t   BookingConfirmation confirmation = bookingService.make(booking);</span><br><span class=\"line\">\t\t\t   context.getFlowScope().put(&quot;confirmation&quot;, confirmation);</span><br><span class=\"line\">\t\t\t   return success();</span><br><span class=\"line\">\t\t   &#125; catch (RoomNotAvailableException e) &#123;</span><br><span class=\"line\">\t\t\t   context.getMessageContext().addMessage(new MessageBuilder().error().</span><br><span class=\"line\">\t\t\t\t   .defaultText(&quot;No room is available at this hotel&quot;).build());</span><br><span class=\"line\">\t\t\t   return error();</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<code>exception-handler</code>属性，定义异常处理器</li>\n</ul>\n<h2 id=\"decision-state\"><a href=\"#decision-state\" class=\"headerlink\" title=\"decision-state\"></a>decision-state</h2><p>decision-state是action-state的一种简单替代，在if/else情况时比较好用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;decision-state id=&quot;moreAnswersNeeded&quot;&gt;</span><br><span class=\"line\">\t&lt;if test=&quot;interview.moreAnswersNeeded()&quot; then=&quot;answerQuestions&quot; else=&quot;finish&quot; /&gt;</span><br><span class=\"line\">&lt;/decision-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"action相关标签\"><a href=\"#action相关标签\" class=\"headerlink\" title=\"action相关标签\"></a>action相关标签</h2><p>1) <code>&lt;on-start&gt;</code>    flow开始时执行<br>2) <code>&lt;on-entry&gt;</code>    state进入时执行<br>3) <code>&lt;on-exit&gt;</code>    state退出时执行<br>4) <code>&lt;on-end&gt;</code>    flow结束时执行<br>5) <code>&lt;on-render&gt;</code>view-state中使用，渲染前执行<br>6) <code>&lt;transition&gt;</code>    在转移前执行</p>\n<h2 id=\"命名的action\"><a href=\"#命名的action\" class=\"headerlink\" title=\"命名的action\"></a>命名的action</h2><p>如下展示了一个action-state下多个操作执行，为每个操作命名，第二个操作成功后进行转移操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;doTwoThings&quot;&gt;</span><br><span class=\"line\">\t&lt;evaluate expression=&quot;service.thingOne()&quot;&gt;</span><br><span class=\"line\">\t\t&lt;attribute name=&quot;name&quot; value=&quot;thingOne&quot; /&gt;</span><br><span class=\"line\">\t&lt;/evaluate&gt;</span><br><span class=\"line\">\t&lt;evaluate expression=&quot;service.thingTwo()&quot;&gt;</span><br><span class=\"line\">\t\t&lt;attribute name=&quot;name&quot; value=&quot;thingTwo&quot; /&gt;</span><br><span class=\"line\">\t&lt;/evaluate&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;thingTwo.success&quot; to=&quot;showResults&quot; /&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"向客户端发送流信息\"><a href=\"#向客户端发送流信息\" class=\"headerlink\" title=\"向客户端发送流信息\"></a>向客户端发送流信息</h1><h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>客户端请求一个图片文件，此时我们需要直接操作httpresponse进行图片的响应，而不是渲染view。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>通过ExternalContext获取HttpResponse，将图片写入，然后操作ExternalContext对象记录response完成，这样web-flow就不会再渲染view，而是直接返回给浏览器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PrintBoardingPassAction extends AbstractAction &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Event doExecute(RequestContext context) throws Exception &#123;</span><br><span class=\"line\">        HttpServletResponse response = (HttpServletResponse)context.getExternalContext().getNativeResponse();</span><br><span class=\"line\">        OutputStream os = response.getOutputStream();</span><br><span class=\"line\">        // 在这里操作os，写入流数据</span><br><span class=\"line\">        os.close();</span><br><span class=\"line\">        context.getExternalContext().recordResponseComplete();</span><br><span class=\"line\">        return success();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Spring Webflow - 基础","date":"2018-09-07T13:33:00.000Z","_content":"\n# 基础\n\n&emsp;&emsp;Web Flow将一个流程分为若干个状态(可以理解为步骤)，每个流程由若干个状态组成，通过特性的方式在步骤之间进行跳转，协同完成整个流程。\n&emsp;&emsp;常用标签如下\n\n - `<view-state>` - 视图状态，用于渲染视图\n - `<action-state>` - 动作状态，用于专门执行操作\n - `<transition>` - 转移，用于状态间转移，转移由事件触发\n - `<end-state>` - 结束状态，流程的最后一个状态\n - `<evaluate>` - 执行具体操作，是上述各个标签的子标签，用于所有需要执行操作的位置\n####view-state\n如下声明了视图状态，在该状态会绘制一个视图，view的解析依赖于具体的视图解析器\n\n```\n<view-state id=\"result\" view=\"flow/view/result\"/>\n```\n可以不指定view属性，此时，会在flow文件同目录下寻找和id相同文件名的视图文件进行渲染\n\n```\n<view-state id=\"enterBookingDetails\" />\n```\n可以在声明同时指定model属性，该属性配合前端spring taglib可将表单数据绑定到model指定的bean中\n\n```\n<view-state id=\"init\" view=\"flow/view/input\" model=\"searchForm\">\n    <binder>\n        <binding property=\"name\"/>\n        <binding property=\"gender\"/>\n    </binder>\n    <transition on=\"submit\" to=\"validate\"/>\n</view-state>\n...\n<!-- 对应的JSP代码 -->\n...\n<sf:form action=\"${flowExecutionUrl}&_eventId=submit\" commandName=\"searchForm\" method=\"post\">\n    Name: <sf:input path=\"name\"/><br/>\n    gender:\n       <sf:select path=\"gender\">\n           <sf:option value=\"\">- Please Select -</sf:option>\n       </sf:select>\n       <input type=\"submit\" value=\"Submit\">\n</sf:form>\n...\n```\n\n## action-state\naction-state将单独一个操作设置为一个状态，除了不能渲染视图外，其它功能和view-state基本一致\n\n```\n<action-state id=\"validate\">\n    <evaluate  expression=\"flowController.performValidate(searchForm)\"/>\n    <transition on=\"success\" to=\"result\"/>\n    <transition on=\"fail\" to=\"input\"/>\n</action-state>\n```\n\n## transition\ntransaction可以根据事件id从一个state跳转到另一个state，如下，当发生submit时间时，将跳转到id为reviewBooking的state\n\n```\n<view-state id=\"enterBookingDetails\">\n  \t\t<transition on=\"submit\" to=\"reviewBooking\" />\n</view-state>\n```\n事件id定义的方式比较特殊，最典型的从view中触发事件的方式：\n\n```\n<!-- 该超链接被点击时，会触发submit事件 -->\n<a href=\"${flowExecutionUrl}\"&_eventId=\"submit\">Submit</a>\n```\ntransition还可以作为<action-state>的子元素，此时on中的内容就是EL表达式，或者执行方法所返回的字符串\n\n```\n<action-state id=\"validate\">\n    <evaluate  expression=\"flowController.performValidate(searchForm)\" result=\"flashScope.resultMap\"/>\n    <!-- EL表达式方式,去resultMap对象中errors值得hasErrors()方法，成立时跳转 -->\n    <transition on=\"resultMap.errors.hasErrors() == true\" to=\"result\"/>\n</action-state>\n... ...\n<action-state id=\"validate\">\n    <evaluate  expression=\"flowController.performValidate(searchForm)\"/>\n    <!-- 方法返回事件id -->\n    <transition on=\"success\" to=\"result\"/>\n    <transition on=\"fail\" to=\"input\"/>\n</action-state>\n```\n\n## view中触发事件的几种方式\n\n - 使用submit按钮\n\n```\n<input type=\"submit\" name=\"_eventId_proceed\" value=\"Proceed\" />\n```\n&emsp;&emsp;原理：当web-flow发现请求参数中有以_eventId_字符串开头的参数时，会把该字符串中剩余字符串当做eventId。该方法可用于一次性触发多个事件\n\n - 使用hidden域\n\n```\n<input type=\"hidden\" name=\"_eventId\" value=\"proceed\" />\n```\n&emsp;&emsp;原理：web-flow检测到请求参数中有名为_eventId的参数时，会将其值作为eventId进行触发\n\n - 使用url参数\n\n```\n<a href=\"${flowExecutionUrl}&_eventId=cancel\">Cancel</a>\n```\n&emsp;&emsp;原理同上\n\n - web-flow检测eventId的逻辑\n首先检查有没有_eventId的参数，如果没有，检查有没有以_eventId_开头的参数名，都没有时，则没有事件会被触发。\n####end-tate\n&emsp;&emsp;定义流程结束状态\n\n - 当该流程是子流程时，会接着下面的流程继续进行，<end-state>的id属性将会作为event id\n - 当该流程添加了view时，该view会被渲染。还可以添加属性，使得进行重定向之类的\n - 当不是子流程也没有指定view，则该流程结束，并且重新开启一个新的流程实例\n####evaluate\nWeb Flow允许我们在如下几个切入点执行我们自己的业务逻辑，而执行业务逻辑使用`<evaluate>`标签。**该标签可以调用所用Spring中管理的bean和flow中声明的变量的方法**。\n\n - flow开始 - 对应`<on-start>`标签，定义在根标签`<flow>`下\n\n```\n<on-start>\n\t<!-- 仅调用方法 -->\n    <evaluate expression=\"flowController.performInit()\"/>\n</on-start>\n```\n\n - state进入时 - 对应`<on-entry>`标签，可定义在所有`state`标签下\n\n```\n<view-state id=\"init\" view=\"flow/view/input\">\n\t<on-entry>\n\t\t<!-- 调用方法，并将方法返回的对象存在flow变量modelMap中 -->\n\t\t<evaluate expression=\"flowController.performInit()\" result=\"flashScope.modelMap\"/>\n\t</on-entry>\n    ... ...\n</view-state>\n```\n\n - view渲染时 - 对应`<on-render>`标签，定义在`<view-state>`下\n\n```\n<view-state id=\"init\" view=\"flow/view/input\">\n\t<on-render>\n\t\t<!-- 调用方法，并将方法返回的对象转型成目标类型，然后存储在flow变量modelMap中 -->\n\t\t<evaluate expression=\"flowController.performInit()\" result=\"flashScope.modelMap\" resultType=\"java.util.Map\"/>\n\t</on-render>\n    ... ...\n</view-state>\n```\n\n - transition执行时 - 对应`<transition>`标签\n\n```\n<view-state id=\"init\" view=\"flow/view/input\">\n\t<transition on=\"submit\" to\"validate\">\n\t\t<evaluate expression=\"flowController.performTransition()\"/>\n\t</transition>\n</view-state>\n```\n\n - state退出时 - 对应`<on-entry>`标签，可定义在所有state标签下\n\n```\n<action-state id=\"validate\">\n    ... ...\n    <on-exit>\n\t\t<evaluate expression=\"flowController.performExit()\"/>\n\t</on-exit>\n</action-state>\n```\n\n - flow结束时 - 对应`<on-start>`标签，定义在根标签`<flow>`下\n\n```\n<on-end>\n    <evaluate expression=\"flowController.performEnd()\"/>\n</on-end>\n```\n# 进阶\n## 变量\n\n可以在流程中定义多个变量，这些变量将在流程开始被分配。被声明变量的类必须实现serializable，因为在两个state之间，变量需要被保存。\n\n```\n<var name=\"searchCriteria\" class=\"com.mycompany.myapp.hotels.search.SearchCriteria\"/>\n```\n####变量的分配方式\n - 直接分配\n\n```\n<var name=\"searchCriteria\" class=\"com.mycompany.myapp.hotels.search.SearchCriteria\"/>\n```\n\n - 赋值的时候分配\n\n```\n<!-- 创建InitMap对象，并将方法返回的对象赋值给InitMap -->\n<evaluate expression=\"flowController.performInit()\" result=\"flowScope.InitMap\" />\n```\n\n## 变量的使用方法\n\n - jsp中使用\n使用jsp中的el表达式访问flow中声明的变量，如`${modelMap.name}`，访问了flow变量modelMap的name属性\n - flow文件中使用\n直接使用Spring EL表达式进行访问\n\n```\n<transition on=\"modelMap.name == null\" to=\"result\"/>\n```\n\n - 方法中使用\n将变量传给调用方法，即可在方法中使用\n\n```\n<evaluate expression=\"flowController.performSearch(modelMap)\"/>\n```\n\n## 变量作用域\n - `flowScope`：流程开始时分配，流程结束时销毁\n - `viewScope`：在`<view-state>`进入时创建，退出时销毁\n - `requestScope`：当流程被调用时分配，流程返回时销毁。比flowScope作用域稍微大一点\n - `flashScope`：在流程开始时分配，流程结束时销毁，但是在每一个view渲染后都会被清零\n - `conversation Scope`：最顶层的流程开始时分配，最顶层的流程结束时销毁。该作用域的变量是存储在Session中的。","source":"_posts/Spring Webflow - 基础.md","raw":"---\ntitle: Spring Webflow - 基础\ndate: 2018-09-07 21:33:00\ntags: \n    - Spring\n    - Webflow\ncategories: \n    - Spring Webflow\n---\n\n# 基础\n\n&emsp;&emsp;Web Flow将一个流程分为若干个状态(可以理解为步骤)，每个流程由若干个状态组成，通过特性的方式在步骤之间进行跳转，协同完成整个流程。\n&emsp;&emsp;常用标签如下\n\n - `<view-state>` - 视图状态，用于渲染视图\n - `<action-state>` - 动作状态，用于专门执行操作\n - `<transition>` - 转移，用于状态间转移，转移由事件触发\n - `<end-state>` - 结束状态，流程的最后一个状态\n - `<evaluate>` - 执行具体操作，是上述各个标签的子标签，用于所有需要执行操作的位置\n####view-state\n如下声明了视图状态，在该状态会绘制一个视图，view的解析依赖于具体的视图解析器\n\n```\n<view-state id=\"result\" view=\"flow/view/result\"/>\n```\n可以不指定view属性，此时，会在flow文件同目录下寻找和id相同文件名的视图文件进行渲染\n\n```\n<view-state id=\"enterBookingDetails\" />\n```\n可以在声明同时指定model属性，该属性配合前端spring taglib可将表单数据绑定到model指定的bean中\n\n```\n<view-state id=\"init\" view=\"flow/view/input\" model=\"searchForm\">\n    <binder>\n        <binding property=\"name\"/>\n        <binding property=\"gender\"/>\n    </binder>\n    <transition on=\"submit\" to=\"validate\"/>\n</view-state>\n...\n<!-- 对应的JSP代码 -->\n...\n<sf:form action=\"${flowExecutionUrl}&_eventId=submit\" commandName=\"searchForm\" method=\"post\">\n    Name: <sf:input path=\"name\"/><br/>\n    gender:\n       <sf:select path=\"gender\">\n           <sf:option value=\"\">- Please Select -</sf:option>\n       </sf:select>\n       <input type=\"submit\" value=\"Submit\">\n</sf:form>\n...\n```\n\n## action-state\naction-state将单独一个操作设置为一个状态，除了不能渲染视图外，其它功能和view-state基本一致\n\n```\n<action-state id=\"validate\">\n    <evaluate  expression=\"flowController.performValidate(searchForm)\"/>\n    <transition on=\"success\" to=\"result\"/>\n    <transition on=\"fail\" to=\"input\"/>\n</action-state>\n```\n\n## transition\ntransaction可以根据事件id从一个state跳转到另一个state，如下，当发生submit时间时，将跳转到id为reviewBooking的state\n\n```\n<view-state id=\"enterBookingDetails\">\n  \t\t<transition on=\"submit\" to=\"reviewBooking\" />\n</view-state>\n```\n事件id定义的方式比较特殊，最典型的从view中触发事件的方式：\n\n```\n<!-- 该超链接被点击时，会触发submit事件 -->\n<a href=\"${flowExecutionUrl}\"&_eventId=\"submit\">Submit</a>\n```\ntransition还可以作为<action-state>的子元素，此时on中的内容就是EL表达式，或者执行方法所返回的字符串\n\n```\n<action-state id=\"validate\">\n    <evaluate  expression=\"flowController.performValidate(searchForm)\" result=\"flashScope.resultMap\"/>\n    <!-- EL表达式方式,去resultMap对象中errors值得hasErrors()方法，成立时跳转 -->\n    <transition on=\"resultMap.errors.hasErrors() == true\" to=\"result\"/>\n</action-state>\n... ...\n<action-state id=\"validate\">\n    <evaluate  expression=\"flowController.performValidate(searchForm)\"/>\n    <!-- 方法返回事件id -->\n    <transition on=\"success\" to=\"result\"/>\n    <transition on=\"fail\" to=\"input\"/>\n</action-state>\n```\n\n## view中触发事件的几种方式\n\n - 使用submit按钮\n\n```\n<input type=\"submit\" name=\"_eventId_proceed\" value=\"Proceed\" />\n```\n&emsp;&emsp;原理：当web-flow发现请求参数中有以_eventId_字符串开头的参数时，会把该字符串中剩余字符串当做eventId。该方法可用于一次性触发多个事件\n\n - 使用hidden域\n\n```\n<input type=\"hidden\" name=\"_eventId\" value=\"proceed\" />\n```\n&emsp;&emsp;原理：web-flow检测到请求参数中有名为_eventId的参数时，会将其值作为eventId进行触发\n\n - 使用url参数\n\n```\n<a href=\"${flowExecutionUrl}&_eventId=cancel\">Cancel</a>\n```\n&emsp;&emsp;原理同上\n\n - web-flow检测eventId的逻辑\n首先检查有没有_eventId的参数，如果没有，检查有没有以_eventId_开头的参数名，都没有时，则没有事件会被触发。\n####end-tate\n&emsp;&emsp;定义流程结束状态\n\n - 当该流程是子流程时，会接着下面的流程继续进行，<end-state>的id属性将会作为event id\n - 当该流程添加了view时，该view会被渲染。还可以添加属性，使得进行重定向之类的\n - 当不是子流程也没有指定view，则该流程结束，并且重新开启一个新的流程实例\n####evaluate\nWeb Flow允许我们在如下几个切入点执行我们自己的业务逻辑，而执行业务逻辑使用`<evaluate>`标签。**该标签可以调用所用Spring中管理的bean和flow中声明的变量的方法**。\n\n - flow开始 - 对应`<on-start>`标签，定义在根标签`<flow>`下\n\n```\n<on-start>\n\t<!-- 仅调用方法 -->\n    <evaluate expression=\"flowController.performInit()\"/>\n</on-start>\n```\n\n - state进入时 - 对应`<on-entry>`标签，可定义在所有`state`标签下\n\n```\n<view-state id=\"init\" view=\"flow/view/input\">\n\t<on-entry>\n\t\t<!-- 调用方法，并将方法返回的对象存在flow变量modelMap中 -->\n\t\t<evaluate expression=\"flowController.performInit()\" result=\"flashScope.modelMap\"/>\n\t</on-entry>\n    ... ...\n</view-state>\n```\n\n - view渲染时 - 对应`<on-render>`标签，定义在`<view-state>`下\n\n```\n<view-state id=\"init\" view=\"flow/view/input\">\n\t<on-render>\n\t\t<!-- 调用方法，并将方法返回的对象转型成目标类型，然后存储在flow变量modelMap中 -->\n\t\t<evaluate expression=\"flowController.performInit()\" result=\"flashScope.modelMap\" resultType=\"java.util.Map\"/>\n\t</on-render>\n    ... ...\n</view-state>\n```\n\n - transition执行时 - 对应`<transition>`标签\n\n```\n<view-state id=\"init\" view=\"flow/view/input\">\n\t<transition on=\"submit\" to\"validate\">\n\t\t<evaluate expression=\"flowController.performTransition()\"/>\n\t</transition>\n</view-state>\n```\n\n - state退出时 - 对应`<on-entry>`标签，可定义在所有state标签下\n\n```\n<action-state id=\"validate\">\n    ... ...\n    <on-exit>\n\t\t<evaluate expression=\"flowController.performExit()\"/>\n\t</on-exit>\n</action-state>\n```\n\n - flow结束时 - 对应`<on-start>`标签，定义在根标签`<flow>`下\n\n```\n<on-end>\n    <evaluate expression=\"flowController.performEnd()\"/>\n</on-end>\n```\n# 进阶\n## 变量\n\n可以在流程中定义多个变量，这些变量将在流程开始被分配。被声明变量的类必须实现serializable，因为在两个state之间，变量需要被保存。\n\n```\n<var name=\"searchCriteria\" class=\"com.mycompany.myapp.hotels.search.SearchCriteria\"/>\n```\n####变量的分配方式\n - 直接分配\n\n```\n<var name=\"searchCriteria\" class=\"com.mycompany.myapp.hotels.search.SearchCriteria\"/>\n```\n\n - 赋值的时候分配\n\n```\n<!-- 创建InitMap对象，并将方法返回的对象赋值给InitMap -->\n<evaluate expression=\"flowController.performInit()\" result=\"flowScope.InitMap\" />\n```\n\n## 变量的使用方法\n\n - jsp中使用\n使用jsp中的el表达式访问flow中声明的变量，如`${modelMap.name}`，访问了flow变量modelMap的name属性\n - flow文件中使用\n直接使用Spring EL表达式进行访问\n\n```\n<transition on=\"modelMap.name == null\" to=\"result\"/>\n```\n\n - 方法中使用\n将变量传给调用方法，即可在方法中使用\n\n```\n<evaluate expression=\"flowController.performSearch(modelMap)\"/>\n```\n\n## 变量作用域\n - `flowScope`：流程开始时分配，流程结束时销毁\n - `viewScope`：在`<view-state>`进入时创建，退出时销毁\n - `requestScope`：当流程被调用时分配，流程返回时销毁。比flowScope作用域稍微大一点\n - `flashScope`：在流程开始时分配，流程结束时销毁，但是在每一个view渲染后都会被清零\n - `conversation Scope`：最顶层的流程开始时分配，最顶层的流程结束时销毁。该作用域的变量是存储在Session中的。","slug":"Spring Webflow - 基础","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo99000d00bn9cgxam4d","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><p>&emsp;&emsp;Web Flow将一个流程分为若干个状态(可以理解为步骤)，每个流程由若干个状态组成，通过特性的方式在步骤之间进行跳转，协同完成整个流程。<br>&emsp;&emsp;常用标签如下</p><ul>\n<li><code>&lt;view-state&gt;</code> - 视图状态，用于渲染视图</li>\n<li><code>&lt;action-state&gt;</code> - 动作状态，用于专门执行操作</li>\n<li><code>&lt;transition&gt;</code> - 转移，用于状态间转移，转移由事件触发</li>\n<li><code>&lt;end-state&gt;</code> - 结束状态，流程的最后一个状态</li>\n<li><code>&lt;evaluate&gt;</code> - 执行具体操作，是上述各个标签的子标签，用于所有需要执行操作的位置<br>####view-state<br>如下声明了视图状态，在该状态会绘制一个视图，view的解析依赖于具体的视图解析器</li>\n</ul><a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;result&quot; view=&quot;flow/view/result&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以不指定view属性，此时，会在flow文件同目录下寻找和id相同文件名的视图文件进行渲染</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以在声明同时指定model属性，该属性配合前端spring taglib可将表单数据绑定到model指定的bean中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot; model=&quot;searchForm&quot;&gt;</span><br><span class=\"line\">    &lt;binder&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;name&quot;/&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;gender&quot;/&gt;</span><br><span class=\"line\">    &lt;/binder&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;submit&quot; to=&quot;validate&quot;/&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;!-- 对应的JSP代码 --&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">    Name: &lt;sf:input path=&quot;name&quot;/&gt;&lt;br/&gt;</span><br><span class=\"line\">    gender:</span><br><span class=\"line\">       &lt;sf:select path=&quot;gender&quot;&gt;</span><br><span class=\"line\">           &lt;sf:option value=&quot;&quot;&gt;- Please Select -&lt;/sf:option&gt;</span><br><span class=\"line\">       &lt;/sf:select&gt;</span><br><span class=\"line\">       &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class=\"line\">&lt;/sf:form&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"action-state\"><a href=\"#action-state\" class=\"headerlink\" title=\"action-state\"></a>action-state</h2><p>action-state将单独一个操作设置为一个状态，除了不能渲染视图外，其它功能和view-state基本一致</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h2><p>transaction可以根据事件id从一个state跳转到另一个state，如下，当发生submit时间时，将跳转到id为reviewBooking的state</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot;&gt;</span><br><span class=\"line\">  \t\t&lt;transition on=&quot;submit&quot; to=&quot;reviewBooking&quot; /&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<p>事件id定义的方式比较特殊，最典型的从view中触发事件的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 该超链接被点击时，会触发submit事件 --&gt;</span><br><span class=\"line\">&lt;a href=&quot;$&#123;flowExecutionUrl&#125;&quot;&amp;_eventId=&quot;submit&quot;&gt;Submit&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>transition还可以作为<action-state>的子元素，此时on中的内容就是EL表达式，或者执行方法所返回的字符串</action-state></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot; result=&quot;flashScope.resultMap&quot;/&gt;</span><br><span class=\"line\">    &lt;!-- EL表达式方式,去resultMap对象中errors值得hasErrors()方法，成立时跳转 --&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;resultMap.errors.hasErrors() == true&quot; to=&quot;result&quot;/&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br><span class=\"line\">... ...</span><br><span class=\"line\">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class=\"line\">    &lt;!-- 方法返回事件id --&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"view中触发事件的几种方式\"><a href=\"#view中触发事件的几种方式\" class=\"headerlink\" title=\"view中触发事件的几种方式\"></a>view中触发事件的几种方式</h2><ul>\n<li>使用submit按钮</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;submit&quot; name=&quot;_eventId_proceed&quot; value=&quot;Proceed&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;原理：当web-flow发现请求参数中有以_eventId_字符串开头的参数时，会把该字符串中剩余字符串当做eventId。该方法可用于一次性触发多个事件</p>\n<ul>\n<li>使用hidden域</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;hidden&quot; name=&quot;_eventId&quot; value=&quot;proceed&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;原理：web-flow检测到请求参数中有名为_eventId的参数时，会将其值作为eventId进行触发</p>\n<ul>\n<li>使用url参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=cancel&quot;&gt;Cancel&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;原理同上</p>\n<ul>\n<li><p>web-flow检测eventId的逻辑<br>首先检查有没有_eventId的参数，如果没有，检查有没有以_eventId_开头的参数名，都没有时，则没有事件会被触发。<br>####end-tate<br>&emsp;&emsp;定义流程结束状态</p>\n</li>\n<li><p>当该流程是子流程时，会接着下面的流程继续进行，<end-state>的id属性将会作为event id</end-state></p>\n</li>\n<li><p>当该流程添加了view时，该view会被渲染。还可以添加属性，使得进行重定向之类的</p>\n</li>\n<li><p>当不是子流程也没有指定view，则该流程结束，并且重新开启一个新的流程实例<br>####evaluate<br>Web Flow允许我们在如下几个切入点执行我们自己的业务逻辑，而执行业务逻辑使用<code>&lt;evaluate&gt;</code>标签。<strong>该标签可以调用所用Spring中管理的bean和flow中声明的变量的方法</strong>。</p>\n</li>\n<li><p>flow开始 - 对应<code>&lt;on-start&gt;</code>标签，定义在根标签<code>&lt;flow&gt;</code>下</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;on-start&gt;</span><br><span class=\"line\">\t&lt;!-- 仅调用方法 --&gt;</span><br><span class=\"line\">    &lt;evaluate expression=&quot;flowController.performInit()&quot;/&gt;</span><br><span class=\"line\">&lt;/on-start&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>state进入时 - 对应<code>&lt;on-entry&gt;</code>标签，可定义在所有<code>state</code>标签下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class=\"line\">\t&lt;on-entry&gt;</span><br><span class=\"line\">\t\t&lt;!-- 调用方法，并将方法返回的对象存在flow变量modelMap中 --&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class=\"line\">\t&lt;/on-entry&gt;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>view渲染时 - 对应<code>&lt;on-render&gt;</code>标签，定义在<code>&lt;view-state&gt;</code>下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class=\"line\">\t&lt;on-render&gt;</span><br><span class=\"line\">\t\t&lt;!-- 调用方法，并将方法返回的对象转型成目标类型，然后存储在flow变量modelMap中 --&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flashScope.modelMap&quot; resultType=&quot;java.util.Map&quot;/&gt;</span><br><span class=\"line\">\t&lt;/on-render&gt;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>transition执行时 - 对应<code>&lt;transition&gt;</code>标签</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;submit&quot; to&quot;validate&quot;&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;flowController.performTransition()&quot;/&gt;</span><br><span class=\"line\">\t&lt;/transition&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>state退出时 - 对应<code>&lt;on-entry&gt;</code>标签，可定义在所有state标签下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">    &lt;on-exit&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;flowController.performExit()&quot;/&gt;</span><br><span class=\"line\">\t&lt;/on-exit&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>flow结束时 - 对应<code>&lt;on-start&gt;</code>标签，定义在根标签<code>&lt;flow&gt;</code>下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;on-end&gt;</span><br><span class=\"line\">    &lt;evaluate expression=&quot;flowController.performEnd()&quot;/&gt;</span><br><span class=\"line\">&lt;/on-end&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h1><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>可以在流程中定义多个变量，这些变量将在流程开始被分配。被声明变量的类必须实现serializable，因为在两个state之间，变量需要被保存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.search.SearchCriteria&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>####变量的分配方式</p>\n<ul>\n<li>直接分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.search.SearchCriteria&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>赋值的时候分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 创建InitMap对象，并将方法返回的对象赋值给InitMap --&gt;</span><br><span class=\"line\">&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flowScope.InitMap&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量的使用方法\"><a href=\"#变量的使用方法\" class=\"headerlink\" title=\"变量的使用方法\"></a>变量的使用方法</h2><ul>\n<li>jsp中使用<br>使用jsp中的el表达式访问flow中声明的变量，如<code>${modelMap.name}</code>，访问了flow变量modelMap的name属性</li>\n<li>flow文件中使用<br>直接使用Spring EL表达式进行访问</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;modelMap.name == null&quot; to=&quot;result&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法中使用<br>将变量传给调用方法，即可在方法中使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;evaluate expression=&quot;flowController.performSearch(modelMap)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><ul>\n<li><code>flowScope</code>：流程开始时分配，流程结束时销毁</li>\n<li><code>viewScope</code>：在<code>&lt;view-state&gt;</code>进入时创建，退出时销毁</li>\n<li><code>requestScope</code>：当流程被调用时分配，流程返回时销毁。比flowScope作用域稍微大一点</li>\n<li><code>flashScope</code>：在流程开始时分配，流程结束时销毁，但是在每一个view渲染后都会被清零</li>\n<li><code>conversation Scope</code>：最顶层的流程开始时分配，最顶层的流程结束时销毁。该作用域的变量是存储在Session中的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><p>&emsp;&emsp;Web Flow将一个流程分为若干个状态(可以理解为步骤)，每个流程由若干个状态组成，通过特性的方式在步骤之间进行跳转，协同完成整个流程。<br>&emsp;&emsp;常用标签如下</p><ul>\n<li><code>&lt;view-state&gt;</code> - 视图状态，用于渲染视图</li>\n<li><code>&lt;action-state&gt;</code> - 动作状态，用于专门执行操作</li>\n<li><code>&lt;transition&gt;</code> - 转移，用于状态间转移，转移由事件触发</li>\n<li><code>&lt;end-state&gt;</code> - 结束状态，流程的最后一个状态</li>\n<li><code>&lt;evaluate&gt;</code> - 执行具体操作，是上述各个标签的子标签，用于所有需要执行操作的位置<br>####view-state<br>如下声明了视图状态，在该状态会绘制一个视图，view的解析依赖于具体的视图解析器</li>\n</ul>","more":"\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;result&quot; view=&quot;flow/view/result&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以不指定view属性，此时，会在flow文件同目录下寻找和id相同文件名的视图文件进行渲染</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以在声明同时指定model属性，该属性配合前端spring taglib可将表单数据绑定到model指定的bean中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot; model=&quot;searchForm&quot;&gt;</span><br><span class=\"line\">    &lt;binder&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;name&quot;/&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;gender&quot;/&gt;</span><br><span class=\"line\">    &lt;/binder&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;submit&quot; to=&quot;validate&quot;/&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;!-- 对应的JSP代码 --&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">    Name: &lt;sf:input path=&quot;name&quot;/&gt;&lt;br/&gt;</span><br><span class=\"line\">    gender:</span><br><span class=\"line\">       &lt;sf:select path=&quot;gender&quot;&gt;</span><br><span class=\"line\">           &lt;sf:option value=&quot;&quot;&gt;- Please Select -&lt;/sf:option&gt;</span><br><span class=\"line\">       &lt;/sf:select&gt;</span><br><span class=\"line\">       &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class=\"line\">&lt;/sf:form&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"action-state\"><a href=\"#action-state\" class=\"headerlink\" title=\"action-state\"></a>action-state</h2><p>action-state将单独一个操作设置为一个状态，除了不能渲染视图外，其它功能和view-state基本一致</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h2><p>transaction可以根据事件id从一个state跳转到另一个state，如下，当发生submit时间时，将跳转到id为reviewBooking的state</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot;&gt;</span><br><span class=\"line\">  \t\t&lt;transition on=&quot;submit&quot; to=&quot;reviewBooking&quot; /&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<p>事件id定义的方式比较特殊，最典型的从view中触发事件的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 该超链接被点击时，会触发submit事件 --&gt;</span><br><span class=\"line\">&lt;a href=&quot;$&#123;flowExecutionUrl&#125;&quot;&amp;_eventId=&quot;submit&quot;&gt;Submit&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>transition还可以作为<action-state>的子元素，此时on中的内容就是EL表达式，或者执行方法所返回的字符串</action-state></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot; result=&quot;flashScope.resultMap&quot;/&gt;</span><br><span class=\"line\">    &lt;!-- EL表达式方式,去resultMap对象中errors值得hasErrors()方法，成立时跳转 --&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;resultMap.errors.hasErrors() == true&quot; to=&quot;result&quot;/&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br><span class=\"line\">... ...</span><br><span class=\"line\">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class=\"line\">    &lt;!-- 方法返回事件id --&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"view中触发事件的几种方式\"><a href=\"#view中触发事件的几种方式\" class=\"headerlink\" title=\"view中触发事件的几种方式\"></a>view中触发事件的几种方式</h2><ul>\n<li>使用submit按钮</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;submit&quot; name=&quot;_eventId_proceed&quot; value=&quot;Proceed&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;原理：当web-flow发现请求参数中有以_eventId_字符串开头的参数时，会把该字符串中剩余字符串当做eventId。该方法可用于一次性触发多个事件</p>\n<ul>\n<li>使用hidden域</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;hidden&quot; name=&quot;_eventId&quot; value=&quot;proceed&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;原理：web-flow检测到请求参数中有名为_eventId的参数时，会将其值作为eventId进行触发</p>\n<ul>\n<li>使用url参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=cancel&quot;&gt;Cancel&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;原理同上</p>\n<ul>\n<li><p>web-flow检测eventId的逻辑<br>首先检查有没有_eventId的参数，如果没有，检查有没有以_eventId_开头的参数名，都没有时，则没有事件会被触发。<br>####end-tate<br>&emsp;&emsp;定义流程结束状态</p>\n</li>\n<li><p>当该流程是子流程时，会接着下面的流程继续进行，<end-state>的id属性将会作为event id</end-state></p>\n</li>\n<li><p>当该流程添加了view时，该view会被渲染。还可以添加属性，使得进行重定向之类的</p>\n</li>\n<li><p>当不是子流程也没有指定view，则该流程结束，并且重新开启一个新的流程实例<br>####evaluate<br>Web Flow允许我们在如下几个切入点执行我们自己的业务逻辑，而执行业务逻辑使用<code>&lt;evaluate&gt;</code>标签。<strong>该标签可以调用所用Spring中管理的bean和flow中声明的变量的方法</strong>。</p>\n</li>\n<li><p>flow开始 - 对应<code>&lt;on-start&gt;</code>标签，定义在根标签<code>&lt;flow&gt;</code>下</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;on-start&gt;</span><br><span class=\"line\">\t&lt;!-- 仅调用方法 --&gt;</span><br><span class=\"line\">    &lt;evaluate expression=&quot;flowController.performInit()&quot;/&gt;</span><br><span class=\"line\">&lt;/on-start&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>state进入时 - 对应<code>&lt;on-entry&gt;</code>标签，可定义在所有<code>state</code>标签下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class=\"line\">\t&lt;on-entry&gt;</span><br><span class=\"line\">\t\t&lt;!-- 调用方法，并将方法返回的对象存在flow变量modelMap中 --&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class=\"line\">\t&lt;/on-entry&gt;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>view渲染时 - 对应<code>&lt;on-render&gt;</code>标签，定义在<code>&lt;view-state&gt;</code>下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class=\"line\">\t&lt;on-render&gt;</span><br><span class=\"line\">\t\t&lt;!-- 调用方法，并将方法返回的对象转型成目标类型，然后存储在flow变量modelMap中 --&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flashScope.modelMap&quot; resultType=&quot;java.util.Map&quot;/&gt;</span><br><span class=\"line\">\t&lt;/on-render&gt;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>transition执行时 - 对应<code>&lt;transition&gt;</code>标签</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot;&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;submit&quot; to&quot;validate&quot;&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;flowController.performTransition()&quot;/&gt;</span><br><span class=\"line\">\t&lt;/transition&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>state退出时 - 对应<code>&lt;on-entry&gt;</code>标签，可定义在所有state标签下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">    &lt;on-exit&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;flowController.performExit()&quot;/&gt;</span><br><span class=\"line\">\t&lt;/on-exit&gt;</span><br><span class=\"line\">&lt;/action-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>flow结束时 - 对应<code>&lt;on-start&gt;</code>标签，定义在根标签<code>&lt;flow&gt;</code>下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;on-end&gt;</span><br><span class=\"line\">    &lt;evaluate expression=&quot;flowController.performEnd()&quot;/&gt;</span><br><span class=\"line\">&lt;/on-end&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h1><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>可以在流程中定义多个变量，这些变量将在流程开始被分配。被声明变量的类必须实现serializable，因为在两个state之间，变量需要被保存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.search.SearchCriteria&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>####变量的分配方式</p>\n<ul>\n<li>直接分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.search.SearchCriteria&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>赋值的时候分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 创建InitMap对象，并将方法返回的对象赋值给InitMap --&gt;</span><br><span class=\"line\">&lt;evaluate expression=&quot;flowController.performInit()&quot; result=&quot;flowScope.InitMap&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量的使用方法\"><a href=\"#变量的使用方法\" class=\"headerlink\" title=\"变量的使用方法\"></a>变量的使用方法</h2><ul>\n<li>jsp中使用<br>使用jsp中的el表达式访问flow中声明的变量，如<code>${modelMap.name}</code>，访问了flow变量modelMap的name属性</li>\n<li>flow文件中使用<br>直接使用Spring EL表达式进行访问</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;modelMap.name == null&quot; to=&quot;result&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法中使用<br>将变量传给调用方法，即可在方法中使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;evaluate expression=&quot;flowController.performSearch(modelMap)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><ul>\n<li><code>flowScope</code>：流程开始时分配，流程结束时销毁</li>\n<li><code>viewScope</code>：在<code>&lt;view-state&gt;</code>进入时创建，退出时销毁</li>\n<li><code>requestScope</code>：当流程被调用时分配，流程返回时销毁。比flowScope作用域稍微大一点</li>\n<li><code>flashScope</code>：在流程开始时分配，流程结束时销毁，但是在每一个view渲染后都会被清零</li>\n<li><code>conversation Scope</code>：最顶层的流程开始时分配，最顶层的流程结束时销毁。该作用域的变量是存储在Session中的。</li>\n</ul>\n"},{"title":"Spring Webflow - 配置","date":"2018-09-05T14:33:00.000Z","_content":">  1. 本文基于Spring Web Flow 2.4.5，其它版本配置方式可能略有不同，请参考相应版本的[官方文档](https://projects.spring.io/spring-webflow/)\n>  2. Maven依赖\nmaven库查询推荐地址：http://mvnrepository.com/\n```\n<dependency>\n    <groupId>org.springframework.webflow</groupId>\n    <artifactId>spring-webflow</artifactId>\n    <version>2.4.5.RELEASE</version>\n</dependency>\n```\n# Web Flow嵌入到Spring MVC工作流简介\n请求被DispatcherServlet拦截 -> 分发flow进行处理，返回view -> viewResolver解析 -> 返回请求\n\n---\n# 配置项预览\n<ul>\n\t<li>FlowRegistry：必须，注册流程，指明流程配置文件所在位置；指定流程id(用于请求访问标识)；指定流程属性；此外还可以传入FlowBuilderServices进行更多个性化配置</li>\n\t<li>FlowBuilderServices：必须，用于设定流程配置文件中EL表达式的解析器、form属性绑定时的转换器、view-state的view解析器等，很重要</li>\n\t<li>FlowExecutor：必须，用于执行流程，可指定执行监听器(可选，常用于流程安全和持久化)</li>\n\t<li>FlowHandlerAdapter：必须，用于适配Spring MVC，配置时传入FlowExecutor</li>\n\t<li>FlowHandlerMapping：必须，用于将请求映射到对应的flow，配置时传入FlowRegistry</li>\n</ul>\n\n---\n# 配置I - 注册流程 - FlowRegistry\nFlowRegistry用于注册流程实例，指定流程位置和流程id，并可自定义流程创建相关内容\n\n## 注册flow的各种方式\n\n- 直接指定流程位置\n默认情况下，web-flow的id为其文件名减去后缀名，如下配置的id为booking。指定了基地址或使用了通配符时除外。\n```\n<webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" />\n// 注册了一个路径为/WEB-INF/flows/booking/booking.xml的流程，其余为默认配置。\n```\n- 自定义id\n\n```\n<webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" id=\"bookHotel\" />\n```\n\n-  定义流程属性\n如下定义了一个带有属性caption，其值为\"Books a hotel\"的流程。属性的使用方法暂时不了解\n```\n<webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\">\n    <webflow:flow-definition-attributes>\n        <webflow:attribute name=\"caption\" value=\"Books a hotel\" />\n    </webflow:flow-definition-attributes>\n</webflow:flow-location>\n```\n\n - 使用通配定义流程位置\n**使用该方法并没有正确实验出id**，这点作为参考\n```\n<webflow:flow-location-pattern value=\"/WEB-INF/flows/**/*-flow.xml\" />\n```\n\n- 使用基地址\n使用基地址的flow的id为其path属性减去文件名，如下配置的id为/hotels/booking；如果path中没有路径信息，只有文件名，则id为文件名减去后缀。\n```\n<webflow:flow-registry id=\"flowRegistry\" base-path=\"/WEB-INF\">\n    <webflow:flow-location path=\"/hotels/booking/booking.xml\" />\n</webflow:flow-registry>\n```\n## flow id属性总结\n1.  id的作用\nid用于请求定位到某个确切的flow，如当请求路径为http://localhost:8090/Floyd/search-flow，其中Floyd是项目名，如果有id为search-flow的flow存在，则会访问该flow\n2. id的定义\n - 没有基地址或通配符时，flow的id为文件名减去后缀，如`<webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" />`这里的id为booking\n - 有基地址时，id为path的值减去文件名，如基地址为`/WEB-INF`， path=`/flows/booking/booking.xml`时，id被确定为`flows/booking`\n - 有通配符时，该情况比较特殊，按照[官方说明](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#flow-registry-base-path)并没有验证通过，这里略过。\n当显式指定了id属性时，则使用指定的id。<b>推荐自定义id</b>\n## FlowRegistry继承\nFlowRegistry是可以继承的，可以定义一个公用的注册器，在多个子注册器中继承该注册器\n\n```\n<!-- my-system-config.xml -->\n<webflow:flow-registry id=\"flowRegistry\" parent=\"sharedFlowRegistry\">\n    <webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" />\n</webflow:flow-registry>\n\n<!-- shared-config.xml -->\n<webflow:flow-registry id=\"sharedFlowRegistry\">\n    <!-- Global flows shared by several applications -->\n</webflow:flow-registry>\n```\n\n---\n# 配置II - 使用FlowBuilder services\n使用FlowBuilder Services可以在build流程时自定义服务，比如视图解析器、EL表达式解析器、类型格式化和转换服务等。如无显式设定FlowBuilder Services，系统将使用默认实现。\n\n```\n<webflow:flow-registry id=\"flowRegistry\" flow-builder-services=\"flowBuilderServices\">\n    <webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" />\n</webflow:flow-registry>\n\n<webflow:flow-builder-services id=\"flowBuilderServices\"\n    conversion-service=\"conversionService\"\n    expression-parser=\"expressionParser\"\n    view-factory-creator=\"viewFactoryCreator\" />\n\n<bean id=\"conversionService\" class=\"...\" />\n<bean id=\"expressionParser\" class=\"...\" />\n<bean id=\"viewFactoryCreator\" class=\"...\" />\n```\n## 自定义视图解析器 view-factory-creator\nview-factory-creator用于视图解析工作，默认的creator可以支持Spring MVC支持的几种视图类型：JSP, Velocity，FreeMarker等。\n```\n<webflow:flow-registry id=\"flowRegistry\" flow-builder-services=\"flowBuilderServices\">\n\t<webflow:location path=\"/WEB-INF/hotels/booking/booking.xml\" />\n</webflow:flow-registry>\n\n<!-- 尤其注意这里的development，设置为true时表示开启开发模式，该模式下会在flow定义改变时自动re-load，甚至flow中引用的resource bundle发生了变化都会热重载 -->\n<webflow:flow-builder-services id=\"flowBuilderServices\" view-factory-creator=\"mvcViewFactoryCreator\" development=\"true\"/>\n\n<bean id=\"mvcViewFactoryCreator\" class=\"org.springframework.webflow.mvc.builder.MvcViewFactoryCreator\">\n\t<!-- myExistingViewResolverToUseForFlows就是我们常用的视图解析器，注意这里引用的是一个列表 -->\n\t<property name=\"viewResolvers\" ref=\"myExistingViewResolverToUseForFlows\"/>\n</bean>\n\n... ... \n... ...\n<!-- 做验证时使用的是javaconfig的形式，这种形式并没有验证过 -->\n<property name=\"myExistingViewResolverToUseForFlows\">\n    <list>\n        <ref bean=\"viewResolver\" />\n    </list>\n</property>\n\n<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n   <property name=\"prefix\" value=\"/WEB-INF/\"/>\n   <property name=\"suffix\" value=\".jsp\"/>\n</bean>\n\n```\n\n## 自定义表达式解析器 expression-parser\nexpression-parser用于定义表达式解析器，默认的解析器使用逻辑：当类路径下有Unified EL解析器时，则使用；没有时，则使用OGNL表达式解析器(官方文档在[EL表达式](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-unified-el)一章和[系统设置](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#builder-service-expression-parser)一章关于默认表达式解析说法有出入，自己认为比较可信的是Spring Web Flow 2.1以后，默认使用Spring EL表达式解析器)。\n下面是手动配置成Unified EL解析器的方式：\n\n```\n<webflow:flow-builder-services expression-parser=\"expressionParser\"/>\n\n<bean id=\"expressionParser\" class=\"org.springframework.webflow.expression.el.WebFlowELExpressionParser\">\n    <constructor-arg>\n        <bean class=\"org.jboss.el.ExpressionFactoryImpl\" />\n    </constructor-arg>\n</bean>\n```\n\n## 自定义类型转换器 conversion-service\n 详细内容参见本系列视图渲染相关章节或[官方文档](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration)\n\n```\n<webflow:flow-registry id=\"flowRegistry\" flow-builder-services=\"flowBuilderServices\" ... />\n\n<webflow:flow-builder-services id=\"flowBuilderServices\" conversion-service=\"defaultConversionService\" ... />\n\n<bean id=\"defaultConversionService\" class=\"org.springframework.binding.convert.service.DefaultConversionService\">\n\t<constructor-arg ref=\"applicationConversionSevice\"/>\n</bean>\n\n<bean id=\"applicationConversionService\" class=\"somepackage.ApplicationConversionServiceFactoryBean\">\n```\n\n```\npublic class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean {\n    @Override\n    protected void installFormatters(FormatterRegistry registry) {\n        // ...\n    }\n}\n```\n\n---\n# 配置III - 发布流程执行器 - FlowExecutor\nFlowExecutor用于执行flow并管理flow执行过程，常见的自定义项有：设置监听器，监听流程执行过程并作出相应，如security监听器，用于监听并控制流程的访问权限；调整flow的部分持久化选项等。\n\n - 注册监听器\n\n```\n<!-- 这里是为特定的flow应用该监听器，当不设criteria属性时，将对所有flow应用 -->\n<webflow:flow-execution-listeners>\n    <webflow:listener ref=\"securityListener\" criteria=\"securedFlow1,securedFlow2\"/>\n</webflow:flow-execution-listeners>\n```\n\n - 调整持久化参数\n- max-executions： 设定为每个用户保留的执行数(没错，就是执行数)，当超过该数量时，最先的那个执行会被清除。(这里的执行，我认为是一个新开的且处于激活状态下的flow实例)\n- max-execution-snapshots： 设定每个执行保留的最大快照数。不允许保留时，设为0。允许无线保留时，设为-1。(快照用于浏览器的返回按钮)\n```\n<webflow:flow-executor id=\"flowExecutor\" flow-registry=\"flowRegistry\">\n    <webflow:flow-execution-repository max-executions=\"5\" max-execution-snapshots=\"30\" />\n</webflow:flow-executor>\n\n```\n\n---\n# 配置IV - Spring MVC集成\n## 基础配置（将请求转发给flow）\n\n - Spring MVC基础配置\n\n```\n<servlet>\n\t<servlet-name>Spring MVC Dispatcher Servlet</servlet-name>\n\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t<init-param>\n\t\t<param-name>contextConfigLocation</param-name>\n\t\t<param-value>/WEB-INF/web-application-config.xml</param-value>\n\t</init-param>\n</servlet>\n\n<servlet-mapping>\n\t<servlet-name>Spring MVC Dispatcher Servlet</servlet-name>\n\t<!-- 不能使用类型/*的通配符进行匹配，否则会出现jsp不解析直接回发给浏览器的情况 -->\n\t<url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n***\n## FlowHandlerAdapter\n该步骤是使得Web Flow能够适配Spring MVC\n当一个对flow的请求被接收到时，FlowHandlerAdapter会决定是启动一个全新的flow还是继续之前的流程(如从一个view-state跳转到下一个state就属于继续之前的流程)，继续之前的flow是需要在请求有相关信息才行。有关这一方面，web flow默认有如下设定：\n&emsp;&emsp;1.Http请求参数在任何情况下都是可以使用的\n&emsp;&emsp;2.当一个flow执行结束，且结束时没有想浏览器发送最后的响应时，默认的handler会尝试在同一个request中启动一个新的flow执行\n&emsp;&emsp;3.除了NoSuchFlowExecutionException异常外，所有其它异常都会以冒泡的方式抛到Dispatcher中。这是因为默认的handler会尝试自动从该异常中恢复过来，恢复的方式是新开一个全新的flow执行\n针对大多数设定，都可以通过实现FlowHandlerAdapter类的子类进行自定义。\n\n```\n<!-- Enables FlowHandler URL mapping -->\n<bean class=\"org.springframework.webflow.mvc.servlet.FlowHandlerAdapter\">\n\t<!-- flowExecutor就是前文声明的执行器 -->\n\t<property name=\"flowExecutor\" ref=\"flowExecutor\" />\n</bean>\n```\n\n---\n# 配置V - FlowHandlerMapping\n\n```\n<!-- Maps request paths to flows in the flowRegistry;\n\te.g. a path of /hotels/booking looks for a flow with id \"hotels/booking\" -->\n<bean class=\"org.springframework.webflow.mvc.servlet.FlowHandlerMapping\">\n\t<!-- flowRegistry就是前文声明的注册器 -->\n\t<property name=\"flowRegistry\" ref=\"flowRegistry\"/>\n\t<property name=\"order\" value=\"0\"/>\n</bean>\n```\n有了Flow的基本配置和这里的两个Spring MVC的集成配置，请求就能够映射到flow中了。接下来就是写Flow了。想要快速上手的可忽略本文后面的内容，转而直接看本系列其它文章。\n\n---\n# 配置VI - 实现自定义的FlowHandler\n\n  - FlowHandler讲解\n FlowHandler可用于自定义flow在HTTP Servlert环境中执行的方式，FlowHandler在FlowHandlerAdapter中被使用，主要负责如下内容：\n\n &emsp;&emsp;- 返回flow的id以用于执行该flow\n &emsp;&emsp;- 在新流程开始时创建输入\n &emsp;&emsp;- 在流程结束时处理流程的输出\n &emsp;&emsp;- 在流程发生异常时，处理这些异常\n\n 其主要方法如下：\n\n\n```\npublic interface FlowHandler {\n\n\tpublic String getFlowId();\n\n\tpublic MutableAttributeMap createExecutionInputMap(HttpServletRequest request);\n\n\tpublic String handleExecutionOutcome(FlowExecutionOutcome outcome,\n\t\tHttpServletRequest request, HttpServletResponse response);\n\n\tpublic String handleException(FlowException e,\n\t\tHttpServletRequest request, HttpServletResponse response);\n}\n```\n &emsp;&emsp;该接口的直接实现为AbstractFlowHandler，当我们想要自定义某个设定时，继承该抽象类并重写其中的方法即可。\n\n - 发布一个FlowHandler\n 一个FlowHandler负责一个flow，发布方式是在Spring环境中声明一个bean，该bean的name必须和我们想要处理的flow的id一致，配置好后，当方位该flow的id，则会定位到新发布的FlowHandler中，我们自定义的方法也就生效了。\n\n\n```\n<!-- 这里的BookingHandler只是一个例子，实际用时替换成我们自己的Handler -->\n<bean name=\"hotels/booking\" class=\"org.springframework.webflow.samples.booking.BookingFlowHandler\" />\n```\n - 着重讲一下FlowHandler中handleExecutionOutcome(...)方法\n 该方法用于处理flow结束时产生的FlowExecutionOutcome(系统自动产生)，我们常用它来在流程结束后进行重定向，比如\n\n\n```\npublic class BookingFlowHandler extends AbstractFlowHandler {\n\t// handlExecutionOutcome()方法返回的String代表的是重定向的地址\n\tpublic String handleExecutionOutcome(FlowExecutionOutcome outcome,\n\t\t\t\t\t\t\t\t\t\tHttpServletRequest request, HttpServletResponse response) {\n\t\tif (outcome.getId().equals(\"bookingConfirmed\")) {\n\t\t\treturn \"/booking/show\";\n\t\t} else {\n\t\t\treturn \"/hotels/index\";\n\t\t}\n\t}\n}\n// 当flow id为bookinConfirmed时，重定向到/booking/show，否则重定向到/hotels/index\n```\n\n&emsp;&emsp;默认情况下，该方法返回的地址是相关于当前Servlet的。但是我们也可以显式地指定一些前缀来扩展重定向的范围\n\n &emsp;&emsp; -- `servletRelative`: - 相对于当前Servlet重定向\n&emsp;&emsp; -- `contextRelative`: - 相对于当前应用重定向\n&emsp;&emsp; -- `serverRelative`: - 相对于当前服务器的基地址重定向\n&emsp;&emsp; -- `http:// or https://` - 重定向到一个完整的URI地址\n\n&emsp;&emsp;相同的前缀同样适用于声明state时的view属性配上`externalRedirect`的情况\n\n```\n<end-state view=\"externalRedirect:http://springframework.org\"/>\n<!-- 在流程结束时，跳转到spring首页 -->\n```\n\n-----------------------------------------------------手动分割线------------------------------------------------------------------------------------------\n\n# 一个能用的配置(采用Java config的方式配置)\n## WebInitializer（与web.xml作用类似）\n\n```\npublic class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n\t@Override\n\tprotected Class<?>[] getRootConfigClasses() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected Class<?>[] getServletConfigClasses() {\n\t\treturn new Class<?>[] {MainConfig.class, RegisterConfig.class};\n\t}\n\n\t@Override\n\tprotected String[] getServletMappings() {\n\t\treturn new String[] {\"/\"};\n\t}\n\n}\n```\n\n## MainConfig（Spring的主要配置文件）\n\n```\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"cn.floyd.pw\")\npublic class MainConfig extends WebMvcConfigurerAdapter{\n\n\t@Bean(name=\"viewResolver\")\n\tpublic ViewResolver getViewResolver() {\n\t\tInternalResourceViewResolver resolver = new InternalResourceViewResolver();\n\t\tresolver.setPrefix(\"/WEB-INF/jsp/\");\n\t\tresolver.setSuffix(\".jsp\");\n\t\treturn resolver;\n\t}\n\t\n\t@Bean\n\tpublic MultipartResolver multipartResolver() throws IOException {\n\t    CommonsMultipartResolver resolver = new CommonsMultipartResolver();\n\t    return resolver;\n\t}\n\n\t// enable the static resource\n\t@Override\n\tpublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n\t\tconfigurer.enable();\n\t}\n\t\n\t@Bean\n    public FlowHandlerAdapter flowHandlerAdapter(@Autowired FlowExecutor flowExecutor) {\n\t    System.out.println(\"init flowHandlerAdapter\");\n        FlowHandlerAdapter adapter = new FlowHandlerAdapter();\n        adapter.setFlowExecutor(flowExecutor);\n        \n        return adapter;\n    }\n    \n    @Bean\n    public FlowHandlerMapping flowHandlerMapping(@Autowired FlowDefinitionRegistry flowRegistry) {\n        System.out.println(\"init flowHandlerMapping\");\n        FlowHandlerMapping mapping = new FlowHandlerMapping();\n        mapping.setOrder(0);\n        mapping.setFlowRegistry(flowRegistry);\n        \n        return mapping;\n    }\n\t\n}\n```\n\n## RegisterConfig（配置FlowRegister和flowExecutor）\n\n```\n@Configuration\npublic class RegisterConfig extends AbstractFlowConfiguration {\n\n    // 用于注册flow\n    @Bean(\"flowRegistry\")\n    public FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) {\n        \n        return getFlowDefinitionRegistryBuilder()\n                .setBasePath(\"/WEB-INF/jsp/flow\")\n                .addFlowLocation(\"/config/search-flow.xml\")\n                .setFlowBuilderServices(flowBuilderServices)\n                .build();\n    }\n    \n    @Bean\n    public FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator) {\n        return getFlowBuilderServicesBuilder()\n                .setViewFactoryCreator(mvcViewFactoryCreator)\n                .build();\n    }\n    \n    @Bean\n    public MvcViewFactoryCreator mvcViewFactoryCreator(@Autowired ViewResolver viewResolver) {\n        MvcViewFactoryCreator creator = new MvcViewFactoryCreator();\n        List<ViewResolver> list = new ArrayList<ViewResolver>();\n        list.add(viewResolver);\n        creator.setViewResolvers(list);\n        \n        return creator;\n    }\n    \n    @Bean\n    public FlowExecutor flowExecutor(@Autowired FlowDefinitionRegistry flowRegistry) {\n        return getFlowExecutorBuilder(flowRegistry).build();\n    }\n    \n}\n```\n\n---\n# 配置时踩过的坑\n\n## flow id的坑\n> 最开始对flow id的认识不够，导致不知道到底该如何定位到flow，其实访问方式就是  .../appName/flowId\n> #### Web MVC Environment null not supported\n> 启动时正常，访问flow时报异常java.lang.IllegalStateException: Web MVC Environment null not supported\n>  是在创建viewFactory时出错，由于我没有采用在config中声明bean的方式创建MvcViewFactoryCreator，因此出现找不到mvc环境的问题，原来是spring在自动检测并创建bean时，会同时设置该bean的环境，因此不能自己随意采用new的方式创建这些配置类\n> #### JSP文件不解析\n> 出现JSP文件不经过解析就直接传送给了浏览器的问题(对如下阐述的原理并不是很清楚)\n> url-pattern为\"/*\"时，能够匹配到任何路径，因此当controller返回.jsp文件时，也会被拦截，从而返回jsp源码(这里不是很理解，主要是跟自己认识的spring mvc处理流程有差别)。\n> url-pattern为\"/\"时，只能够匹配不带后缀的路径，因此jsp就不会被dispatcherServlet拦截，而是会被jspServlet拦截并处理。但是\"/\"在配置使能的情况下也能够拦截并允许静态资源的访问","source":"_posts/Spring Webflow - 配置.md","raw":"---\ntitle: Spring Webflow - 配置\ndate: 2018-09-05 22:33:00\ntags: \n    - Spring\n    - Webflow\ncategories: \n    - Spring Webflow\n---\n>  1. 本文基于Spring Web Flow 2.4.5，其它版本配置方式可能略有不同，请参考相应版本的[官方文档](https://projects.spring.io/spring-webflow/)\n>  2. Maven依赖\nmaven库查询推荐地址：http://mvnrepository.com/\n```\n<dependency>\n    <groupId>org.springframework.webflow</groupId>\n    <artifactId>spring-webflow</artifactId>\n    <version>2.4.5.RELEASE</version>\n</dependency>\n```\n# Web Flow嵌入到Spring MVC工作流简介\n请求被DispatcherServlet拦截 -> 分发flow进行处理，返回view -> viewResolver解析 -> 返回请求\n\n---\n# 配置项预览\n<ul>\n\t<li>FlowRegistry：必须，注册流程，指明流程配置文件所在位置；指定流程id(用于请求访问标识)；指定流程属性；此外还可以传入FlowBuilderServices进行更多个性化配置</li>\n\t<li>FlowBuilderServices：必须，用于设定流程配置文件中EL表达式的解析器、form属性绑定时的转换器、view-state的view解析器等，很重要</li>\n\t<li>FlowExecutor：必须，用于执行流程，可指定执行监听器(可选，常用于流程安全和持久化)</li>\n\t<li>FlowHandlerAdapter：必须，用于适配Spring MVC，配置时传入FlowExecutor</li>\n\t<li>FlowHandlerMapping：必须，用于将请求映射到对应的flow，配置时传入FlowRegistry</li>\n</ul>\n\n---\n# 配置I - 注册流程 - FlowRegistry\nFlowRegistry用于注册流程实例，指定流程位置和流程id，并可自定义流程创建相关内容\n\n## 注册flow的各种方式\n\n- 直接指定流程位置\n默认情况下，web-flow的id为其文件名减去后缀名，如下配置的id为booking。指定了基地址或使用了通配符时除外。\n```\n<webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" />\n// 注册了一个路径为/WEB-INF/flows/booking/booking.xml的流程，其余为默认配置。\n```\n- 自定义id\n\n```\n<webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" id=\"bookHotel\" />\n```\n\n-  定义流程属性\n如下定义了一个带有属性caption，其值为\"Books a hotel\"的流程。属性的使用方法暂时不了解\n```\n<webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\">\n    <webflow:flow-definition-attributes>\n        <webflow:attribute name=\"caption\" value=\"Books a hotel\" />\n    </webflow:flow-definition-attributes>\n</webflow:flow-location>\n```\n\n - 使用通配定义流程位置\n**使用该方法并没有正确实验出id**，这点作为参考\n```\n<webflow:flow-location-pattern value=\"/WEB-INF/flows/**/*-flow.xml\" />\n```\n\n- 使用基地址\n使用基地址的flow的id为其path属性减去文件名，如下配置的id为/hotels/booking；如果path中没有路径信息，只有文件名，则id为文件名减去后缀。\n```\n<webflow:flow-registry id=\"flowRegistry\" base-path=\"/WEB-INF\">\n    <webflow:flow-location path=\"/hotels/booking/booking.xml\" />\n</webflow:flow-registry>\n```\n## flow id属性总结\n1.  id的作用\nid用于请求定位到某个确切的flow，如当请求路径为http://localhost:8090/Floyd/search-flow，其中Floyd是项目名，如果有id为search-flow的flow存在，则会访问该flow\n2. id的定义\n - 没有基地址或通配符时，flow的id为文件名减去后缀，如`<webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" />`这里的id为booking\n - 有基地址时，id为path的值减去文件名，如基地址为`/WEB-INF`， path=`/flows/booking/booking.xml`时，id被确定为`flows/booking`\n - 有通配符时，该情况比较特殊，按照[官方说明](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#flow-registry-base-path)并没有验证通过，这里略过。\n当显式指定了id属性时，则使用指定的id。<b>推荐自定义id</b>\n## FlowRegistry继承\nFlowRegistry是可以继承的，可以定义一个公用的注册器，在多个子注册器中继承该注册器\n\n```\n<!-- my-system-config.xml -->\n<webflow:flow-registry id=\"flowRegistry\" parent=\"sharedFlowRegistry\">\n    <webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" />\n</webflow:flow-registry>\n\n<!-- shared-config.xml -->\n<webflow:flow-registry id=\"sharedFlowRegistry\">\n    <!-- Global flows shared by several applications -->\n</webflow:flow-registry>\n```\n\n---\n# 配置II - 使用FlowBuilder services\n使用FlowBuilder Services可以在build流程时自定义服务，比如视图解析器、EL表达式解析器、类型格式化和转换服务等。如无显式设定FlowBuilder Services，系统将使用默认实现。\n\n```\n<webflow:flow-registry id=\"flowRegistry\" flow-builder-services=\"flowBuilderServices\">\n    <webflow:flow-location path=\"/WEB-INF/flows/booking/booking.xml\" />\n</webflow:flow-registry>\n\n<webflow:flow-builder-services id=\"flowBuilderServices\"\n    conversion-service=\"conversionService\"\n    expression-parser=\"expressionParser\"\n    view-factory-creator=\"viewFactoryCreator\" />\n\n<bean id=\"conversionService\" class=\"...\" />\n<bean id=\"expressionParser\" class=\"...\" />\n<bean id=\"viewFactoryCreator\" class=\"...\" />\n```\n## 自定义视图解析器 view-factory-creator\nview-factory-creator用于视图解析工作，默认的creator可以支持Spring MVC支持的几种视图类型：JSP, Velocity，FreeMarker等。\n```\n<webflow:flow-registry id=\"flowRegistry\" flow-builder-services=\"flowBuilderServices\">\n\t<webflow:location path=\"/WEB-INF/hotels/booking/booking.xml\" />\n</webflow:flow-registry>\n\n<!-- 尤其注意这里的development，设置为true时表示开启开发模式，该模式下会在flow定义改变时自动re-load，甚至flow中引用的resource bundle发生了变化都会热重载 -->\n<webflow:flow-builder-services id=\"flowBuilderServices\" view-factory-creator=\"mvcViewFactoryCreator\" development=\"true\"/>\n\n<bean id=\"mvcViewFactoryCreator\" class=\"org.springframework.webflow.mvc.builder.MvcViewFactoryCreator\">\n\t<!-- myExistingViewResolverToUseForFlows就是我们常用的视图解析器，注意这里引用的是一个列表 -->\n\t<property name=\"viewResolvers\" ref=\"myExistingViewResolverToUseForFlows\"/>\n</bean>\n\n... ... \n... ...\n<!-- 做验证时使用的是javaconfig的形式，这种形式并没有验证过 -->\n<property name=\"myExistingViewResolverToUseForFlows\">\n    <list>\n        <ref bean=\"viewResolver\" />\n    </list>\n</property>\n\n<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n   <property name=\"prefix\" value=\"/WEB-INF/\"/>\n   <property name=\"suffix\" value=\".jsp\"/>\n</bean>\n\n```\n\n## 自定义表达式解析器 expression-parser\nexpression-parser用于定义表达式解析器，默认的解析器使用逻辑：当类路径下有Unified EL解析器时，则使用；没有时，则使用OGNL表达式解析器(官方文档在[EL表达式](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-unified-el)一章和[系统设置](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#builder-service-expression-parser)一章关于默认表达式解析说法有出入，自己认为比较可信的是Spring Web Flow 2.1以后，默认使用Spring EL表达式解析器)。\n下面是手动配置成Unified EL解析器的方式：\n\n```\n<webflow:flow-builder-services expression-parser=\"expressionParser\"/>\n\n<bean id=\"expressionParser\" class=\"org.springframework.webflow.expression.el.WebFlowELExpressionParser\">\n    <constructor-arg>\n        <bean class=\"org.jboss.el.ExpressionFactoryImpl\" />\n    </constructor-arg>\n</bean>\n```\n\n## 自定义类型转换器 conversion-service\n 详细内容参见本系列视图渲染相关章节或[官方文档](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration)\n\n```\n<webflow:flow-registry id=\"flowRegistry\" flow-builder-services=\"flowBuilderServices\" ... />\n\n<webflow:flow-builder-services id=\"flowBuilderServices\" conversion-service=\"defaultConversionService\" ... />\n\n<bean id=\"defaultConversionService\" class=\"org.springframework.binding.convert.service.DefaultConversionService\">\n\t<constructor-arg ref=\"applicationConversionSevice\"/>\n</bean>\n\n<bean id=\"applicationConversionService\" class=\"somepackage.ApplicationConversionServiceFactoryBean\">\n```\n\n```\npublic class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean {\n    @Override\n    protected void installFormatters(FormatterRegistry registry) {\n        // ...\n    }\n}\n```\n\n---\n# 配置III - 发布流程执行器 - FlowExecutor\nFlowExecutor用于执行flow并管理flow执行过程，常见的自定义项有：设置监听器，监听流程执行过程并作出相应，如security监听器，用于监听并控制流程的访问权限；调整flow的部分持久化选项等。\n\n - 注册监听器\n\n```\n<!-- 这里是为特定的flow应用该监听器，当不设criteria属性时，将对所有flow应用 -->\n<webflow:flow-execution-listeners>\n    <webflow:listener ref=\"securityListener\" criteria=\"securedFlow1,securedFlow2\"/>\n</webflow:flow-execution-listeners>\n```\n\n - 调整持久化参数\n- max-executions： 设定为每个用户保留的执行数(没错，就是执行数)，当超过该数量时，最先的那个执行会被清除。(这里的执行，我认为是一个新开的且处于激活状态下的flow实例)\n- max-execution-snapshots： 设定每个执行保留的最大快照数。不允许保留时，设为0。允许无线保留时，设为-1。(快照用于浏览器的返回按钮)\n```\n<webflow:flow-executor id=\"flowExecutor\" flow-registry=\"flowRegistry\">\n    <webflow:flow-execution-repository max-executions=\"5\" max-execution-snapshots=\"30\" />\n</webflow:flow-executor>\n\n```\n\n---\n# 配置IV - Spring MVC集成\n## 基础配置（将请求转发给flow）\n\n - Spring MVC基础配置\n\n```\n<servlet>\n\t<servlet-name>Spring MVC Dispatcher Servlet</servlet-name>\n\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t<init-param>\n\t\t<param-name>contextConfigLocation</param-name>\n\t\t<param-value>/WEB-INF/web-application-config.xml</param-value>\n\t</init-param>\n</servlet>\n\n<servlet-mapping>\n\t<servlet-name>Spring MVC Dispatcher Servlet</servlet-name>\n\t<!-- 不能使用类型/*的通配符进行匹配，否则会出现jsp不解析直接回发给浏览器的情况 -->\n\t<url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n***\n## FlowHandlerAdapter\n该步骤是使得Web Flow能够适配Spring MVC\n当一个对flow的请求被接收到时，FlowHandlerAdapter会决定是启动一个全新的flow还是继续之前的流程(如从一个view-state跳转到下一个state就属于继续之前的流程)，继续之前的flow是需要在请求有相关信息才行。有关这一方面，web flow默认有如下设定：\n&emsp;&emsp;1.Http请求参数在任何情况下都是可以使用的\n&emsp;&emsp;2.当一个flow执行结束，且结束时没有想浏览器发送最后的响应时，默认的handler会尝试在同一个request中启动一个新的flow执行\n&emsp;&emsp;3.除了NoSuchFlowExecutionException异常外，所有其它异常都会以冒泡的方式抛到Dispatcher中。这是因为默认的handler会尝试自动从该异常中恢复过来，恢复的方式是新开一个全新的flow执行\n针对大多数设定，都可以通过实现FlowHandlerAdapter类的子类进行自定义。\n\n```\n<!-- Enables FlowHandler URL mapping -->\n<bean class=\"org.springframework.webflow.mvc.servlet.FlowHandlerAdapter\">\n\t<!-- flowExecutor就是前文声明的执行器 -->\n\t<property name=\"flowExecutor\" ref=\"flowExecutor\" />\n</bean>\n```\n\n---\n# 配置V - FlowHandlerMapping\n\n```\n<!-- Maps request paths to flows in the flowRegistry;\n\te.g. a path of /hotels/booking looks for a flow with id \"hotels/booking\" -->\n<bean class=\"org.springframework.webflow.mvc.servlet.FlowHandlerMapping\">\n\t<!-- flowRegistry就是前文声明的注册器 -->\n\t<property name=\"flowRegistry\" ref=\"flowRegistry\"/>\n\t<property name=\"order\" value=\"0\"/>\n</bean>\n```\n有了Flow的基本配置和这里的两个Spring MVC的集成配置，请求就能够映射到flow中了。接下来就是写Flow了。想要快速上手的可忽略本文后面的内容，转而直接看本系列其它文章。\n\n---\n# 配置VI - 实现自定义的FlowHandler\n\n  - FlowHandler讲解\n FlowHandler可用于自定义flow在HTTP Servlert环境中执行的方式，FlowHandler在FlowHandlerAdapter中被使用，主要负责如下内容：\n\n &emsp;&emsp;- 返回flow的id以用于执行该flow\n &emsp;&emsp;- 在新流程开始时创建输入\n &emsp;&emsp;- 在流程结束时处理流程的输出\n &emsp;&emsp;- 在流程发生异常时，处理这些异常\n\n 其主要方法如下：\n\n\n```\npublic interface FlowHandler {\n\n\tpublic String getFlowId();\n\n\tpublic MutableAttributeMap createExecutionInputMap(HttpServletRequest request);\n\n\tpublic String handleExecutionOutcome(FlowExecutionOutcome outcome,\n\t\tHttpServletRequest request, HttpServletResponse response);\n\n\tpublic String handleException(FlowException e,\n\t\tHttpServletRequest request, HttpServletResponse response);\n}\n```\n &emsp;&emsp;该接口的直接实现为AbstractFlowHandler，当我们想要自定义某个设定时，继承该抽象类并重写其中的方法即可。\n\n - 发布一个FlowHandler\n 一个FlowHandler负责一个flow，发布方式是在Spring环境中声明一个bean，该bean的name必须和我们想要处理的flow的id一致，配置好后，当方位该flow的id，则会定位到新发布的FlowHandler中，我们自定义的方法也就生效了。\n\n\n```\n<!-- 这里的BookingHandler只是一个例子，实际用时替换成我们自己的Handler -->\n<bean name=\"hotels/booking\" class=\"org.springframework.webflow.samples.booking.BookingFlowHandler\" />\n```\n - 着重讲一下FlowHandler中handleExecutionOutcome(...)方法\n 该方法用于处理flow结束时产生的FlowExecutionOutcome(系统自动产生)，我们常用它来在流程结束后进行重定向，比如\n\n\n```\npublic class BookingFlowHandler extends AbstractFlowHandler {\n\t// handlExecutionOutcome()方法返回的String代表的是重定向的地址\n\tpublic String handleExecutionOutcome(FlowExecutionOutcome outcome,\n\t\t\t\t\t\t\t\t\t\tHttpServletRequest request, HttpServletResponse response) {\n\t\tif (outcome.getId().equals(\"bookingConfirmed\")) {\n\t\t\treturn \"/booking/show\";\n\t\t} else {\n\t\t\treturn \"/hotels/index\";\n\t\t}\n\t}\n}\n// 当flow id为bookinConfirmed时，重定向到/booking/show，否则重定向到/hotels/index\n```\n\n&emsp;&emsp;默认情况下，该方法返回的地址是相关于当前Servlet的。但是我们也可以显式地指定一些前缀来扩展重定向的范围\n\n &emsp;&emsp; -- `servletRelative`: - 相对于当前Servlet重定向\n&emsp;&emsp; -- `contextRelative`: - 相对于当前应用重定向\n&emsp;&emsp; -- `serverRelative`: - 相对于当前服务器的基地址重定向\n&emsp;&emsp; -- `http:// or https://` - 重定向到一个完整的URI地址\n\n&emsp;&emsp;相同的前缀同样适用于声明state时的view属性配上`externalRedirect`的情况\n\n```\n<end-state view=\"externalRedirect:http://springframework.org\"/>\n<!-- 在流程结束时，跳转到spring首页 -->\n```\n\n-----------------------------------------------------手动分割线------------------------------------------------------------------------------------------\n\n# 一个能用的配置(采用Java config的方式配置)\n## WebInitializer（与web.xml作用类似）\n\n```\npublic class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n\t@Override\n\tprotected Class<?>[] getRootConfigClasses() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected Class<?>[] getServletConfigClasses() {\n\t\treturn new Class<?>[] {MainConfig.class, RegisterConfig.class};\n\t}\n\n\t@Override\n\tprotected String[] getServletMappings() {\n\t\treturn new String[] {\"/\"};\n\t}\n\n}\n```\n\n## MainConfig（Spring的主要配置文件）\n\n```\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"cn.floyd.pw\")\npublic class MainConfig extends WebMvcConfigurerAdapter{\n\n\t@Bean(name=\"viewResolver\")\n\tpublic ViewResolver getViewResolver() {\n\t\tInternalResourceViewResolver resolver = new InternalResourceViewResolver();\n\t\tresolver.setPrefix(\"/WEB-INF/jsp/\");\n\t\tresolver.setSuffix(\".jsp\");\n\t\treturn resolver;\n\t}\n\t\n\t@Bean\n\tpublic MultipartResolver multipartResolver() throws IOException {\n\t    CommonsMultipartResolver resolver = new CommonsMultipartResolver();\n\t    return resolver;\n\t}\n\n\t// enable the static resource\n\t@Override\n\tpublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n\t\tconfigurer.enable();\n\t}\n\t\n\t@Bean\n    public FlowHandlerAdapter flowHandlerAdapter(@Autowired FlowExecutor flowExecutor) {\n\t    System.out.println(\"init flowHandlerAdapter\");\n        FlowHandlerAdapter adapter = new FlowHandlerAdapter();\n        adapter.setFlowExecutor(flowExecutor);\n        \n        return adapter;\n    }\n    \n    @Bean\n    public FlowHandlerMapping flowHandlerMapping(@Autowired FlowDefinitionRegistry flowRegistry) {\n        System.out.println(\"init flowHandlerMapping\");\n        FlowHandlerMapping mapping = new FlowHandlerMapping();\n        mapping.setOrder(0);\n        mapping.setFlowRegistry(flowRegistry);\n        \n        return mapping;\n    }\n\t\n}\n```\n\n## RegisterConfig（配置FlowRegister和flowExecutor）\n\n```\n@Configuration\npublic class RegisterConfig extends AbstractFlowConfiguration {\n\n    // 用于注册flow\n    @Bean(\"flowRegistry\")\n    public FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) {\n        \n        return getFlowDefinitionRegistryBuilder()\n                .setBasePath(\"/WEB-INF/jsp/flow\")\n                .addFlowLocation(\"/config/search-flow.xml\")\n                .setFlowBuilderServices(flowBuilderServices)\n                .build();\n    }\n    \n    @Bean\n    public FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator) {\n        return getFlowBuilderServicesBuilder()\n                .setViewFactoryCreator(mvcViewFactoryCreator)\n                .build();\n    }\n    \n    @Bean\n    public MvcViewFactoryCreator mvcViewFactoryCreator(@Autowired ViewResolver viewResolver) {\n        MvcViewFactoryCreator creator = new MvcViewFactoryCreator();\n        List<ViewResolver> list = new ArrayList<ViewResolver>();\n        list.add(viewResolver);\n        creator.setViewResolvers(list);\n        \n        return creator;\n    }\n    \n    @Bean\n    public FlowExecutor flowExecutor(@Autowired FlowDefinitionRegistry flowRegistry) {\n        return getFlowExecutorBuilder(flowRegistry).build();\n    }\n    \n}\n```\n\n---\n# 配置时踩过的坑\n\n## flow id的坑\n> 最开始对flow id的认识不够，导致不知道到底该如何定位到flow，其实访问方式就是  .../appName/flowId\n> #### Web MVC Environment null not supported\n> 启动时正常，访问flow时报异常java.lang.IllegalStateException: Web MVC Environment null not supported\n>  是在创建viewFactory时出错，由于我没有采用在config中声明bean的方式创建MvcViewFactoryCreator，因此出现找不到mvc环境的问题，原来是spring在自动检测并创建bean时，会同时设置该bean的环境，因此不能自己随意采用new的方式创建这些配置类\n> #### JSP文件不解析\n> 出现JSP文件不经过解析就直接传送给了浏览器的问题(对如下阐述的原理并不是很清楚)\n> url-pattern为\"/*\"时，能够匹配到任何路径，因此当controller返回.jsp文件时，也会被拦截，从而返回jsp源码(这里不是很理解，主要是跟自己认识的spring mvc处理流程有差别)。\n> url-pattern为\"/\"时，只能够匹配不带后缀的路径，因此jsp就不会被dispatcherServlet拦截，而是会被jspServlet拦截并处理。但是\"/\"在配置使能的情况下也能够拦截并允许静态资源的访问","slug":"Spring Webflow - 配置","published":1,"updated":"2019-09-08T10:13:30.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo9a000e00bn1k0z1u3b","content":"<blockquote>\n<ol>\n<li>本文基于Spring Web Flow 2.4.5，其它版本配置方式可能略有不同，请参考相应版本的<a href=\"https://projects.spring.io/spring-webflow/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>Maven依赖<br>maven库查询推荐地址：<a href=\"http://mvnrepository.com/\" target=\"_blank\" rel=\"noopener\">http://mvnrepository.com/</a></li>\n</ol>\n</blockquote><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.webflow&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-webflow&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.4.5.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n\n\n<h1 id=\"Web-Flow嵌入到Spring-MVC工作流简介\"><a href=\"#Web-Flow嵌入到Spring-MVC工作流简介\" class=\"headerlink\" title=\"Web Flow嵌入到Spring MVC工作流简介\"></a>Web Flow嵌入到Spring MVC工作流简介</h1><p>请求被DispatcherServlet拦截 -&gt; 分发flow进行处理，返回view -&gt; viewResolver解析 -&gt; 返回请求</p>\n<hr>\n<h1 id=\"配置项预览\"><a href=\"#配置项预览\" class=\"headerlink\" title=\"配置项预览\"></a>配置项预览</h1><ul>\n    <li>FlowRegistry：必须，注册流程，指明流程配置文件所在位置；指定流程id(用于请求访问标识)；指定流程属性；此外还可以传入FlowBuilderServices进行更多个性化配置</li>\n    <li>FlowBuilderServices：必须，用于设定流程配置文件中EL表达式的解析器、form属性绑定时的转换器、view-state的view解析器等，很重要</li>\n    <li>FlowExecutor：必须，用于执行流程，可指定执行监听器(可选，常用于流程安全和持久化)</li>\n    <li>FlowHandlerAdapter：必须，用于适配Spring MVC，配置时传入FlowExecutor</li>\n    <li>FlowHandlerMapping：必须，用于将请求映射到对应的flow，配置时传入FlowRegistry</li>\n</ul>\n\n<hr>\n<h1 id=\"配置I-注册流程-FlowRegistry\"><a href=\"#配置I-注册流程-FlowRegistry\" class=\"headerlink\" title=\"配置I - 注册流程 - FlowRegistry\"></a>配置I - 注册流程 - FlowRegistry</h1><p>FlowRegistry用于注册流程实例，指定流程位置和流程id，并可自定义流程创建相关内容</p>\n<h2 id=\"注册flow的各种方式\"><a href=\"#注册flow的各种方式\" class=\"headerlink\" title=\"注册flow的各种方式\"></a>注册flow的各种方式</h2><ul>\n<li><p>直接指定流程位置<br>默认情况下，web-flow的id为其文件名减去后缀名，如下配置的id为booking。指定了基地址或使用了通配符时除外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">// 注册了一个路径为/WEB-INF/flows/booking/booking.xml的流程，其余为默认配置。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义id</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; id=&quot;bookHotel&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>定义流程属性<br>如下定义了一个带有属性caption，其值为”Books a hotel”的流程。属性的使用方法暂时不了解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-definition-attributes&gt;</span><br><span class=\"line\">        &lt;webflow:attribute name=&quot;caption&quot; value=&quot;Books a hotel&quot; /&gt;</span><br><span class=\"line\">    &lt;/webflow:flow-definition-attributes&gt;</span><br><span class=\"line\">&lt;/webflow:flow-location&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用通配定义流程位置</li>\n</ul>\n</li>\n</ul>\n<p><strong>使用该方法并没有正确实验出id</strong>，这点作为参考</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-location-pattern value=&quot;/WEB-INF/flows/**/*-flow.xml&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用基地址<br>使用基地址的flow的id为其path属性减去文件名，如下配置的id为/hotels/booking；如果path中没有路径信息，只有文件名，则id为文件名减去后缀。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; base-path=&quot;/WEB-INF&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-location path=&quot;/hotels/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"flow-id属性总结\"><a href=\"#flow-id属性总结\" class=\"headerlink\" title=\"flow id属性总结\"></a>flow id属性总结</h2><ol>\n<li>id的作用<br>id用于请求定位到某个确切的flow，如当请求路径为<a href=\"http://localhost:8090/Floyd/search-flow，其中Floyd是项目名，如果有id为search-flow的flow存在，则会访问该flow\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/Floyd/search-flow，其中Floyd是项目名，如果有id为search-flow的flow存在，则会访问该flow</a></li>\n<li>id的定义<ul>\n<li>没有基地址或通配符时，flow的id为文件名减去后缀，如<code>&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</code>这里的id为booking</li>\n<li>有基地址时，id为path的值减去文件名，如基地址为<code>/WEB-INF</code>， path=<code>/flows/booking/booking.xml</code>时，id被确定为<code>flows/booking</code></li>\n<li>有通配符时，该情况比较特殊，按照<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#flow-registry-base-path\" target=\"_blank\" rel=\"noopener\">官方说明</a>并没有验证通过，这里略过。<br>当显式指定了id属性时，则使用指定的id。<b>推荐自定义id</b><h2 id=\"FlowRegistry继承\"><a href=\"#FlowRegistry继承\" class=\"headerlink\" title=\"FlowRegistry继承\"></a>FlowRegistry继承</h2>FlowRegistry是可以继承的，可以定义一个公用的注册器，在多个子注册器中继承该注册器</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- my-system-config.xml --&gt;</span><br><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; parent=&quot;sharedFlowRegistry&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- shared-config.xml --&gt;</span><br><span class=\"line\">&lt;webflow:flow-registry id=&quot;sharedFlowRegistry&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Global flows shared by several applications --&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置II-使用FlowBuilder-services\"><a href=\"#配置II-使用FlowBuilder-services\" class=\"headerlink\" title=\"配置II - 使用FlowBuilder services\"></a>配置II - 使用FlowBuilder services</h1><p>使用FlowBuilder Services可以在build流程时自定义服务，比如视图解析器、EL表达式解析器、类型格式化和转换服务等。如无显式设定FlowBuilder Services，系统将使用默认实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot;</span><br><span class=\"line\">    conversion-service=&quot;conversionService&quot;</span><br><span class=\"line\">    expression-parser=&quot;expressionParser&quot;</span><br><span class=\"line\">    view-factory-creator=&quot;viewFactoryCreator&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;conversionService&quot; class=&quot;...&quot; /&gt;</span><br><span class=\"line\">&lt;bean id=&quot;expressionParser&quot; class=&quot;...&quot; /&gt;</span><br><span class=\"line\">&lt;bean id=&quot;viewFactoryCreator&quot; class=&quot;...&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义视图解析器-view-factory-creator\"><a href=\"#自定义视图解析器-view-factory-creator\" class=\"headerlink\" title=\"自定义视图解析器 view-factory-creator\"></a>自定义视图解析器 view-factory-creator</h2><p>view-factory-creator用于视图解析工作，默认的creator可以支持Spring MVC支持的几种视图类型：JSP, Velocity，FreeMarker等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot;&gt;</span><br><span class=\"line\">\t&lt;webflow:location path=&quot;/WEB-INF/hotels/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 尤其注意这里的development，设置为true时表示开启开发模式，该模式下会在flow定义改变时自动re-load，甚至flow中引用的resource bundle发生了变化都会热重载 --&gt;</span><br><span class=\"line\">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; view-factory-creator=&quot;mvcViewFactoryCreator&quot; development=&quot;true&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;mvcViewFactoryCreator&quot; class=&quot;org.springframework.webflow.mvc.builder.MvcViewFactoryCreator&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- myExistingViewResolverToUseForFlows就是我们常用的视图解析器，注意这里引用的是一个列表 --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;viewResolvers&quot; ref=&quot;myExistingViewResolverToUseForFlows&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">... ... </span><br><span class=\"line\">... ...</span><br><span class=\"line\">&lt;!-- 做验证时使用的是javaconfig的形式，这种形式并没有验证过 --&gt;</span><br><span class=\"line\">&lt;property name=&quot;myExistingViewResolverToUseForFlows&quot;&gt;</span><br><span class=\"line\">    &lt;list&gt;</span><br><span class=\"line\">        &lt;ref bean=&quot;viewResolver&quot; /&gt;</span><br><span class=\"line\">    &lt;/list&gt;</span><br><span class=\"line\">&lt;/property&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class=\"line\">   &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;/&gt;</span><br><span class=\"line\">   &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义表达式解析器-expression-parser\"><a href=\"#自定义表达式解析器-expression-parser\" class=\"headerlink\" title=\"自定义表达式解析器 expression-parser\"></a>自定义表达式解析器 expression-parser</h2><p>expression-parser用于定义表达式解析器，默认的解析器使用逻辑：当类路径下有Unified EL解析器时，则使用；没有时，则使用OGNL表达式解析器(官方文档在<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-unified-el\" target=\"_blank\" rel=\"noopener\">EL表达式</a>一章和<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#builder-service-expression-parser\" target=\"_blank\" rel=\"noopener\">系统设置</a>一章关于默认表达式解析说法有出入，自己认为比较可信的是Spring Web Flow 2.1以后，默认使用Spring EL表达式解析器)。<br>下面是手动配置成Unified EL解析器的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-builder-services expression-parser=&quot;expressionParser&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;expressionParser&quot; class=&quot;org.springframework.webflow.expression.el.WebFlowELExpressionParser&quot;&gt;</span><br><span class=\"line\">    &lt;constructor-arg&gt;</span><br><span class=\"line\">        &lt;bean class=&quot;org.jboss.el.ExpressionFactoryImpl&quot; /&gt;</span><br><span class=\"line\">    &lt;/constructor-arg&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义类型转换器-conversion-service\"><a href=\"#自定义类型转换器-conversion-service\" class=\"headerlink\" title=\"自定义类型转换器 conversion-service\"></a>自定义类型转换器 conversion-service</h2><p> 详细内容参见本系列视图渲染相关章节或<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot; ... /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; conversion-service=&quot;defaultConversionService&quot; ... /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;defaultConversionService&quot; class=&quot;org.springframework.binding.convert.service.DefaultConversionService&quot;&gt;</span><br><span class=\"line\">\t&lt;constructor-arg ref=&quot;applicationConversionSevice&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;applicationConversionService&quot; class=&quot;somepackage.ApplicationConversionServiceFactoryBean&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void installFormatters(FormatterRegistry registry) &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置III-发布流程执行器-FlowExecutor\"><a href=\"#配置III-发布流程执行器-FlowExecutor\" class=\"headerlink\" title=\"配置III - 发布流程执行器 - FlowExecutor\"></a>配置III - 发布流程执行器 - FlowExecutor</h1><p>FlowExecutor用于执行flow并管理flow执行过程，常见的自定义项有：设置监听器，监听流程执行过程并作出相应，如security监听器，用于监听并控制流程的访问权限；调整flow的部分持久化选项等。</p>\n<ul>\n<li>注册监听器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 这里是为特定的flow应用该监听器，当不设criteria属性时，将对所有flow应用 --&gt;</span><br><span class=\"line\">&lt;webflow:flow-execution-listeners&gt;</span><br><span class=\"line\">    &lt;webflow:listener ref=&quot;securityListener&quot; criteria=&quot;securedFlow1,securedFlow2&quot;/&gt;</span><br><span class=\"line\">&lt;/webflow:flow-execution-listeners&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>调整持久化参数<ul>\n<li>max-executions： 设定为每个用户保留的执行数(没错，就是执行数)，当超过该数量时，最先的那个执行会被清除。(这里的执行，我认为是一个新开的且处于激活状态下的flow实例)</li>\n<li>max-execution-snapshots： 设定每个执行保留的最大快照数。不允许保留时，设为0。允许无线保留时，设为-1。(快照用于浏览器的返回按钮)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-executor id=&quot;flowExecutor&quot; flow-registry=&quot;flowRegistry&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-execution-repository max-executions=&quot;5&quot; max-execution-snapshots=&quot;30&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-executor&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"配置IV-Spring-MVC集成\"><a href=\"#配置IV-Spring-MVC集成\" class=\"headerlink\" title=\"配置IV - Spring MVC集成\"></a>配置IV - Spring MVC集成</h1><h2 id=\"基础配置（将请求转发给flow）\"><a href=\"#基础配置（将请求转发给flow）\" class=\"headerlink\" title=\"基础配置（将请求转发给flow）\"></a>基础配置（将请求转发给flow）</h2><ul>\n<li>Spring MVC基础配置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;servlet&gt;</span><br><span class=\"line\">\t&lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;</span><br><span class=\"line\">\t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class=\"line\">\t&lt;init-param&gt;</span><br><span class=\"line\">\t\t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class=\"line\">\t\t&lt;param-value&gt;/WEB-INF/web-application-config.xml&lt;/param-value&gt;</span><br><span class=\"line\">\t&lt;/init-param&gt;</span><br><span class=\"line\">&lt;/servlet&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">\t&lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;</span><br><span class=\"line\">\t&lt;!-- 不能使用类型/*的通配符进行匹配，否则会出现jsp不解析直接回发给浏览器的情况 --&gt;</span><br><span class=\"line\">\t&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class=\"line\">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"FlowHandlerAdapter\"><a href=\"#FlowHandlerAdapter\" class=\"headerlink\" title=\"FlowHandlerAdapter\"></a>FlowHandlerAdapter</h2><p>该步骤是使得Web Flow能够适配Spring MVC<br>当一个对flow的请求被接收到时，FlowHandlerAdapter会决定是启动一个全新的flow还是继续之前的流程(如从一个view-state跳转到下一个state就属于继续之前的流程)，继续之前的flow是需要在请求有相关信息才行。有关这一方面，web flow默认有如下设定：<br>&emsp;&emsp;1.Http请求参数在任何情况下都是可以使用的<br>&emsp;&emsp;2.当一个flow执行结束，且结束时没有想浏览器发送最后的响应时，默认的handler会尝试在同一个request中启动一个新的flow执行<br>&emsp;&emsp;3.除了NoSuchFlowExecutionException异常外，所有其它异常都会以冒泡的方式抛到Dispatcher中。这是因为默认的handler会尝试自动从该异常中恢复过来，恢复的方式是新开一个全新的flow执行<br>针对大多数设定，都可以通过实现FlowHandlerAdapter类的子类进行自定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Enables FlowHandler URL mapping --&gt;</span><br><span class=\"line\">&lt;bean class=&quot;org.springframework.webflow.mvc.servlet.FlowHandlerAdapter&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- flowExecutor就是前文声明的执行器 --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;flowExecutor&quot; ref=&quot;flowExecutor&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置V-FlowHandlerMapping\"><a href=\"#配置V-FlowHandlerMapping\" class=\"headerlink\" title=\"配置V - FlowHandlerMapping\"></a>配置V - FlowHandlerMapping</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Maps request paths to flows in the flowRegistry;</span><br><span class=\"line\">\te.g. a path of /hotels/booking looks for a flow with id &quot;hotels/booking&quot; --&gt;</span><br><span class=\"line\">&lt;bean class=&quot;org.springframework.webflow.mvc.servlet.FlowHandlerMapping&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- flowRegistry就是前文声明的注册器 --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;flowRegistry&quot; ref=&quot;flowRegistry&quot;/&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;order&quot; value=&quot;0&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p>有了Flow的基本配置和这里的两个Spring MVC的集成配置，请求就能够映射到flow中了。接下来就是写Flow了。想要快速上手的可忽略本文后面的内容，转而直接看本系列其它文章。</p>\n<hr>\n<h1 id=\"配置VI-实现自定义的FlowHandler\"><a href=\"#配置VI-实现自定义的FlowHandler\" class=\"headerlink\" title=\"配置VI - 实现自定义的FlowHandler\"></a>配置VI - 实现自定义的FlowHandler</h1><ul>\n<li><p>FlowHandler讲解<br>FlowHandler可用于自定义flow在HTTP Servlert环境中执行的方式，FlowHandler在FlowHandlerAdapter中被使用，主要负责如下内容：</p>\n<p>&emsp;&emsp;- 返回flow的id以用于执行该flow<br>&emsp;&emsp;- 在新流程开始时创建输入<br>&emsp;&emsp;- 在流程结束时处理流程的输出<br>&emsp;&emsp;- 在流程发生异常时，处理这些异常</p>\n<p>其主要方法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface FlowHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getFlowId();</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic MutableAttributeMap createExecutionInputMap(HttpServletRequest request);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String handleExecutionOutcome(FlowExecutionOutcome outcome,</span><br><span class=\"line\">\t\tHttpServletRequest request, HttpServletResponse response);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String handleException(FlowException e,</span><br><span class=\"line\">\t\tHttpServletRequest request, HttpServletResponse response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> &emsp;&emsp;该接口的直接实现为AbstractFlowHandler，当我们想要自定义某个设定时，继承该抽象类并重写其中的方法即可。</p>\n<ul>\n<li>发布一个FlowHandler<br>一个FlowHandler负责一个flow，发布方式是在Spring环境中声明一个bean，该bean的name必须和我们想要处理的flow的id一致，配置好后，当方位该flow的id，则会定位到新发布的FlowHandler中，我们自定义的方法也就生效了。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 这里的BookingHandler只是一个例子，实际用时替换成我们自己的Handler --&gt;</span><br><span class=\"line\">&lt;bean name=&quot;hotels/booking&quot; class=&quot;org.springframework.webflow.samples.booking.BookingFlowHandler&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>着重讲一下FlowHandler中handleExecutionOutcome(…)方法<br>该方法用于处理flow结束时产生的FlowExecutionOutcome(系统自动产生)，我们常用它来在流程结束后进行重定向，比如</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookingFlowHandler extends AbstractFlowHandler &#123;</span><br><span class=\"line\">\t// handlExecutionOutcome()方法返回的String代表的是重定向的地址</span><br><span class=\"line\">\tpublic String handleExecutionOutcome(FlowExecutionOutcome outcome,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\tHttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class=\"line\">\t\tif (outcome.getId().equals(&quot;bookingConfirmed&quot;)) &#123;</span><br><span class=\"line\">\t\t\treturn &quot;/booking/show&quot;;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn &quot;/hotels/index&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 当flow id为bookinConfirmed时，重定向到/booking/show，否则重定向到/hotels/index</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;默认情况下，该方法返回的地址是相关于当前Servlet的。但是我们也可以显式地指定一些前缀来扩展重定向的范围</p>\n<p> &emsp;&emsp; – <code>servletRelative</code>: - 相对于当前Servlet重定向<br>&emsp;&emsp; – <code>contextRelative</code>: - 相对于当前应用重定向<br>&emsp;&emsp; – <code>serverRelative</code>: - 相对于当前服务器的基地址重定向<br>&emsp;&emsp; – <code>http:// or https://</code> - 重定向到一个完整的URI地址</p>\n<p>&emsp;&emsp;相同的前缀同样适用于声明state时的view属性配上<code>externalRedirect</code>的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;end-state view=&quot;externalRedirect:http://springframework.org&quot;/&gt;</span><br><span class=\"line\">&lt;!-- 在流程结束时，跳转到spring首页 --&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—————————————————–手动分割线——————————————————————————————</p>\n<h1 id=\"一个能用的配置-采用Java-config的方式配置\"><a href=\"#一个能用的配置-采用Java-config的方式配置\" class=\"headerlink\" title=\"一个能用的配置(采用Java config的方式配置)\"></a>一个能用的配置(采用Java config的方式配置)</h1><h2 id=\"WebInitializer（与web-xml作用类似）\"><a href=\"#WebInitializer（与web-xml作用类似）\" class=\"headerlink\" title=\"WebInitializer（与web.xml作用类似）\"></a>WebInitializer（与web.xml作用类似）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">\t\treturn null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">\t\treturn new Class&lt;?&gt;[] &#123;MainConfig.class, RegisterConfig.class&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected String[] getServletMappings() &#123;</span><br><span class=\"line\">\t\treturn new String[] &#123;&quot;/&quot;&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MainConfig（Spring的主要配置文件）\"><a href=\"#MainConfig（Spring的主要配置文件）\" class=\"headerlink\" title=\"MainConfig（Spring的主要配置文件）\"></a>MainConfig（Spring的主要配置文件）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableWebMvc</span><br><span class=\"line\">@ComponentScan(&quot;cn.floyd.pw&quot;)</span><br><span class=\"line\">public class MainConfig extends WebMvcConfigurerAdapter&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Bean(name=&quot;viewResolver&quot;)</span><br><span class=\"line\">\tpublic ViewResolver getViewResolver() &#123;</span><br><span class=\"line\">\t\tInternalResourceViewResolver resolver = new InternalResourceViewResolver();</span><br><span class=\"line\">\t\tresolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);</span><br><span class=\"line\">\t\tresolver.setSuffix(&quot;.jsp&quot;);</span><br><span class=\"line\">\t\treturn resolver;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">\tpublic MultipartResolver multipartResolver() throws IOException &#123;</span><br><span class=\"line\">\t    CommonsMultipartResolver resolver = new CommonsMultipartResolver();</span><br><span class=\"line\">\t    return resolver;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// enable the static resource</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</span><br><span class=\"line\">\t\tconfigurer.enable();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">    public FlowHandlerAdapter flowHandlerAdapter(@Autowired FlowExecutor flowExecutor) &#123;</span><br><span class=\"line\">\t    System.out.println(&quot;init flowHandlerAdapter&quot;);</span><br><span class=\"line\">        FlowHandlerAdapter adapter = new FlowHandlerAdapter();</span><br><span class=\"line\">        adapter.setFlowExecutor(flowExecutor);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return adapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public FlowHandlerMapping flowHandlerMapping(@Autowired FlowDefinitionRegistry flowRegistry) &#123;</span><br><span class=\"line\">        System.out.println(&quot;init flowHandlerMapping&quot;);</span><br><span class=\"line\">        FlowHandlerMapping mapping = new FlowHandlerMapping();</span><br><span class=\"line\">        mapping.setOrder(0);</span><br><span class=\"line\">        mapping.setFlowRegistry(flowRegistry);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return mapping;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RegisterConfig（配置FlowRegister和flowExecutor）\"><a href=\"#RegisterConfig（配置FlowRegister和flowExecutor）\" class=\"headerlink\" title=\"RegisterConfig（配置FlowRegister和flowExecutor）\"></a>RegisterConfig（配置FlowRegister和flowExecutor）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RegisterConfig extends AbstractFlowConfiguration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 用于注册flow</span><br><span class=\"line\">    @Bean(&quot;flowRegistry&quot;)</span><br><span class=\"line\">    public FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        return getFlowDefinitionRegistryBuilder()</span><br><span class=\"line\">                .setBasePath(&quot;/WEB-INF/jsp/flow&quot;)</span><br><span class=\"line\">                .addFlowLocation(&quot;/config/search-flow.xml&quot;)</span><br><span class=\"line\">                .setFlowBuilderServices(flowBuilderServices)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator) &#123;</span><br><span class=\"line\">        return getFlowBuilderServicesBuilder()</span><br><span class=\"line\">                .setViewFactoryCreator(mvcViewFactoryCreator)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public MvcViewFactoryCreator mvcViewFactoryCreator(@Autowired ViewResolver viewResolver) &#123;</span><br><span class=\"line\">        MvcViewFactoryCreator creator = new MvcViewFactoryCreator();</span><br><span class=\"line\">        List&lt;ViewResolver&gt; list = new ArrayList&lt;ViewResolver&gt;();</span><br><span class=\"line\">        list.add(viewResolver);</span><br><span class=\"line\">        creator.setViewResolvers(list);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return creator;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public FlowExecutor flowExecutor(@Autowired FlowDefinitionRegistry flowRegistry) &#123;</span><br><span class=\"line\">        return getFlowExecutorBuilder(flowRegistry).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置时踩过的坑\"><a href=\"#配置时踩过的坑\" class=\"headerlink\" title=\"配置时踩过的坑\"></a>配置时踩过的坑</h1><h2 id=\"flow-id的坑\"><a href=\"#flow-id的坑\" class=\"headerlink\" title=\"flow id的坑\"></a>flow id的坑</h2><blockquote>\n<p>最开始对flow id的认识不够，导致不知道到底该如何定位到flow，其实访问方式就是  …/appName/flowId</p>\n<h4 id=\"Web-MVC-Environment-null-not-supported\"><a href=\"#Web-MVC-Environment-null-not-supported\" class=\"headerlink\" title=\"Web MVC Environment null not supported\"></a>Web MVC Environment null not supported</h4><p>启动时正常，访问flow时报异常java.lang.IllegalStateException: Web MVC Environment null not supported<br> 是在创建viewFactory时出错，由于我没有采用在config中声明bean的方式创建MvcViewFactoryCreator，因此出现找不到mvc环境的问题，原来是spring在自动检测并创建bean时，会同时设置该bean的环境，因此不能自己随意采用new的方式创建这些配置类</p>\n<h4 id=\"JSP文件不解析\"><a href=\"#JSP文件不解析\" class=\"headerlink\" title=\"JSP文件不解析\"></a>JSP文件不解析</h4><p>出现JSP文件不经过解析就直接传送给了浏览器的问题(对如下阐述的原理并不是很清楚)<br>url-pattern为”/*”时，能够匹配到任何路径，因此当controller返回.jsp文件时，也会被拦截，从而返回jsp源码(这里不是很理解，主要是跟自己认识的spring mvc处理流程有差别)。<br>url-pattern为”/“时，只能够匹配不带后缀的路径，因此jsp就不会被dispatcherServlet拦截，而是会被jspServlet拦截并处理。但是”/“在配置使能的情况下也能够拦截并允许静态资源的访问</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<ol>\n<li>本文基于Spring Web Flow 2.4.5，其它版本配置方式可能略有不同，请参考相应版本的<a href=\"https://projects.spring.io/spring-webflow/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>Maven依赖<br>maven库查询推荐地址：<a href=\"http://mvnrepository.com/\" target=\"_blank\" rel=\"noopener\">http://mvnrepository.com/</a></li>\n</ol>\n</blockquote><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.webflow&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-webflow&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.4.5.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>","more":"\n\n\n<h1 id=\"Web-Flow嵌入到Spring-MVC工作流简介\"><a href=\"#Web-Flow嵌入到Spring-MVC工作流简介\" class=\"headerlink\" title=\"Web Flow嵌入到Spring MVC工作流简介\"></a>Web Flow嵌入到Spring MVC工作流简介</h1><p>请求被DispatcherServlet拦截 -&gt; 分发flow进行处理，返回view -&gt; viewResolver解析 -&gt; 返回请求</p>\n<hr>\n<h1 id=\"配置项预览\"><a href=\"#配置项预览\" class=\"headerlink\" title=\"配置项预览\"></a>配置项预览</h1><ul>\n    <li>FlowRegistry：必须，注册流程，指明流程配置文件所在位置；指定流程id(用于请求访问标识)；指定流程属性；此外还可以传入FlowBuilderServices进行更多个性化配置</li>\n    <li>FlowBuilderServices：必须，用于设定流程配置文件中EL表达式的解析器、form属性绑定时的转换器、view-state的view解析器等，很重要</li>\n    <li>FlowExecutor：必须，用于执行流程，可指定执行监听器(可选，常用于流程安全和持久化)</li>\n    <li>FlowHandlerAdapter：必须，用于适配Spring MVC，配置时传入FlowExecutor</li>\n    <li>FlowHandlerMapping：必须，用于将请求映射到对应的flow，配置时传入FlowRegistry</li>\n</ul>\n\n<hr>\n<h1 id=\"配置I-注册流程-FlowRegistry\"><a href=\"#配置I-注册流程-FlowRegistry\" class=\"headerlink\" title=\"配置I - 注册流程 - FlowRegistry\"></a>配置I - 注册流程 - FlowRegistry</h1><p>FlowRegistry用于注册流程实例，指定流程位置和流程id，并可自定义流程创建相关内容</p>\n<h2 id=\"注册flow的各种方式\"><a href=\"#注册flow的各种方式\" class=\"headerlink\" title=\"注册flow的各种方式\"></a>注册flow的各种方式</h2><ul>\n<li><p>直接指定流程位置<br>默认情况下，web-flow的id为其文件名减去后缀名，如下配置的id为booking。指定了基地址或使用了通配符时除外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">// 注册了一个路径为/WEB-INF/flows/booking/booking.xml的流程，其余为默认配置。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义id</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; id=&quot;bookHotel&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>定义流程属性<br>如下定义了一个带有属性caption，其值为”Books a hotel”的流程。属性的使用方法暂时不了解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-definition-attributes&gt;</span><br><span class=\"line\">        &lt;webflow:attribute name=&quot;caption&quot; value=&quot;Books a hotel&quot; /&gt;</span><br><span class=\"line\">    &lt;/webflow:flow-definition-attributes&gt;</span><br><span class=\"line\">&lt;/webflow:flow-location&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用通配定义流程位置</li>\n</ul>\n</li>\n</ul>\n<p><strong>使用该方法并没有正确实验出id</strong>，这点作为参考</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-location-pattern value=&quot;/WEB-INF/flows/**/*-flow.xml&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用基地址<br>使用基地址的flow的id为其path属性减去文件名，如下配置的id为/hotels/booking；如果path中没有路径信息，只有文件名，则id为文件名减去后缀。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; base-path=&quot;/WEB-INF&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-location path=&quot;/hotels/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"flow-id属性总结\"><a href=\"#flow-id属性总结\" class=\"headerlink\" title=\"flow id属性总结\"></a>flow id属性总结</h2><ol>\n<li>id的作用<br>id用于请求定位到某个确切的flow，如当请求路径为<a href=\"http://localhost:8090/Floyd/search-flow，其中Floyd是项目名，如果有id为search-flow的flow存在，则会访问该flow\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/Floyd/search-flow，其中Floyd是项目名，如果有id为search-flow的flow存在，则会访问该flow</a></li>\n<li>id的定义<ul>\n<li>没有基地址或通配符时，flow的id为文件名减去后缀，如<code>&lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</code>这里的id为booking</li>\n<li>有基地址时，id为path的值减去文件名，如基地址为<code>/WEB-INF</code>， path=<code>/flows/booking/booking.xml</code>时，id被确定为<code>flows/booking</code></li>\n<li>有通配符时，该情况比较特殊，按照<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#flow-registry-base-path\" target=\"_blank\" rel=\"noopener\">官方说明</a>并没有验证通过，这里略过。<br>当显式指定了id属性时，则使用指定的id。<b>推荐自定义id</b><h2 id=\"FlowRegistry继承\"><a href=\"#FlowRegistry继承\" class=\"headerlink\" title=\"FlowRegistry继承\"></a>FlowRegistry继承</h2>FlowRegistry是可以继承的，可以定义一个公用的注册器，在多个子注册器中继承该注册器</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- my-system-config.xml --&gt;</span><br><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; parent=&quot;sharedFlowRegistry&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- shared-config.xml --&gt;</span><br><span class=\"line\">&lt;webflow:flow-registry id=&quot;sharedFlowRegistry&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Global flows shared by several applications --&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置II-使用FlowBuilder-services\"><a href=\"#配置II-使用FlowBuilder-services\" class=\"headerlink\" title=\"配置II - 使用FlowBuilder services\"></a>配置II - 使用FlowBuilder services</h1><p>使用FlowBuilder Services可以在build流程时自定义服务，比如视图解析器、EL表达式解析器、类型格式化和转换服务等。如无显式设定FlowBuilder Services，系统将使用默认实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-location path=&quot;/WEB-INF/flows/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot;</span><br><span class=\"line\">    conversion-service=&quot;conversionService&quot;</span><br><span class=\"line\">    expression-parser=&quot;expressionParser&quot;</span><br><span class=\"line\">    view-factory-creator=&quot;viewFactoryCreator&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;conversionService&quot; class=&quot;...&quot; /&gt;</span><br><span class=\"line\">&lt;bean id=&quot;expressionParser&quot; class=&quot;...&quot; /&gt;</span><br><span class=\"line\">&lt;bean id=&quot;viewFactoryCreator&quot; class=&quot;...&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义视图解析器-view-factory-creator\"><a href=\"#自定义视图解析器-view-factory-creator\" class=\"headerlink\" title=\"自定义视图解析器 view-factory-creator\"></a>自定义视图解析器 view-factory-creator</h2><p>view-factory-creator用于视图解析工作，默认的creator可以支持Spring MVC支持的几种视图类型：JSP, Velocity，FreeMarker等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot;&gt;</span><br><span class=\"line\">\t&lt;webflow:location path=&quot;/WEB-INF/hotels/booking/booking.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-registry&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 尤其注意这里的development，设置为true时表示开启开发模式，该模式下会在flow定义改变时自动re-load，甚至flow中引用的resource bundle发生了变化都会热重载 --&gt;</span><br><span class=\"line\">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; view-factory-creator=&quot;mvcViewFactoryCreator&quot; development=&quot;true&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;mvcViewFactoryCreator&quot; class=&quot;org.springframework.webflow.mvc.builder.MvcViewFactoryCreator&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- myExistingViewResolverToUseForFlows就是我们常用的视图解析器，注意这里引用的是一个列表 --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;viewResolvers&quot; ref=&quot;myExistingViewResolverToUseForFlows&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">... ... </span><br><span class=\"line\">... ...</span><br><span class=\"line\">&lt;!-- 做验证时使用的是javaconfig的形式，这种形式并没有验证过 --&gt;</span><br><span class=\"line\">&lt;property name=&quot;myExistingViewResolverToUseForFlows&quot;&gt;</span><br><span class=\"line\">    &lt;list&gt;</span><br><span class=\"line\">        &lt;ref bean=&quot;viewResolver&quot; /&gt;</span><br><span class=\"line\">    &lt;/list&gt;</span><br><span class=\"line\">&lt;/property&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class=\"line\">   &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;/&gt;</span><br><span class=\"line\">   &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义表达式解析器-expression-parser\"><a href=\"#自定义表达式解析器-expression-parser\" class=\"headerlink\" title=\"自定义表达式解析器 expression-parser\"></a>自定义表达式解析器 expression-parser</h2><p>expression-parser用于定义表达式解析器，默认的解析器使用逻辑：当类路径下有Unified EL解析器时，则使用；没有时，则使用OGNL表达式解析器(官方文档在<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/el.html#el-unified-el\" target=\"_blank\" rel=\"noopener\">EL表达式</a>一章和<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/system-setup.html#builder-service-expression-parser\" target=\"_blank\" rel=\"noopener\">系统设置</a>一章关于默认表达式解析说法有出入，自己认为比较可信的是Spring Web Flow 2.1以后，默认使用Spring EL表达式解析器)。<br>下面是手动配置成Unified EL解析器的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-builder-services expression-parser=&quot;expressionParser&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;expressionParser&quot; class=&quot;org.springframework.webflow.expression.el.WebFlowELExpressionParser&quot;&gt;</span><br><span class=\"line\">    &lt;constructor-arg&gt;</span><br><span class=\"line\">        &lt;bean class=&quot;org.jboss.el.ExpressionFactoryImpl&quot; /&gt;</span><br><span class=\"line\">    &lt;/constructor-arg&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义类型转换器-conversion-service\"><a href=\"#自定义类型转换器-conversion-service\" class=\"headerlink\" title=\"自定义类型转换器 conversion-service\"></a>自定义类型转换器 conversion-service</h2><p> 详细内容参见本系列视图渲染相关章节或<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry id=&quot;flowRegistry&quot; flow-builder-services=&quot;flowBuilderServices&quot; ... /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; conversion-service=&quot;defaultConversionService&quot; ... /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;defaultConversionService&quot; class=&quot;org.springframework.binding.convert.service.DefaultConversionService&quot;&gt;</span><br><span class=\"line\">\t&lt;constructor-arg ref=&quot;applicationConversionSevice&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;applicationConversionService&quot; class=&quot;somepackage.ApplicationConversionServiceFactoryBean&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void installFormatters(FormatterRegistry registry) &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置III-发布流程执行器-FlowExecutor\"><a href=\"#配置III-发布流程执行器-FlowExecutor\" class=\"headerlink\" title=\"配置III - 发布流程执行器 - FlowExecutor\"></a>配置III - 发布流程执行器 - FlowExecutor</h1><p>FlowExecutor用于执行flow并管理flow执行过程，常见的自定义项有：设置监听器，监听流程执行过程并作出相应，如security监听器，用于监听并控制流程的访问权限；调整flow的部分持久化选项等。</p>\n<ul>\n<li>注册监听器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 这里是为特定的flow应用该监听器，当不设criteria属性时，将对所有flow应用 --&gt;</span><br><span class=\"line\">&lt;webflow:flow-execution-listeners&gt;</span><br><span class=\"line\">    &lt;webflow:listener ref=&quot;securityListener&quot; criteria=&quot;securedFlow1,securedFlow2&quot;/&gt;</span><br><span class=\"line\">&lt;/webflow:flow-execution-listeners&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>调整持久化参数<ul>\n<li>max-executions： 设定为每个用户保留的执行数(没错，就是执行数)，当超过该数量时，最先的那个执行会被清除。(这里的执行，我认为是一个新开的且处于激活状态下的flow实例)</li>\n<li>max-execution-snapshots： 设定每个执行保留的最大快照数。不允许保留时，设为0。允许无线保留时，设为-1。(快照用于浏览器的返回按钮)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-executor id=&quot;flowExecutor&quot; flow-registry=&quot;flowRegistry&quot;&gt;</span><br><span class=\"line\">    &lt;webflow:flow-execution-repository max-executions=&quot;5&quot; max-execution-snapshots=&quot;30&quot; /&gt;</span><br><span class=\"line\">&lt;/webflow:flow-executor&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"配置IV-Spring-MVC集成\"><a href=\"#配置IV-Spring-MVC集成\" class=\"headerlink\" title=\"配置IV - Spring MVC集成\"></a>配置IV - Spring MVC集成</h1><h2 id=\"基础配置（将请求转发给flow）\"><a href=\"#基础配置（将请求转发给flow）\" class=\"headerlink\" title=\"基础配置（将请求转发给flow）\"></a>基础配置（将请求转发给flow）</h2><ul>\n<li>Spring MVC基础配置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;servlet&gt;</span><br><span class=\"line\">\t&lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;</span><br><span class=\"line\">\t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class=\"line\">\t&lt;init-param&gt;</span><br><span class=\"line\">\t\t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class=\"line\">\t\t&lt;param-value&gt;/WEB-INF/web-application-config.xml&lt;/param-value&gt;</span><br><span class=\"line\">\t&lt;/init-param&gt;</span><br><span class=\"line\">&lt;/servlet&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">\t&lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;</span><br><span class=\"line\">\t&lt;!-- 不能使用类型/*的通配符进行匹配，否则会出现jsp不解析直接回发给浏览器的情况 --&gt;</span><br><span class=\"line\">\t&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class=\"line\">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"FlowHandlerAdapter\"><a href=\"#FlowHandlerAdapter\" class=\"headerlink\" title=\"FlowHandlerAdapter\"></a>FlowHandlerAdapter</h2><p>该步骤是使得Web Flow能够适配Spring MVC<br>当一个对flow的请求被接收到时，FlowHandlerAdapter会决定是启动一个全新的flow还是继续之前的流程(如从一个view-state跳转到下一个state就属于继续之前的流程)，继续之前的flow是需要在请求有相关信息才行。有关这一方面，web flow默认有如下设定：<br>&emsp;&emsp;1.Http请求参数在任何情况下都是可以使用的<br>&emsp;&emsp;2.当一个flow执行结束，且结束时没有想浏览器发送最后的响应时，默认的handler会尝试在同一个request中启动一个新的flow执行<br>&emsp;&emsp;3.除了NoSuchFlowExecutionException异常外，所有其它异常都会以冒泡的方式抛到Dispatcher中。这是因为默认的handler会尝试自动从该异常中恢复过来，恢复的方式是新开一个全新的flow执行<br>针对大多数设定，都可以通过实现FlowHandlerAdapter类的子类进行自定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Enables FlowHandler URL mapping --&gt;</span><br><span class=\"line\">&lt;bean class=&quot;org.springframework.webflow.mvc.servlet.FlowHandlerAdapter&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- flowExecutor就是前文声明的执行器 --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;flowExecutor&quot; ref=&quot;flowExecutor&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置V-FlowHandlerMapping\"><a href=\"#配置V-FlowHandlerMapping\" class=\"headerlink\" title=\"配置V - FlowHandlerMapping\"></a>配置V - FlowHandlerMapping</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Maps request paths to flows in the flowRegistry;</span><br><span class=\"line\">\te.g. a path of /hotels/booking looks for a flow with id &quot;hotels/booking&quot; --&gt;</span><br><span class=\"line\">&lt;bean class=&quot;org.springframework.webflow.mvc.servlet.FlowHandlerMapping&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- flowRegistry就是前文声明的注册器 --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;flowRegistry&quot; ref=&quot;flowRegistry&quot;/&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;order&quot; value=&quot;0&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p>有了Flow的基本配置和这里的两个Spring MVC的集成配置，请求就能够映射到flow中了。接下来就是写Flow了。想要快速上手的可忽略本文后面的内容，转而直接看本系列其它文章。</p>\n<hr>\n<h1 id=\"配置VI-实现自定义的FlowHandler\"><a href=\"#配置VI-实现自定义的FlowHandler\" class=\"headerlink\" title=\"配置VI - 实现自定义的FlowHandler\"></a>配置VI - 实现自定义的FlowHandler</h1><ul>\n<li><p>FlowHandler讲解<br>FlowHandler可用于自定义flow在HTTP Servlert环境中执行的方式，FlowHandler在FlowHandlerAdapter中被使用，主要负责如下内容：</p>\n<p>&emsp;&emsp;- 返回flow的id以用于执行该flow<br>&emsp;&emsp;- 在新流程开始时创建输入<br>&emsp;&emsp;- 在流程结束时处理流程的输出<br>&emsp;&emsp;- 在流程发生异常时，处理这些异常</p>\n<p>其主要方法如下：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface FlowHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getFlowId();</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic MutableAttributeMap createExecutionInputMap(HttpServletRequest request);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String handleExecutionOutcome(FlowExecutionOutcome outcome,</span><br><span class=\"line\">\t\tHttpServletRequest request, HttpServletResponse response);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String handleException(FlowException e,</span><br><span class=\"line\">\t\tHttpServletRequest request, HttpServletResponse response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> &emsp;&emsp;该接口的直接实现为AbstractFlowHandler，当我们想要自定义某个设定时，继承该抽象类并重写其中的方法即可。</p>\n<ul>\n<li>发布一个FlowHandler<br>一个FlowHandler负责一个flow，发布方式是在Spring环境中声明一个bean，该bean的name必须和我们想要处理的flow的id一致，配置好后，当方位该flow的id，则会定位到新发布的FlowHandler中，我们自定义的方法也就生效了。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 这里的BookingHandler只是一个例子，实际用时替换成我们自己的Handler --&gt;</span><br><span class=\"line\">&lt;bean name=&quot;hotels/booking&quot; class=&quot;org.springframework.webflow.samples.booking.BookingFlowHandler&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>着重讲一下FlowHandler中handleExecutionOutcome(…)方法<br>该方法用于处理flow结束时产生的FlowExecutionOutcome(系统自动产生)，我们常用它来在流程结束后进行重定向，比如</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BookingFlowHandler extends AbstractFlowHandler &#123;</span><br><span class=\"line\">\t// handlExecutionOutcome()方法返回的String代表的是重定向的地址</span><br><span class=\"line\">\tpublic String handleExecutionOutcome(FlowExecutionOutcome outcome,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\tHttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class=\"line\">\t\tif (outcome.getId().equals(&quot;bookingConfirmed&quot;)) &#123;</span><br><span class=\"line\">\t\t\treturn &quot;/booking/show&quot;;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn &quot;/hotels/index&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 当flow id为bookinConfirmed时，重定向到/booking/show，否则重定向到/hotels/index</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;默认情况下，该方法返回的地址是相关于当前Servlet的。但是我们也可以显式地指定一些前缀来扩展重定向的范围</p>\n<p> &emsp;&emsp; – <code>servletRelative</code>: - 相对于当前Servlet重定向<br>&emsp;&emsp; – <code>contextRelative</code>: - 相对于当前应用重定向<br>&emsp;&emsp; – <code>serverRelative</code>: - 相对于当前服务器的基地址重定向<br>&emsp;&emsp; – <code>http:// or https://</code> - 重定向到一个完整的URI地址</p>\n<p>&emsp;&emsp;相同的前缀同样适用于声明state时的view属性配上<code>externalRedirect</code>的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;end-state view=&quot;externalRedirect:http://springframework.org&quot;/&gt;</span><br><span class=\"line\">&lt;!-- 在流程结束时，跳转到spring首页 --&gt;</span><br></pre></td></tr></table></figure>\n\n<p>—————————————————–手动分割线——————————————————————————————</p>\n<h1 id=\"一个能用的配置-采用Java-config的方式配置\"><a href=\"#一个能用的配置-采用Java-config的方式配置\" class=\"headerlink\" title=\"一个能用的配置(采用Java config的方式配置)\"></a>一个能用的配置(采用Java config的方式配置)</h1><h2 id=\"WebInitializer（与web-xml作用类似）\"><a href=\"#WebInitializer（与web-xml作用类似）\" class=\"headerlink\" title=\"WebInitializer（与web.xml作用类似）\"></a>WebInitializer（与web.xml作用类似）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">\t\treturn null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">\t\treturn new Class&lt;?&gt;[] &#123;MainConfig.class, RegisterConfig.class&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected String[] getServletMappings() &#123;</span><br><span class=\"line\">\t\treturn new String[] &#123;&quot;/&quot;&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MainConfig（Spring的主要配置文件）\"><a href=\"#MainConfig（Spring的主要配置文件）\" class=\"headerlink\" title=\"MainConfig（Spring的主要配置文件）\"></a>MainConfig（Spring的主要配置文件）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableWebMvc</span><br><span class=\"line\">@ComponentScan(&quot;cn.floyd.pw&quot;)</span><br><span class=\"line\">public class MainConfig extends WebMvcConfigurerAdapter&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Bean(name=&quot;viewResolver&quot;)</span><br><span class=\"line\">\tpublic ViewResolver getViewResolver() &#123;</span><br><span class=\"line\">\t\tInternalResourceViewResolver resolver = new InternalResourceViewResolver();</span><br><span class=\"line\">\t\tresolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);</span><br><span class=\"line\">\t\tresolver.setSuffix(&quot;.jsp&quot;);</span><br><span class=\"line\">\t\treturn resolver;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">\tpublic MultipartResolver multipartResolver() throws IOException &#123;</span><br><span class=\"line\">\t    CommonsMultipartResolver resolver = new CommonsMultipartResolver();</span><br><span class=\"line\">\t    return resolver;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// enable the static resource</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</span><br><span class=\"line\">\t\tconfigurer.enable();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t@Bean</span><br><span class=\"line\">    public FlowHandlerAdapter flowHandlerAdapter(@Autowired FlowExecutor flowExecutor) &#123;</span><br><span class=\"line\">\t    System.out.println(&quot;init flowHandlerAdapter&quot;);</span><br><span class=\"line\">        FlowHandlerAdapter adapter = new FlowHandlerAdapter();</span><br><span class=\"line\">        adapter.setFlowExecutor(flowExecutor);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return adapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public FlowHandlerMapping flowHandlerMapping(@Autowired FlowDefinitionRegistry flowRegistry) &#123;</span><br><span class=\"line\">        System.out.println(&quot;init flowHandlerMapping&quot;);</span><br><span class=\"line\">        FlowHandlerMapping mapping = new FlowHandlerMapping();</span><br><span class=\"line\">        mapping.setOrder(0);</span><br><span class=\"line\">        mapping.setFlowRegistry(flowRegistry);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return mapping;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RegisterConfig（配置FlowRegister和flowExecutor）\"><a href=\"#RegisterConfig（配置FlowRegister和flowExecutor）\" class=\"headerlink\" title=\"RegisterConfig（配置FlowRegister和flowExecutor）\"></a>RegisterConfig（配置FlowRegister和flowExecutor）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RegisterConfig extends AbstractFlowConfiguration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 用于注册flow</span><br><span class=\"line\">    @Bean(&quot;flowRegistry&quot;)</span><br><span class=\"line\">    public FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        return getFlowDefinitionRegistryBuilder()</span><br><span class=\"line\">                .setBasePath(&quot;/WEB-INF/jsp/flow&quot;)</span><br><span class=\"line\">                .addFlowLocation(&quot;/config/search-flow.xml&quot;)</span><br><span class=\"line\">                .setFlowBuilderServices(flowBuilderServices)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator) &#123;</span><br><span class=\"line\">        return getFlowBuilderServicesBuilder()</span><br><span class=\"line\">                .setViewFactoryCreator(mvcViewFactoryCreator)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public MvcViewFactoryCreator mvcViewFactoryCreator(@Autowired ViewResolver viewResolver) &#123;</span><br><span class=\"line\">        MvcViewFactoryCreator creator = new MvcViewFactoryCreator();</span><br><span class=\"line\">        List&lt;ViewResolver&gt; list = new ArrayList&lt;ViewResolver&gt;();</span><br><span class=\"line\">        list.add(viewResolver);</span><br><span class=\"line\">        creator.setViewResolvers(list);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return creator;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public FlowExecutor flowExecutor(@Autowired FlowDefinitionRegistry flowRegistry) &#123;</span><br><span class=\"line\">        return getFlowExecutorBuilder(flowRegistry).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置时踩过的坑\"><a href=\"#配置时踩过的坑\" class=\"headerlink\" title=\"配置时踩过的坑\"></a>配置时踩过的坑</h1><h2 id=\"flow-id的坑\"><a href=\"#flow-id的坑\" class=\"headerlink\" title=\"flow id的坑\"></a>flow id的坑</h2><blockquote>\n<p>最开始对flow id的认识不够，导致不知道到底该如何定位到flow，其实访问方式就是  …/appName/flowId</p>\n<h4 id=\"Web-MVC-Environment-null-not-supported\"><a href=\"#Web-MVC-Environment-null-not-supported\" class=\"headerlink\" title=\"Web MVC Environment null not supported\"></a>Web MVC Environment null not supported</h4><p>启动时正常，访问flow时报异常java.lang.IllegalStateException: Web MVC Environment null not supported<br> 是在创建viewFactory时出错，由于我没有采用在config中声明bean的方式创建MvcViewFactoryCreator，因此出现找不到mvc环境的问题，原来是spring在自动检测并创建bean时，会同时设置该bean的环境，因此不能自己随意采用new的方式创建这些配置类</p>\n<h4 id=\"JSP文件不解析\"><a href=\"#JSP文件不解析\" class=\"headerlink\" title=\"JSP文件不解析\"></a>JSP文件不解析</h4><p>出现JSP文件不经过解析就直接传送给了浏览器的问题(对如下阐述的原理并不是很清楚)<br>url-pattern为”/*”时，能够匹配到任何路径，因此当controller返回.jsp文件时，也会被拦截，从而返回jsp源码(这里不是很理解，主要是跟自己认识的spring mvc处理流程有差别)。<br>url-pattern为”/“时，只能够匹配不带后缀的路径，因此jsp就不会被dispatcherServlet拦截，而是会被jspServlet拦截并处理。但是”/“在配置使能的情况下也能够拦截并允许静态资源的访问</p>\n</blockquote>\n"},{"title":"Spring Webflow - 第一个Flow","date":"2018-09-06T15:00:00.000Z","_content":"\n> 在学习每一门新语言时，第一个程序往往是Hello World。这里我们写一个非常简单的flow，使用常用标签，在深入讲解之前有一个感官上的认识\n\n# 需求说明\n假设有如下简单流程：要求程序启动，显式输入界面，用户输入信息后，点击提交按钮，后台查询数据库，然后显式查询结果界面，中间任何步骤出错，都重新返回输入界面，并显示错误信息。流程大体如下。\n<!-- more -->\n![需求流程图](20180906212548121.png)\n# 需求分析\n将上述需求分解：流程启动时，初始化输入界面的信息，渲染输入页面，用户点击提交按钮，后台验证输入信息的格式是否正确，验证失败则返回输入界面，验证成功则进行下一步查询数据库操作，查询完成后跳转到结果页面进行显示，流程结束。(请忽略如下流程中判断图示不标准的错误)\n![逻辑流程图](20180906213226568.png)\n# 运行前的基本配置\n首先需要将FlowRegistry，FlowExecutor，FlowHandlerAdapter，FlowHandlerMapping等项配置好。本文的采用了[Spring Web Flow 学习 —— 配置 - 001](https://www.zouguodong.top/2018/09/05/Spring%20Webflow%20-%20%E9%85%8D%E7%BD%AE/)的配置。\n# Flow文件\n如下配置文件讲解: \n\n - 流程启动时指定flowController的performInit()方法，并返回一个ModelMap类型的对象，分配flowScope作用域下的InitMap变量，将返回的对象赋予该变量；\n - 渲染/WEB-INF/jsp/flow/view/input.jsp，并将input界面中上传的参数与searchForm进行绑定，当触发submit事件时，跳转到validate状态\n - validate状态中，执行flowController的performValidate(searchForm)方法，返回success时跳转到result状态，返回fail时跳转到init状态，重新渲染input.jsp。\n - result状态，渲染result.jsp，渲染前，首先指定flowController的performSearch(searchForm)方法，该方法返回一个modelMap并分配给flashScope范围内的modelMap变量。在result界面，无论点击任何按键，只要是向flow在此提交请求，都会跳转到end状态，\n - end状态, 重定向到spring首页\n 至此，流程结束。\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- 这是web flow 2.4.5的根标签形式，2.5.0并不一样 -->\n<flow xmlns=\"http://www.springframework.org/schema/webflow\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/webflow\n                          http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd\">\n    \n    <var name=\"searchForm\" class=\"cn.floyd.pw.flow.SearchForm\"/>\n    \n    <on-start>\n        <evaluate expression=\"flowController.performInit()\" \n                result=\"flowScope.InitMap\" \n                result-type=\"org.springframework.ui.ModelMap\"/>\n    </on-start>\n    \n    <view-state id=\"init\" view=\"flow/view/input\" model=\"searchForm\">\n        <binder>\n            <binding property=\"name\"/>\n            <binding property=\"gender\"/>\n        </binder>\n        <transition on=\"submit\" to=\"validate\"/>\n    </view-state>\n\n    <action-state id=\"validate\">\n        <evaluate  expression=\"flowController.performValidate(searchForm)\"/>\n        <transition on=\"success\" to=\"result\"/>\n        <transition on=\"fail\" to=\"input\"/>\n    </action-state>\n\n    <view-state id=\"result\" view=\"flow/view/result\">\n        <on-render>\n            <evaluate expression=\"flowController.performSearch(searchForm)\" result=\"flashScope.modelMap\"/>\n        </on-render>\n        <transition to=\"end\"/>\n    </view-state>\n    \n    <end-state id=\"end\" view=\"externalRedirect:http://springframework.org\"/>\n</flow>\n```\n看完上面的描述，想必刚接触web flow的人是一脸懵逼\n![这里写图片描述](20180906215538433.jpeg)\n解释几个概念就好了。\n\n - 状态：web flow将一个步骤称作一个状态(state)，有专门渲染view的view-state，也有只执行操作的action-state\n - 变量：web flow是以xml的形式进行编程的，可以在该xml上下文中定义变量，该变量可以在flow上下文以及flow渲染的jsp文件(使用EL表达式调用)，调用的方法中(作为参数传入)使用。定义变量的方式主要有两种，一是通过`<var>`标签显式定义，二是在`<evaluate>`标签的`result`属性中定义(此时同时完成了分配变量和变量赋值两个操作)\n - 变量作用域：规定了变量的作用范围，常见的有flashScope(当前状态有效)，flowScope(当前flow有效)等\n - 事件：从一个状态到另一个状态，一般需要进行触发，而进行触发的就是事件。事件可能由view触发，也可能由方法触发，我们不用真的去定义一个事件对象。当view-state中的view返回的请求中带有_eventId的参数时，其值会被自动转换成Event，当action-state中调用的方法返回字符串时，该字符串也会被自动转换成Event\n - 模型绑定：当view需要提交参数时，可以采用模型绑定的形式，web flow会自动将对应参数绑定到我们的model中，并且还可以自定义验证和转换规则。\n\n# 相关其它文件\n## FlowController\n按照顺序列出相关文件，`<evaluate>`标签的`expression`属性可以通过Spring EL表达式的形式直接访问Spring管理的bean的方法或属性，也可以访问flow上下文环境中的对象的方法或属性。其中主要方法讲解如下：\n\n - `performInit()`初始化下拉选中的初始值，返回modelMap对象，该对象被赋值给flow中的InitMap变量\n - `performValidate(SearchForm form)`将SearchForm对象传入，用于验证输入的值，这里假设全都验证通过，返回的\"success\"会被映射成Event\n - `performSearch(SearchForm form)`根据传入form中的参数进行数据查找，这里假设已经查找完毕，并将数据放入一个ModelMap，赋值给flow中的modelMap变量\n\n该类是Spring管理的一个bean，\n```\n@Controller(\"flowController\")\npublic class FlowController implements Serializable{\n    \n    private static final long serialVersionUID = -4439633424434338888L;\n\n    public ModelMap performInit() {\n        ModelMap model = new ModelMap();\n        model.addAttribute(\"gender\", new String[] {\"Man\", \"Woman\"});\n        return model;\n    }\n    \n    public String performValidate(SearchForm form) {\n        // assume we have pass the validation\n        return \"success\";\n    }\n    \n    public ModelMap performSearch(SearchForm form) {\n        // assume we have finished the search process, and got the search result\n        ModelMap model = new ModelMap();\n        model.addAttribute(\"name\", form.getName());\n        model.addAttribute(\"gender\", form.getGender());\n        model.addAttribute(\"age\", 25);\n        model.addAttribute(\"profession\", \"Programmer\");\n        model.addAttribute(\"hobbies\", new String[] {\"Basktball\", \"Football\"});\n        \n        return model;\n    }\n}\n```\n## input.jsp\n输入界面，将`InitMap`中的值通过EL表达式渲染到下拉选中。通过`_eventId=submit`的GET参数方式触发submit事件。`${flowExecutionUrl}`是flow中自管理变量，访问它才能使得流程继续下去\n\n - 尤其需要注意的一个点是，在声明form时，一定要使用spring提供的taglib，否则会出现无法跳转到下一个state，无限回到第一个state的情况。\n```\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%>\n<%@ taglib uri=\"http://www.springframework.org/tags/form\" prefix=\"sf\" %>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Input page</title>\n\t</head>\n\t<body>\n\t\t<!-- commandName 声明该form需要绑定的model，与flow.xml中<view-state>声明的model是一个东西 -->\n\t   <sf:form action=\"${flowExecutionUrl}&_eventId=submit\" commandName=\"searchForm\" method=\"post\">\n\t       Name: <sf:input path=\"name\"/><br/>\n           gender:\n           <sf:select path=\"gender\">\n               <sf:option value=\"\">- Please Select -</sf:option>\n               <c:forEach items=\"${InitMap.gender }\" var=\"gender\">\n                   <sf:option value=\"${gender }\">${gender }</sf:option>\n               </c:forEach>\n           </sf:select>\n           <input type=\"submit\" value=\"Submit\">\n\t   </sf:form>\n\t</body>\n</html>\n```\n\n## SearchForm\nform，与input.jsp中的form参数对应，注意必须要实现序列化接口。\n```\npublic class SearchForm implements Serializable {\n\n    private String name;\n    private String gender;\n\n    ... ...\n}\n\n```\n\n## result.jsp\n将flow中的`modelMap`变量渲染到页面中\n```\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Result Page</title>\n\t</head>\n\t<body>\n\t    Name: ${modelMap.name } <br/>\n\t    Gender: ${modelMap.gender } <br/>\n\t    Age: ${modelMap.age } <br/>\n\t    profession: ${modelMap.profession } <br/>\n\t    hobbies: \n        <c:forEach items=\"${modelMap.hobbies }\" var=\"hobby\">\n            ${hobby } &ensp;\n        </c:forEach>\n        <br/>\n\t</body>\n</html>\n```\n\n# 调试中遇到的坑\n\n - 现象\n点击form的submit按钮，无法跳转到下一个state，始终重新渲染input界面；定义一个`<a href=\"${flowExecutionUrl}&_eventId=submit\">`标签，能够正常跳转到下一个state\n - 原因\n使用了原生的html标签`<form>`进行表单的声明，导致web flow无法继续工作，改用Spring标签即可。\nWeb Flow无法工作的具体原理尚不明晰，我是在参考公司已有项目时发现这个问题的。\n - 解决方案\n使用Spring官方提供的taglib进行form及其属性的声明。","source":"_posts/Spring-Webflow-第一个Flow.md","raw":"---\ntitle: Spring Webflow - 第一个Flow\ndate: 2018-09-06 23:00:00\ntags: \n    - Spring\n    - Webflow\ncategories: \n    - Spring Webflow\n---\n\n> 在学习每一门新语言时，第一个程序往往是Hello World。这里我们写一个非常简单的flow，使用常用标签，在深入讲解之前有一个感官上的认识\n\n# 需求说明\n假设有如下简单流程：要求程序启动，显式输入界面，用户输入信息后，点击提交按钮，后台查询数据库，然后显式查询结果界面，中间任何步骤出错，都重新返回输入界面，并显示错误信息。流程大体如下。\n<!-- more -->\n![需求流程图](20180906212548121.png)\n# 需求分析\n将上述需求分解：流程启动时，初始化输入界面的信息，渲染输入页面，用户点击提交按钮，后台验证输入信息的格式是否正确，验证失败则返回输入界面，验证成功则进行下一步查询数据库操作，查询完成后跳转到结果页面进行显示，流程结束。(请忽略如下流程中判断图示不标准的错误)\n![逻辑流程图](20180906213226568.png)\n# 运行前的基本配置\n首先需要将FlowRegistry，FlowExecutor，FlowHandlerAdapter，FlowHandlerMapping等项配置好。本文的采用了[Spring Web Flow 学习 —— 配置 - 001](https://www.zouguodong.top/2018/09/05/Spring%20Webflow%20-%20%E9%85%8D%E7%BD%AE/)的配置。\n# Flow文件\n如下配置文件讲解: \n\n - 流程启动时指定flowController的performInit()方法，并返回一个ModelMap类型的对象，分配flowScope作用域下的InitMap变量，将返回的对象赋予该变量；\n - 渲染/WEB-INF/jsp/flow/view/input.jsp，并将input界面中上传的参数与searchForm进行绑定，当触发submit事件时，跳转到validate状态\n - validate状态中，执行flowController的performValidate(searchForm)方法，返回success时跳转到result状态，返回fail时跳转到init状态，重新渲染input.jsp。\n - result状态，渲染result.jsp，渲染前，首先指定flowController的performSearch(searchForm)方法，该方法返回一个modelMap并分配给flashScope范围内的modelMap变量。在result界面，无论点击任何按键，只要是向flow在此提交请求，都会跳转到end状态，\n - end状态, 重定向到spring首页\n 至此，流程结束。\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- 这是web flow 2.4.5的根标签形式，2.5.0并不一样 -->\n<flow xmlns=\"http://www.springframework.org/schema/webflow\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/webflow\n                          http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd\">\n    \n    <var name=\"searchForm\" class=\"cn.floyd.pw.flow.SearchForm\"/>\n    \n    <on-start>\n        <evaluate expression=\"flowController.performInit()\" \n                result=\"flowScope.InitMap\" \n                result-type=\"org.springframework.ui.ModelMap\"/>\n    </on-start>\n    \n    <view-state id=\"init\" view=\"flow/view/input\" model=\"searchForm\">\n        <binder>\n            <binding property=\"name\"/>\n            <binding property=\"gender\"/>\n        </binder>\n        <transition on=\"submit\" to=\"validate\"/>\n    </view-state>\n\n    <action-state id=\"validate\">\n        <evaluate  expression=\"flowController.performValidate(searchForm)\"/>\n        <transition on=\"success\" to=\"result\"/>\n        <transition on=\"fail\" to=\"input\"/>\n    </action-state>\n\n    <view-state id=\"result\" view=\"flow/view/result\">\n        <on-render>\n            <evaluate expression=\"flowController.performSearch(searchForm)\" result=\"flashScope.modelMap\"/>\n        </on-render>\n        <transition to=\"end\"/>\n    </view-state>\n    \n    <end-state id=\"end\" view=\"externalRedirect:http://springframework.org\"/>\n</flow>\n```\n看完上面的描述，想必刚接触web flow的人是一脸懵逼\n![这里写图片描述](20180906215538433.jpeg)\n解释几个概念就好了。\n\n - 状态：web flow将一个步骤称作一个状态(state)，有专门渲染view的view-state，也有只执行操作的action-state\n - 变量：web flow是以xml的形式进行编程的，可以在该xml上下文中定义变量，该变量可以在flow上下文以及flow渲染的jsp文件(使用EL表达式调用)，调用的方法中(作为参数传入)使用。定义变量的方式主要有两种，一是通过`<var>`标签显式定义，二是在`<evaluate>`标签的`result`属性中定义(此时同时完成了分配变量和变量赋值两个操作)\n - 变量作用域：规定了变量的作用范围，常见的有flashScope(当前状态有效)，flowScope(当前flow有效)等\n - 事件：从一个状态到另一个状态，一般需要进行触发，而进行触发的就是事件。事件可能由view触发，也可能由方法触发，我们不用真的去定义一个事件对象。当view-state中的view返回的请求中带有_eventId的参数时，其值会被自动转换成Event，当action-state中调用的方法返回字符串时，该字符串也会被自动转换成Event\n - 模型绑定：当view需要提交参数时，可以采用模型绑定的形式，web flow会自动将对应参数绑定到我们的model中，并且还可以自定义验证和转换规则。\n\n# 相关其它文件\n## FlowController\n按照顺序列出相关文件，`<evaluate>`标签的`expression`属性可以通过Spring EL表达式的形式直接访问Spring管理的bean的方法或属性，也可以访问flow上下文环境中的对象的方法或属性。其中主要方法讲解如下：\n\n - `performInit()`初始化下拉选中的初始值，返回modelMap对象，该对象被赋值给flow中的InitMap变量\n - `performValidate(SearchForm form)`将SearchForm对象传入，用于验证输入的值，这里假设全都验证通过，返回的\"success\"会被映射成Event\n - `performSearch(SearchForm form)`根据传入form中的参数进行数据查找，这里假设已经查找完毕，并将数据放入一个ModelMap，赋值给flow中的modelMap变量\n\n该类是Spring管理的一个bean，\n```\n@Controller(\"flowController\")\npublic class FlowController implements Serializable{\n    \n    private static final long serialVersionUID = -4439633424434338888L;\n\n    public ModelMap performInit() {\n        ModelMap model = new ModelMap();\n        model.addAttribute(\"gender\", new String[] {\"Man\", \"Woman\"});\n        return model;\n    }\n    \n    public String performValidate(SearchForm form) {\n        // assume we have pass the validation\n        return \"success\";\n    }\n    \n    public ModelMap performSearch(SearchForm form) {\n        // assume we have finished the search process, and got the search result\n        ModelMap model = new ModelMap();\n        model.addAttribute(\"name\", form.getName());\n        model.addAttribute(\"gender\", form.getGender());\n        model.addAttribute(\"age\", 25);\n        model.addAttribute(\"profession\", \"Programmer\");\n        model.addAttribute(\"hobbies\", new String[] {\"Basktball\", \"Football\"});\n        \n        return model;\n    }\n}\n```\n## input.jsp\n输入界面，将`InitMap`中的值通过EL表达式渲染到下拉选中。通过`_eventId=submit`的GET参数方式触发submit事件。`${flowExecutionUrl}`是flow中自管理变量，访问它才能使得流程继续下去\n\n - 尤其需要注意的一个点是，在声明form时，一定要使用spring提供的taglib，否则会出现无法跳转到下一个state，无限回到第一个state的情况。\n```\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%>\n<%@ taglib uri=\"http://www.springframework.org/tags/form\" prefix=\"sf\" %>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Input page</title>\n\t</head>\n\t<body>\n\t\t<!-- commandName 声明该form需要绑定的model，与flow.xml中<view-state>声明的model是一个东西 -->\n\t   <sf:form action=\"${flowExecutionUrl}&_eventId=submit\" commandName=\"searchForm\" method=\"post\">\n\t       Name: <sf:input path=\"name\"/><br/>\n           gender:\n           <sf:select path=\"gender\">\n               <sf:option value=\"\">- Please Select -</sf:option>\n               <c:forEach items=\"${InitMap.gender }\" var=\"gender\">\n                   <sf:option value=\"${gender }\">${gender }</sf:option>\n               </c:forEach>\n           </sf:select>\n           <input type=\"submit\" value=\"Submit\">\n\t   </sf:form>\n\t</body>\n</html>\n```\n\n## SearchForm\nform，与input.jsp中的form参数对应，注意必须要实现序列化接口。\n```\npublic class SearchForm implements Serializable {\n\n    private String name;\n    private String gender;\n\n    ... ...\n}\n\n```\n\n## result.jsp\n将flow中的`modelMap`变量渲染到页面中\n```\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<title>Result Page</title>\n\t</head>\n\t<body>\n\t    Name: ${modelMap.name } <br/>\n\t    Gender: ${modelMap.gender } <br/>\n\t    Age: ${modelMap.age } <br/>\n\t    profession: ${modelMap.profession } <br/>\n\t    hobbies: \n        <c:forEach items=\"${modelMap.hobbies }\" var=\"hobby\">\n            ${hobby } &ensp;\n        </c:forEach>\n        <br/>\n\t</body>\n</html>\n```\n\n# 调试中遇到的坑\n\n - 现象\n点击form的submit按钮，无法跳转到下一个state，始终重新渲染input界面；定义一个`<a href=\"${flowExecutionUrl}&_eventId=submit\">`标签，能够正常跳转到下一个state\n - 原因\n使用了原生的html标签`<form>`进行表单的声明，导致web flow无法继续工作，改用Spring标签即可。\nWeb Flow无法工作的具体原理尚不明晰，我是在参考公司已有项目时发现这个问题的。\n - 解决方案\n使用Spring官方提供的taglib进行form及其属性的声明。","slug":"Spring-Webflow-第一个Flow","published":1,"updated":"2019-09-08T10:17:29.114Z","_id":"ck0atmo9c000i00bn1wocenn3","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>在学习每一门新语言时，第一个程序往往是Hello World。这里我们写一个非常简单的flow，使用常用标签，在深入讲解之前有一个感官上的认识</p>\n</blockquote>\n<h1 id=\"需求说明\"><a href=\"#需求说明\" class=\"headerlink\" title=\"需求说明\"></a>需求说明</h1><p>假设有如下简单流程：要求程序启动，显式输入界面，用户输入信息后，点击提交按钮，后台查询数据库，然后显式查询结果界面，中间任何步骤出错，都重新返回输入界面，并显示错误信息。流程大体如下。</p>\n<a id=\"more\"></a>\n<p><img src=\"20180906212548121.png\" alt=\"需求流程图\"></p>\n<h1 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h1><p>将上述需求分解：流程启动时，初始化输入界面的信息，渲染输入页面，用户点击提交按钮，后台验证输入信息的格式是否正确，验证失败则返回输入界面，验证成功则进行下一步查询数据库操作，查询完成后跳转到结果页面进行显示，流程结束。(请忽略如下流程中判断图示不标准的错误)<br><img src=\"20180906213226568.png\" alt=\"逻辑流程图\"></p>\n<h1 id=\"运行前的基本配置\"><a href=\"#运行前的基本配置\" class=\"headerlink\" title=\"运行前的基本配置\"></a>运行前的基本配置</h1><p>首先需要将FlowRegistry，FlowExecutor，FlowHandlerAdapter，FlowHandlerMapping等项配置好。本文的采用了<a href=\"https://www.zouguodong.top/2018/09/05/Spring%20Webflow%20-%20%E9%85%8D%E7%BD%AE/\">Spring Web Flow 学习 —— 配置 - 001</a>的配置。</p>\n<h1 id=\"Flow文件\"><a href=\"#Flow文件\" class=\"headerlink\" title=\"Flow文件\"></a>Flow文件</h1><p>如下配置文件讲解: </p>\n<ul>\n<li>流程启动时指定flowController的performInit()方法，并返回一个ModelMap类型的对象，分配flowScope作用域下的InitMap变量，将返回的对象赋予该变量；</li>\n<li>渲染/WEB-INF/jsp/flow/view/input.jsp，并将input界面中上传的参数与searchForm进行绑定，当触发submit事件时，跳转到validate状态</li>\n<li>validate状态中，执行flowController的performValidate(searchForm)方法，返回success时跳转到result状态，返回fail时跳转到init状态，重新渲染input.jsp。</li>\n<li>result状态，渲染result.jsp，渲染前，首先指定flowController的performSearch(searchForm)方法，该方法返回一个modelMap并分配给flashScope范围内的modelMap变量。在result界面，无论点击任何按键，只要是向flow在此提交请求，都会跳转到end状态，</li>\n<li>end状态, 重定向到spring首页<br>至此，流程结束。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!-- 这是web flow 2.4.5的根标签形式，2.5.0并不一样 --&gt;</span><br><span class=\"line\">&lt;flow xmlns=&quot;http://www.springframework.org/schema/webflow&quot;</span><br><span class=\"line\">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/webflow</span><br><span class=\"line\">                          http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd&quot;&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;var name=&quot;searchForm&quot; class=&quot;cn.floyd.pw.flow.SearchForm&quot;/&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;on-start&gt;</span><br><span class=\"line\">        &lt;evaluate expression=&quot;flowController.performInit()&quot; </span><br><span class=\"line\">                result=&quot;flowScope.InitMap&quot; </span><br><span class=\"line\">                result-type=&quot;org.springframework.ui.ModelMap&quot;/&gt;</span><br><span class=\"line\">    &lt;/on-start&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot; model=&quot;searchForm&quot;&gt;</span><br><span class=\"line\">        &lt;binder&gt;</span><br><span class=\"line\">            &lt;binding property=&quot;name&quot;/&gt;</span><br><span class=\"line\">            &lt;binding property=&quot;gender&quot;/&gt;</span><br><span class=\"line\">        &lt;/binder&gt;</span><br><span class=\"line\">        &lt;transition on=&quot;submit&quot; to=&quot;validate&quot;/&gt;</span><br><span class=\"line\">    &lt;/view-state&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">        &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class=\"line\">        &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class=\"line\">        &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class=\"line\">    &lt;/action-state&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;view-state id=&quot;result&quot; view=&quot;flow/view/result&quot;&gt;</span><br><span class=\"line\">        &lt;on-render&gt;</span><br><span class=\"line\">            &lt;evaluate expression=&quot;flowController.performSearch(searchForm)&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class=\"line\">        &lt;/on-render&gt;</span><br><span class=\"line\">        &lt;transition to=&quot;end&quot;/&gt;</span><br><span class=\"line\">    &lt;/view-state&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;end-state id=&quot;end&quot; view=&quot;externalRedirect:http://springframework.org&quot;/&gt;</span><br><span class=\"line\">&lt;/flow&gt;</span><br></pre></td></tr></table></figure>\n\n<p>看完上面的描述，想必刚接触web flow的人是一脸懵逼<br><img src=\"20180906215538433.jpeg\" alt=\"这里写图片描述\"><br>解释几个概念就好了。</p>\n<ul>\n<li>状态：web flow将一个步骤称作一个状态(state)，有专门渲染view的view-state，也有只执行操作的action-state</li>\n<li>变量：web flow是以xml的形式进行编程的，可以在该xml上下文中定义变量，该变量可以在flow上下文以及flow渲染的jsp文件(使用EL表达式调用)，调用的方法中(作为参数传入)使用。定义变量的方式主要有两种，一是通过<code>&lt;var&gt;</code>标签显式定义，二是在<code>&lt;evaluate&gt;</code>标签的<code>result</code>属性中定义(此时同时完成了分配变量和变量赋值两个操作)</li>\n<li>变量作用域：规定了变量的作用范围，常见的有flashScope(当前状态有效)，flowScope(当前flow有效)等</li>\n<li>事件：从一个状态到另一个状态，一般需要进行触发，而进行触发的就是事件。事件可能由view触发，也可能由方法触发，我们不用真的去定义一个事件对象。当view-state中的view返回的请求中带有_eventId的参数时，其值会被自动转换成Event，当action-state中调用的方法返回字符串时，该字符串也会被自动转换成Event</li>\n<li>模型绑定：当view需要提交参数时，可以采用模型绑定的形式，web flow会自动将对应参数绑定到我们的model中，并且还可以自定义验证和转换规则。</li>\n</ul>\n<h1 id=\"相关其它文件\"><a href=\"#相关其它文件\" class=\"headerlink\" title=\"相关其它文件\"></a>相关其它文件</h1><h2 id=\"FlowController\"><a href=\"#FlowController\" class=\"headerlink\" title=\"FlowController\"></a>FlowController</h2><p>按照顺序列出相关文件，<code>&lt;evaluate&gt;</code>标签的<code>expression</code>属性可以通过Spring EL表达式的形式直接访问Spring管理的bean的方法或属性，也可以访问flow上下文环境中的对象的方法或属性。其中主要方法讲解如下：</p>\n<ul>\n<li><code>performInit()</code>初始化下拉选中的初始值，返回modelMap对象，该对象被赋值给flow中的InitMap变量</li>\n<li><code>performValidate(SearchForm form)</code>将SearchForm对象传入，用于验证输入的值，这里假设全都验证通过，返回的”success”会被映射成Event</li>\n<li><code>performSearch(SearchForm form)</code>根据传入form中的参数进行数据查找，这里假设已经查找完毕，并将数据放入一个ModelMap，赋值给flow中的modelMap变量</li>\n</ul>\n<p>该类是Spring管理的一个bean，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller(&quot;flowController&quot;)</span><br><span class=\"line\">public class FlowController implements Serializable&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private static final long serialVersionUID = -4439633424434338888L;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ModelMap performInit() &#123;</span><br><span class=\"line\">        ModelMap model = new ModelMap();</span><br><span class=\"line\">        model.addAttribute(&quot;gender&quot;, new String[] &#123;&quot;Man&quot;, &quot;Woman&quot;&#125;);</span><br><span class=\"line\">        return model;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public String performValidate(SearchForm form) &#123;</span><br><span class=\"line\">        // assume we have pass the validation</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public ModelMap performSearch(SearchForm form) &#123;</span><br><span class=\"line\">        // assume we have finished the search process, and got the search result</span><br><span class=\"line\">        ModelMap model = new ModelMap();</span><br><span class=\"line\">        model.addAttribute(&quot;name&quot;, form.getName());</span><br><span class=\"line\">        model.addAttribute(&quot;gender&quot;, form.getGender());</span><br><span class=\"line\">        model.addAttribute(&quot;age&quot;, 25);</span><br><span class=\"line\">        model.addAttribute(&quot;profession&quot;, &quot;Programmer&quot;);</span><br><span class=\"line\">        model.addAttribute(&quot;hobbies&quot;, new String[] &#123;&quot;Basktball&quot;, &quot;Football&quot;&#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return model;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"input-jsp\"><a href=\"#input-jsp\" class=\"headerlink\" title=\"input.jsp\"></a>input.jsp</h2><p>输入界面，将<code>InitMap</code>中的值通过EL表达式渲染到下拉选中。通过<code>_eventId=submit</code>的GET参数方式触发submit事件。<code>${flowExecutionUrl}</code>是flow中自管理变量，访问它才能使得流程继续下去</p>\n<ul>\n<li>尤其需要注意的一个点是，在声明form时，一定要使用spring提供的taglib，否则会出现无法跳转到下一个state，无限回到第一个state的情况。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; prefix=&quot;fn&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;sf&quot; %&gt;</span><br><span class=\"line\">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;Input page&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;!-- commandName 声明该form需要绑定的model，与flow.xml中&lt;view-state&gt;声明的model是一个东西 --&gt;</span><br><span class=\"line\">\t   &lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">\t       Name: &lt;sf:input path=&quot;name&quot;/&gt;&lt;br/&gt;</span><br><span class=\"line\">           gender:</span><br><span class=\"line\">           &lt;sf:select path=&quot;gender&quot;&gt;</span><br><span class=\"line\">               &lt;sf:option value=&quot;&quot;&gt;- Please Select -&lt;/sf:option&gt;</span><br><span class=\"line\">               &lt;c:forEach items=&quot;$&#123;InitMap.gender &#125;&quot; var=&quot;gender&quot;&gt;</span><br><span class=\"line\">                   &lt;sf:option value=&quot;$&#123;gender &#125;&quot;&gt;$&#123;gender &#125;&lt;/sf:option&gt;</span><br><span class=\"line\">               &lt;/c:forEach&gt;</span><br><span class=\"line\">           &lt;/sf:select&gt;</span><br><span class=\"line\">           &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class=\"line\">\t   &lt;/sf:form&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"SearchForm\"><a href=\"#SearchForm\" class=\"headerlink\" title=\"SearchForm\"></a>SearchForm</h2><p>form，与input.jsp中的form参数对应，注意必须要实现序列化接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SearchForm implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"result-jsp\"><a href=\"#result-jsp\" class=\"headerlink\" title=\"result.jsp\"></a>result.jsp</h2><p>将flow中的<code>modelMap</code>变量渲染到页面中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; prefix=&quot;fn&quot;%&gt;</span><br><span class=\"line\">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;Result Page&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t    Name: $&#123;modelMap.name &#125; &lt;br/&gt;</span><br><span class=\"line\">\t    Gender: $&#123;modelMap.gender &#125; &lt;br/&gt;</span><br><span class=\"line\">\t    Age: $&#123;modelMap.age &#125; &lt;br/&gt;</span><br><span class=\"line\">\t    profession: $&#123;modelMap.profession &#125; &lt;br/&gt;</span><br><span class=\"line\">\t    hobbies: </span><br><span class=\"line\">        &lt;c:forEach items=&quot;$&#123;modelMap.hobbies &#125;&quot; var=&quot;hobby&quot;&gt;</span><br><span class=\"line\">            $&#123;hobby &#125; &amp;ensp;</span><br><span class=\"line\">        &lt;/c:forEach&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"调试中遇到的坑\"><a href=\"#调试中遇到的坑\" class=\"headerlink\" title=\"调试中遇到的坑\"></a>调试中遇到的坑</h1><ul>\n<li>现象<br>点击form的submit按钮，无法跳转到下一个state，始终重新渲染input界面；定义一个<code>&lt;a href=&quot;${flowExecutionUrl}&amp;_eventId=submit&quot;&gt;</code>标签，能够正常跳转到下一个state</li>\n<li>原因<br>使用了原生的html标签<code>&lt;form&gt;</code>进行表单的声明，导致web flow无法继续工作，改用Spring标签即可。<br>Web Flow无法工作的具体原理尚不明晰，我是在参考公司已有项目时发现这个问题的。</li>\n<li>解决方案<br>使用Spring官方提供的taglib进行form及其属性的声明。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在学习每一门新语言时，第一个程序往往是Hello World。这里我们写一个非常简单的flow，使用常用标签，在深入讲解之前有一个感官上的认识</p>\n</blockquote>\n<h1 id=\"需求说明\"><a href=\"#需求说明\" class=\"headerlink\" title=\"需求说明\"></a>需求说明</h1><p>假设有如下简单流程：要求程序启动，显式输入界面，用户输入信息后，点击提交按钮，后台查询数据库，然后显式查询结果界面，中间任何步骤出错，都重新返回输入界面，并显示错误信息。流程大体如下。</p>","more":"<p><img src=\"20180906212548121.png\" alt=\"需求流程图\"></p>\n<h1 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h1><p>将上述需求分解：流程启动时，初始化输入界面的信息，渲染输入页面，用户点击提交按钮，后台验证输入信息的格式是否正确，验证失败则返回输入界面，验证成功则进行下一步查询数据库操作，查询完成后跳转到结果页面进行显示，流程结束。(请忽略如下流程中判断图示不标准的错误)<br><img src=\"20180906213226568.png\" alt=\"逻辑流程图\"></p>\n<h1 id=\"运行前的基本配置\"><a href=\"#运行前的基本配置\" class=\"headerlink\" title=\"运行前的基本配置\"></a>运行前的基本配置</h1><p>首先需要将FlowRegistry，FlowExecutor，FlowHandlerAdapter，FlowHandlerMapping等项配置好。本文的采用了<a href=\"https://www.zouguodong.top/2018/09/05/Spring%20Webflow%20-%20%E9%85%8D%E7%BD%AE/\">Spring Web Flow 学习 —— 配置 - 001</a>的配置。</p>\n<h1 id=\"Flow文件\"><a href=\"#Flow文件\" class=\"headerlink\" title=\"Flow文件\"></a>Flow文件</h1><p>如下配置文件讲解: </p>\n<ul>\n<li>流程启动时指定flowController的performInit()方法，并返回一个ModelMap类型的对象，分配flowScope作用域下的InitMap变量，将返回的对象赋予该变量；</li>\n<li>渲染/WEB-INF/jsp/flow/view/input.jsp，并将input界面中上传的参数与searchForm进行绑定，当触发submit事件时，跳转到validate状态</li>\n<li>validate状态中，执行flowController的performValidate(searchForm)方法，返回success时跳转到result状态，返回fail时跳转到init状态，重新渲染input.jsp。</li>\n<li>result状态，渲染result.jsp，渲染前，首先指定flowController的performSearch(searchForm)方法，该方法返回一个modelMap并分配给flashScope范围内的modelMap变量。在result界面，无论点击任何按键，只要是向flow在此提交请求，都会跳转到end状态，</li>\n<li>end状态, 重定向到spring首页<br>至此，流程结束。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!-- 这是web flow 2.4.5的根标签形式，2.5.0并不一样 --&gt;</span><br><span class=\"line\">&lt;flow xmlns=&quot;http://www.springframework.org/schema/webflow&quot;</span><br><span class=\"line\">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/webflow</span><br><span class=\"line\">                          http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd&quot;&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;var name=&quot;searchForm&quot; class=&quot;cn.floyd.pw.flow.SearchForm&quot;/&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;on-start&gt;</span><br><span class=\"line\">        &lt;evaluate expression=&quot;flowController.performInit()&quot; </span><br><span class=\"line\">                result=&quot;flowScope.InitMap&quot; </span><br><span class=\"line\">                result-type=&quot;org.springframework.ui.ModelMap&quot;/&gt;</span><br><span class=\"line\">    &lt;/on-start&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;view-state id=&quot;init&quot; view=&quot;flow/view/input&quot; model=&quot;searchForm&quot;&gt;</span><br><span class=\"line\">        &lt;binder&gt;</span><br><span class=\"line\">            &lt;binding property=&quot;name&quot;/&gt;</span><br><span class=\"line\">            &lt;binding property=&quot;gender&quot;/&gt;</span><br><span class=\"line\">        &lt;/binder&gt;</span><br><span class=\"line\">        &lt;transition on=&quot;submit&quot; to=&quot;validate&quot;/&gt;</span><br><span class=\"line\">    &lt;/view-state&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;action-state id=&quot;validate&quot;&gt;</span><br><span class=\"line\">        &lt;evaluate  expression=&quot;flowController.performValidate(searchForm)&quot;/&gt;</span><br><span class=\"line\">        &lt;transition on=&quot;success&quot; to=&quot;result&quot;/&gt;</span><br><span class=\"line\">        &lt;transition on=&quot;fail&quot; to=&quot;input&quot;/&gt;</span><br><span class=\"line\">    &lt;/action-state&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;view-state id=&quot;result&quot; view=&quot;flow/view/result&quot;&gt;</span><br><span class=\"line\">        &lt;on-render&gt;</span><br><span class=\"line\">            &lt;evaluate expression=&quot;flowController.performSearch(searchForm)&quot; result=&quot;flashScope.modelMap&quot;/&gt;</span><br><span class=\"line\">        &lt;/on-render&gt;</span><br><span class=\"line\">        &lt;transition to=&quot;end&quot;/&gt;</span><br><span class=\"line\">    &lt;/view-state&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;end-state id=&quot;end&quot; view=&quot;externalRedirect:http://springframework.org&quot;/&gt;</span><br><span class=\"line\">&lt;/flow&gt;</span><br></pre></td></tr></table></figure>\n\n<p>看完上面的描述，想必刚接触web flow的人是一脸懵逼<br><img src=\"20180906215538433.jpeg\" alt=\"这里写图片描述\"><br>解释几个概念就好了。</p>\n<ul>\n<li>状态：web flow将一个步骤称作一个状态(state)，有专门渲染view的view-state，也有只执行操作的action-state</li>\n<li>变量：web flow是以xml的形式进行编程的，可以在该xml上下文中定义变量，该变量可以在flow上下文以及flow渲染的jsp文件(使用EL表达式调用)，调用的方法中(作为参数传入)使用。定义变量的方式主要有两种，一是通过<code>&lt;var&gt;</code>标签显式定义，二是在<code>&lt;evaluate&gt;</code>标签的<code>result</code>属性中定义(此时同时完成了分配变量和变量赋值两个操作)</li>\n<li>变量作用域：规定了变量的作用范围，常见的有flashScope(当前状态有效)，flowScope(当前flow有效)等</li>\n<li>事件：从一个状态到另一个状态，一般需要进行触发，而进行触发的就是事件。事件可能由view触发，也可能由方法触发，我们不用真的去定义一个事件对象。当view-state中的view返回的请求中带有_eventId的参数时，其值会被自动转换成Event，当action-state中调用的方法返回字符串时，该字符串也会被自动转换成Event</li>\n<li>模型绑定：当view需要提交参数时，可以采用模型绑定的形式，web flow会自动将对应参数绑定到我们的model中，并且还可以自定义验证和转换规则。</li>\n</ul>\n<h1 id=\"相关其它文件\"><a href=\"#相关其它文件\" class=\"headerlink\" title=\"相关其它文件\"></a>相关其它文件</h1><h2 id=\"FlowController\"><a href=\"#FlowController\" class=\"headerlink\" title=\"FlowController\"></a>FlowController</h2><p>按照顺序列出相关文件，<code>&lt;evaluate&gt;</code>标签的<code>expression</code>属性可以通过Spring EL表达式的形式直接访问Spring管理的bean的方法或属性，也可以访问flow上下文环境中的对象的方法或属性。其中主要方法讲解如下：</p>\n<ul>\n<li><code>performInit()</code>初始化下拉选中的初始值，返回modelMap对象，该对象被赋值给flow中的InitMap变量</li>\n<li><code>performValidate(SearchForm form)</code>将SearchForm对象传入，用于验证输入的值，这里假设全都验证通过，返回的”success”会被映射成Event</li>\n<li><code>performSearch(SearchForm form)</code>根据传入form中的参数进行数据查找，这里假设已经查找完毕，并将数据放入一个ModelMap，赋值给flow中的modelMap变量</li>\n</ul>\n<p>该类是Spring管理的一个bean，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller(&quot;flowController&quot;)</span><br><span class=\"line\">public class FlowController implements Serializable&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private static final long serialVersionUID = -4439633424434338888L;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ModelMap performInit() &#123;</span><br><span class=\"line\">        ModelMap model = new ModelMap();</span><br><span class=\"line\">        model.addAttribute(&quot;gender&quot;, new String[] &#123;&quot;Man&quot;, &quot;Woman&quot;&#125;);</span><br><span class=\"line\">        return model;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public String performValidate(SearchForm form) &#123;</span><br><span class=\"line\">        // assume we have pass the validation</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public ModelMap performSearch(SearchForm form) &#123;</span><br><span class=\"line\">        // assume we have finished the search process, and got the search result</span><br><span class=\"line\">        ModelMap model = new ModelMap();</span><br><span class=\"line\">        model.addAttribute(&quot;name&quot;, form.getName());</span><br><span class=\"line\">        model.addAttribute(&quot;gender&quot;, form.getGender());</span><br><span class=\"line\">        model.addAttribute(&quot;age&quot;, 25);</span><br><span class=\"line\">        model.addAttribute(&quot;profession&quot;, &quot;Programmer&quot;);</span><br><span class=\"line\">        model.addAttribute(&quot;hobbies&quot;, new String[] &#123;&quot;Basktball&quot;, &quot;Football&quot;&#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return model;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"input-jsp\"><a href=\"#input-jsp\" class=\"headerlink\" title=\"input.jsp\"></a>input.jsp</h2><p>输入界面，将<code>InitMap</code>中的值通过EL表达式渲染到下拉选中。通过<code>_eventId=submit</code>的GET参数方式触发submit事件。<code>${flowExecutionUrl}</code>是flow中自管理变量，访问它才能使得流程继续下去</p>\n<ul>\n<li>尤其需要注意的一个点是，在声明form时，一定要使用spring提供的taglib，否则会出现无法跳转到下一个state，无限回到第一个state的情况。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; prefix=&quot;fn&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;sf&quot; %&gt;</span><br><span class=\"line\">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;Input page&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;!-- commandName 声明该form需要绑定的model，与flow.xml中&lt;view-state&gt;声明的model是一个东西 --&gt;</span><br><span class=\"line\">\t   &lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">\t       Name: &lt;sf:input path=&quot;name&quot;/&gt;&lt;br/&gt;</span><br><span class=\"line\">           gender:</span><br><span class=\"line\">           &lt;sf:select path=&quot;gender&quot;&gt;</span><br><span class=\"line\">               &lt;sf:option value=&quot;&quot;&gt;- Please Select -&lt;/sf:option&gt;</span><br><span class=\"line\">               &lt;c:forEach items=&quot;$&#123;InitMap.gender &#125;&quot; var=&quot;gender&quot;&gt;</span><br><span class=\"line\">                   &lt;sf:option value=&quot;$&#123;gender &#125;&quot;&gt;$&#123;gender &#125;&lt;/sf:option&gt;</span><br><span class=\"line\">               &lt;/c:forEach&gt;</span><br><span class=\"line\">           &lt;/sf:select&gt;</span><br><span class=\"line\">           &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class=\"line\">\t   &lt;/sf:form&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"SearchForm\"><a href=\"#SearchForm\" class=\"headerlink\" title=\"SearchForm\"></a>SearchForm</h2><p>form，与input.jsp中的form参数对应，注意必须要实现序列化接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SearchForm implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"result-jsp\"><a href=\"#result-jsp\" class=\"headerlink\" title=\"result.jsp\"></a>result.jsp</h2><p>将flow中的<code>modelMap</code>变量渲染到页面中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br><span class=\"line\">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; prefix=&quot;fn&quot;%&gt;</span><br><span class=\"line\">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;Result Page&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t    Name: $&#123;modelMap.name &#125; &lt;br/&gt;</span><br><span class=\"line\">\t    Gender: $&#123;modelMap.gender &#125; &lt;br/&gt;</span><br><span class=\"line\">\t    Age: $&#123;modelMap.age &#125; &lt;br/&gt;</span><br><span class=\"line\">\t    profession: $&#123;modelMap.profession &#125; &lt;br/&gt;</span><br><span class=\"line\">\t    hobbies: </span><br><span class=\"line\">        &lt;c:forEach items=&quot;$&#123;modelMap.hobbies &#125;&quot; var=&quot;hobby&quot;&gt;</span><br><span class=\"line\">            $&#123;hobby &#125; &amp;ensp;</span><br><span class=\"line\">        &lt;/c:forEach&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"调试中遇到的坑\"><a href=\"#调试中遇到的坑\" class=\"headerlink\" title=\"调试中遇到的坑\"></a>调试中遇到的坑</h1><ul>\n<li>现象<br>点击form的submit按钮，无法跳转到下一个state，始终重新渲染input界面；定义一个<code>&lt;a href=&quot;${flowExecutionUrl}&amp;_eventId=submit&quot;&gt;</code>标签，能够正常跳转到下一个state</li>\n<li>原因<br>使用了原生的html标签<code>&lt;form&gt;</code>进行表单的声明，导致web flow无法继续工作，改用Spring标签即可。<br>Web Flow无法工作的具体原理尚不明晰，我是在参考公司已有项目时发现这个问题的。</li>\n<li>解决方案<br>使用Spring官方提供的taglib进行form及其属性的声明。</li>\n</ul>"},{"title":"使用Django从零搭建一个小型站点","date":"2019-09-06T14:35:24.000Z","_content":"## 要有project\n\n创建一个基本的Project, 这样我们才能开始工作\n\n```shell\ndjango-admin startproject <工程名>\n```\n<!-- more -->\n## 要能访问数据库\n\nDjango说, 要访问数据库必须创建app和model, 于是, 我们开始创建\n\n- 首先配置好数据库\n\n  在settings.py中加上自己的数据库配置\n\n  ```python\n  DATABASES = {   \n      'default': {        \n          'ENGINE': 'django.db.backends.sqlite3',       \n          'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),    \n      },   \n      # 如下是我的配置\n      'test': {      \n          'ENGINE': 'django.db.backends.mysql',      \n          'NAME': 'test',      \n          'USER': 'test',        \n          'PASSWORD': 'test123',     \n          'HOST':'localhost',      \n          'PORT':'3306',   \n      }\n  }\n  ```\n\n- 然后定义好模型\n\n  在manager.py文件同目录下, 执行如下命令创建app\n\n  ```shell\n  django-admin startapp KnowledgePayModel\n  ```\n\n  然后可以看到如下目录结构\n\n  [外链图片转存失败(img-hy2fdU5Z-1566125816334)(/home/floyd/.config/Typora/typora-user-images/1566014155470.png)]\n\n  然后在project的settings.py下注册刚刚创建的APP\n\n  ```python\n  INSTALLED_APPS = [\n      'django.contrib.admin',\n      'django.contrib.auth',\n      'django.contrib.contenttypes',\n      'django.contrib.sessions',\n      'django.contrib.messages',\n      'django.contrib.staticfiles',\n      # 这是我们自己创建的APP\n      'KnowledgePayModel',\n  ]\n  ```\n\n  然后执行如下命令从现有数据表中导出模型\n\n  ```shell\n  python manager.py inspectdb 表名\n  ```\n\n  我使用django + psycopg2 2.8.3执行上述命令时出现如下错误\n\n  ```python\n  from django.db import models\n  # Unable to inspect table 'payalbum'\n  # The error was: sequence index must be integer, not 'slice'\n  # Unable to inspect table 'paycomment'\n  # The error was: sequence index must be integer, not 'slice'\n  # Unable to inspect table 'payprice'\n  # The error was: sequence index must be integer, not 'slice'\n  # Unable to inspect table 'payvideo'\n  # The error was: sequence index must be integer, not 'slice'\n  ```\n\n  网上查询是版本兼容有问题, 于是将psycopg强制降级\n\n  ```shell\n  sudo pip install psycopg2==2.7.7 --force-reinstall\n  ```\n\n  然后就可以正常工作了, 结果如下, 将其复制到models.py中, 然后进行适当的修改即可使用. 注意生成的AutoField一定要指定为主键, 否则Django会认为没有主键, 从在再隐式给你加一个, 然后就会报说一个model中只能有一个AutoField域.\n\n  ```python\n  # This is an auto-generated Django model module.\n  # You'll have to do the following manually to clean this up:\n  #   * Rearrange models' order\n  #   * Make sure each model has one field with primary_key=True\n  #   * Make sure each ForeignKey has `on_delete` set to the desired behavior.\n  #   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table\n  # Feel free to rename the models, but don't rename db_table values or field names.\n  from __future__ import unicode_literals\n  \n  from django.db import models\n  \n  class Payalbum(models.Model):\n      id = models.AutoField()\n      data = models.TextField()  # This field type is a guess.\n  \n      class Meta:\n          managed = False\n          db_table = 'payalbum'\n  \n  class Paycomment(models.Model):\n      id = models.AutoField()\n      data = models.TextField()  # This field type is a guess.\n  \n      class Meta:\n          managed = False\n          db_table = 'paycomment'\n  \n  class Payprice(models.Model):\n      id = models.AutoField()\n      data = models.TextField()  # This field type is a guess.\n  \n      class Meta:\n          managed = False\n          db_table = 'payprice'\n  \n  class Payvideo(models.Model):\n      id = models.AutoField()\n      data = models.TextField()  # This field type is a guess.\n  \n      class Meta:\n          managed = False\n          db_table = 'payvideo'\n  ```\n\n  如果想要使用Django自带的权限表之类的, 需要执行如下语句, 来生成一系列表\n\n  ```shell\n  python manager.py migrate\n  ```\n\n  控制台执行结果如下:\n\n  ```shell\n  Operations to perform:\n    Apply all migrations: admin, auth, contenttypes, sessions\n  Running migrations:\n    Applying contenttypes.0001_initial... OK\n    Applying auth.0001_initial... OK\n    Applying admin.0001_initial... OK\n    Applying admin.0002_logentry_remove_auto_add... OK\n    Applying contenttypes.0002_remove_content_type_name... OK\n    Applying auth.0002_alter_permission_name_max_length... OK\n    Applying auth.0003_alter_user_email_max_length... OK\n    Applying auth.0004_alter_user_username_opts... OK\n    Applying auth.0005_alter_user_last_login_null... OK\n    Applying auth.0006_require_contenttypes_0002... OK\n    Applying auth.0007_alter_validators_add_error_messages... OK\n    Applying auth.0008_alter_user_username_max_length... OK\n    Applying sessions.0001_initial... OK\n  \n  ```\n\n\n## 要有静态资源\n\n将所有静态资源全部放入templates\n修改settings.py中的静态文件位置配置\n\n```python\nSTATIC_URL = '/templates/'\nSTATICFILES_DIRS = (\n    os.path.join(BASE_DIR, \"templates\"),\n)\n```\n\n在TEMPLATES的DIRS项中增加templates文件夹\n\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        # 只有这个templates是我添加的哦\n        'DIRS': ['templates'],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n```\n\n## 要有路由\n\n在project的urls.py文件中添加我们的路由\n\n```python\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    # 将knowledgepay这个url导向server这个app,让它自己处理\n    url(r'^knowledgepay/', include('server.urls', namespace=\"server\")),\n]\n```\n\n在我们自己的app中创建一个urls.py, 定义app内部自己的路由\n\n```python\n# 这是app内部的路由\nurlpatterns = [\n    url(r'^$', views.homepage),\n    url(r'^home', views.homepage),\n]\n```\n\n在我们自己app的views.py文件中定义各种视图处理器\n\n```python\n# Create your views here.\ndef homepage(request):\n    return render_to_response('login.html')\n```\n\n## 发挥吧\n\n上面已经把基本的框架都搭好了.我们已经可以\n\n- 可以对url进行路由\n- 可以访问静态html文件\n- 可以访问数据库\n- 可以访问自定义的逻辑处理方法\n\n剩下的就是纯粹业务上的事情了.\n\n## 参考资料\n\n如果觉得上面有些地方前后没有联系起来, 那么可以结合下面这个简单的菜鸟教程看看\n\nhttps://www.runoob.com/django/django-tutorial.html\n\n要详细了解, 这里还有Djang中文版文档可供参阅\n\nhttps://docs.djangoproject.com/zh-hans/2.2/intro/\n\n当然这里还有Django book的中文版翻译, 供君选择\n\nhttp://docs.30c.org/djangobook2/index.html\n","source":"_posts/使用Django从零搭建一个小型站点.md","raw":"---\ntitle: 使用Django从零搭建一个小型站点\ndate: 2019-09-06 22:35:24\ntags: \n    - django\ncategories: \n    - python\n---\n## 要有project\n\n创建一个基本的Project, 这样我们才能开始工作\n\n```shell\ndjango-admin startproject <工程名>\n```\n<!-- more -->\n## 要能访问数据库\n\nDjango说, 要访问数据库必须创建app和model, 于是, 我们开始创建\n\n- 首先配置好数据库\n\n  在settings.py中加上自己的数据库配置\n\n  ```python\n  DATABASES = {   \n      'default': {        \n          'ENGINE': 'django.db.backends.sqlite3',       \n          'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),    \n      },   \n      # 如下是我的配置\n      'test': {      \n          'ENGINE': 'django.db.backends.mysql',      \n          'NAME': 'test',      \n          'USER': 'test',        \n          'PASSWORD': 'test123',     \n          'HOST':'localhost',      \n          'PORT':'3306',   \n      }\n  }\n  ```\n\n- 然后定义好模型\n\n  在manager.py文件同目录下, 执行如下命令创建app\n\n  ```shell\n  django-admin startapp KnowledgePayModel\n  ```\n\n  然后可以看到如下目录结构\n\n  [外链图片转存失败(img-hy2fdU5Z-1566125816334)(/home/floyd/.config/Typora/typora-user-images/1566014155470.png)]\n\n  然后在project的settings.py下注册刚刚创建的APP\n\n  ```python\n  INSTALLED_APPS = [\n      'django.contrib.admin',\n      'django.contrib.auth',\n      'django.contrib.contenttypes',\n      'django.contrib.sessions',\n      'django.contrib.messages',\n      'django.contrib.staticfiles',\n      # 这是我们自己创建的APP\n      'KnowledgePayModel',\n  ]\n  ```\n\n  然后执行如下命令从现有数据表中导出模型\n\n  ```shell\n  python manager.py inspectdb 表名\n  ```\n\n  我使用django + psycopg2 2.8.3执行上述命令时出现如下错误\n\n  ```python\n  from django.db import models\n  # Unable to inspect table 'payalbum'\n  # The error was: sequence index must be integer, not 'slice'\n  # Unable to inspect table 'paycomment'\n  # The error was: sequence index must be integer, not 'slice'\n  # Unable to inspect table 'payprice'\n  # The error was: sequence index must be integer, not 'slice'\n  # Unable to inspect table 'payvideo'\n  # The error was: sequence index must be integer, not 'slice'\n  ```\n\n  网上查询是版本兼容有问题, 于是将psycopg强制降级\n\n  ```shell\n  sudo pip install psycopg2==2.7.7 --force-reinstall\n  ```\n\n  然后就可以正常工作了, 结果如下, 将其复制到models.py中, 然后进行适当的修改即可使用. 注意生成的AutoField一定要指定为主键, 否则Django会认为没有主键, 从在再隐式给你加一个, 然后就会报说一个model中只能有一个AutoField域.\n\n  ```python\n  # This is an auto-generated Django model module.\n  # You'll have to do the following manually to clean this up:\n  #   * Rearrange models' order\n  #   * Make sure each model has one field with primary_key=True\n  #   * Make sure each ForeignKey has `on_delete` set to the desired behavior.\n  #   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table\n  # Feel free to rename the models, but don't rename db_table values or field names.\n  from __future__ import unicode_literals\n  \n  from django.db import models\n  \n  class Payalbum(models.Model):\n      id = models.AutoField()\n      data = models.TextField()  # This field type is a guess.\n  \n      class Meta:\n          managed = False\n          db_table = 'payalbum'\n  \n  class Paycomment(models.Model):\n      id = models.AutoField()\n      data = models.TextField()  # This field type is a guess.\n  \n      class Meta:\n          managed = False\n          db_table = 'paycomment'\n  \n  class Payprice(models.Model):\n      id = models.AutoField()\n      data = models.TextField()  # This field type is a guess.\n  \n      class Meta:\n          managed = False\n          db_table = 'payprice'\n  \n  class Payvideo(models.Model):\n      id = models.AutoField()\n      data = models.TextField()  # This field type is a guess.\n  \n      class Meta:\n          managed = False\n          db_table = 'payvideo'\n  ```\n\n  如果想要使用Django自带的权限表之类的, 需要执行如下语句, 来生成一系列表\n\n  ```shell\n  python manager.py migrate\n  ```\n\n  控制台执行结果如下:\n\n  ```shell\n  Operations to perform:\n    Apply all migrations: admin, auth, contenttypes, sessions\n  Running migrations:\n    Applying contenttypes.0001_initial... OK\n    Applying auth.0001_initial... OK\n    Applying admin.0001_initial... OK\n    Applying admin.0002_logentry_remove_auto_add... OK\n    Applying contenttypes.0002_remove_content_type_name... OK\n    Applying auth.0002_alter_permission_name_max_length... OK\n    Applying auth.0003_alter_user_email_max_length... OK\n    Applying auth.0004_alter_user_username_opts... OK\n    Applying auth.0005_alter_user_last_login_null... OK\n    Applying auth.0006_require_contenttypes_0002... OK\n    Applying auth.0007_alter_validators_add_error_messages... OK\n    Applying auth.0008_alter_user_username_max_length... OK\n    Applying sessions.0001_initial... OK\n  \n  ```\n\n\n## 要有静态资源\n\n将所有静态资源全部放入templates\n修改settings.py中的静态文件位置配置\n\n```python\nSTATIC_URL = '/templates/'\nSTATICFILES_DIRS = (\n    os.path.join(BASE_DIR, \"templates\"),\n)\n```\n\n在TEMPLATES的DIRS项中增加templates文件夹\n\n```python\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        # 只有这个templates是我添加的哦\n        'DIRS': ['templates'],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n```\n\n## 要有路由\n\n在project的urls.py文件中添加我们的路由\n\n```python\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    # 将knowledgepay这个url导向server这个app,让它自己处理\n    url(r'^knowledgepay/', include('server.urls', namespace=\"server\")),\n]\n```\n\n在我们自己的app中创建一个urls.py, 定义app内部自己的路由\n\n```python\n# 这是app内部的路由\nurlpatterns = [\n    url(r'^$', views.homepage),\n    url(r'^home', views.homepage),\n]\n```\n\n在我们自己app的views.py文件中定义各种视图处理器\n\n```python\n# Create your views here.\ndef homepage(request):\n    return render_to_response('login.html')\n```\n\n## 发挥吧\n\n上面已经把基本的框架都搭好了.我们已经可以\n\n- 可以对url进行路由\n- 可以访问静态html文件\n- 可以访问数据库\n- 可以访问自定义的逻辑处理方法\n\n剩下的就是纯粹业务上的事情了.\n\n## 参考资料\n\n如果觉得上面有些地方前后没有联系起来, 那么可以结合下面这个简单的菜鸟教程看看\n\nhttps://www.runoob.com/django/django-tutorial.html\n\n要详细了解, 这里还有Djang中文版文档可供参阅\n\nhttps://docs.djangoproject.com/zh-hans/2.2/intro/\n\n当然这里还有Django book的中文版翻译, 供君选择\n\nhttp://docs.30c.org/djangobook2/index.html\n","slug":"使用Django从零搭建一个小型站点","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo9d000k00bne2d0txyq","content":"<h2 id=\"要有project\"><a href=\"#要有project\" class=\"headerlink\" title=\"要有project\"></a>要有project</h2><p>创建一个基本的Project, 这样我们才能开始工作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">django-admin startproject &lt;工程名&gt;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<h2 id=\"要能访问数据库\"><a href=\"#要能访问数据库\" class=\"headerlink\" title=\"要能访问数据库\"></a>要能访问数据库</h2><p>Django说, 要访问数据库必须创建app和model, 于是, 我们开始创建</p>\n<ul>\n<li><p>首先配置好数据库</p>\n<p>在settings.py中加上自己的数据库配置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATABASES = &#123;   </span><br><span class=\"line\">    <span class=\"string\">'default'</span>: &#123;        </span><br><span class=\"line\">        <span class=\"string\">'ENGINE'</span>: <span class=\"string\">'django.db.backends.sqlite3'</span>,       </span><br><span class=\"line\">        <span class=\"string\">'NAME'</span>: os.path.join(BASE_DIR, <span class=\"string\">'db.sqlite3'</span>),    </span><br><span class=\"line\">    &#125;,   </span><br><span class=\"line\">    <span class=\"comment\"># 如下是我的配置</span></span><br><span class=\"line\">    <span class=\"string\">'test'</span>: &#123;      </span><br><span class=\"line\">        <span class=\"string\">'ENGINE'</span>: <span class=\"string\">'django.db.backends.mysql'</span>,      </span><br><span class=\"line\">        <span class=\"string\">'NAME'</span>: <span class=\"string\">'test'</span>,      </span><br><span class=\"line\">        <span class=\"string\">'USER'</span>: <span class=\"string\">'test'</span>,        </span><br><span class=\"line\">        <span class=\"string\">'PASSWORD'</span>: <span class=\"string\">'test123'</span>,     </span><br><span class=\"line\">        <span class=\"string\">'HOST'</span>:<span class=\"string\">'localhost'</span>,      </span><br><span class=\"line\">        <span class=\"string\">'PORT'</span>:<span class=\"string\">'3306'</span>,   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后定义好模型</p>\n<p>在manager.py文件同目录下, 执行如下命令创建app</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">django-admin startapp KnowledgePayModel</span><br></pre></td></tr></table></figure>\n\n<p>然后可以看到如下目录结构</p>\n<p>[外链图片转存失败(img-hy2fdU5Z-1566125816334)(/home/floyd/.config/Typora/typora-user-images/1566014155470.png)]</p>\n<p>然后在project的settings.py下注册刚刚创建的APP</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTALLED_APPS = [</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.admin'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.auth'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.contenttypes'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.sessions'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.messages'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.staticfiles'</span>,</span><br><span class=\"line\">    <span class=\"comment\"># 这是我们自己创建的APP</span></span><br><span class=\"line\">    <span class=\"string\">'KnowledgePayModel'</span>,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>然后执行如下命令从现有数据表中导出模型</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python manager.py inspectdb 表名</span><br></pre></td></tr></table></figure>\n\n<p>我使用django + psycopg2 2.8.3执行上述命令时出现如下错误</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.db <span class=\"keyword\">import</span> models</span><br><span class=\"line\"><span class=\"comment\"># Unable to inspect table 'payalbum'</span></span><br><span class=\"line\"><span class=\"comment\"># The error was: sequence index must be integer, not 'slice'</span></span><br><span class=\"line\"><span class=\"comment\"># Unable to inspect table 'paycomment'</span></span><br><span class=\"line\"><span class=\"comment\"># The error was: sequence index must be integer, not 'slice'</span></span><br><span class=\"line\"><span class=\"comment\"># Unable to inspect table 'payprice'</span></span><br><span class=\"line\"><span class=\"comment\"># The error was: sequence index must be integer, not 'slice'</span></span><br><span class=\"line\"><span class=\"comment\"># Unable to inspect table 'payvideo'</span></span><br><span class=\"line\"><span class=\"comment\"># The error was: sequence index must be integer, not 'slice'</span></span><br></pre></td></tr></table></figure>\n\n<p>网上查询是版本兼容有问题, 于是将psycopg强制降级</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install psycopg2==2.7.7 --force-reinstall</span><br></pre></td></tr></table></figure>\n\n<p>然后就可以正常工作了, 结果如下, 将其复制到models.py中, 然后进行适当的修改即可使用. 注意生成的AutoField一定要指定为主键, 否则Django会认为没有主键, 从在再隐式给你加一个, 然后就会报说一个model中只能有一个AutoField域.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This is an auto-generated Django model module.</span></span><br><span class=\"line\"><span class=\"comment\"># You'll have to do the following manually to clean this up:</span></span><br><span class=\"line\"><span class=\"comment\">#   * Rearrange models' order</span></span><br><span class=\"line\"><span class=\"comment\">#   * Make sure each model has one field with primary_key=True</span></span><br><span class=\"line\"><span class=\"comment\">#   * Make sure each ForeignKey has `on_delete` set to the desired behavior.</span></span><br><span class=\"line\"><span class=\"comment\">#   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table</span></span><br><span class=\"line\"><span class=\"comment\"># Feel free to rename the models, but don't rename db_table values or field names.</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> unicode_literals</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.db <span class=\"keyword\">import</span> models</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Payalbum</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.AutoField()</span><br><span class=\"line\">    data = models.TextField()  <span class=\"comment\"># This field type is a guess.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"literal\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'payalbum'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paycomment</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.AutoField()</span><br><span class=\"line\">    data = models.TextField()  <span class=\"comment\"># This field type is a guess.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"literal\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'paycomment'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Payprice</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.AutoField()</span><br><span class=\"line\">    data = models.TextField()  <span class=\"comment\"># This field type is a guess.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"literal\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'payprice'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Payvideo</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.AutoField()</span><br><span class=\"line\">    data = models.TextField()  <span class=\"comment\"># This field type is a guess.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"literal\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'payvideo'</span></span><br></pre></td></tr></table></figure>\n\n<p>如果想要使用Django自带的权限表之类的, 需要执行如下语句, 来生成一系列表</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python manager.py migrate</span><br></pre></td></tr></table></figure>\n\n<p>控制台执行结果如下:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Operations to perform:</span><br><span class=\"line\">  Apply all migrations: admin, auth, contenttypes, sessions</span><br><span class=\"line\">Running migrations:</span><br><span class=\"line\">  Applying contenttypes.0001_initial... OK</span><br><span class=\"line\">  Applying auth.0001_initial... OK</span><br><span class=\"line\">  Applying admin.0001_initial... OK</span><br><span class=\"line\">  Applying admin.0002_logentry_remove_auto_add... OK</span><br><span class=\"line\">  Applying contenttypes.0002_remove_content_type_name... OK</span><br><span class=\"line\">  Applying auth.0002_alter_permission_name_max_length... OK</span><br><span class=\"line\">  Applying auth.0003_alter_user_email_max_length... OK</span><br><span class=\"line\">  Applying auth.0004_alter_user_username_opts... OK</span><br><span class=\"line\">  Applying auth.0005_alter_user_last_login_null... OK</span><br><span class=\"line\">  Applying auth.0006_require_contenttypes_0002... OK</span><br><span class=\"line\">  Applying auth.0007_alter_validators_add_error_messages... OK</span><br><span class=\"line\">  Applying auth.0008_alter_user_username_max_length... OK</span><br><span class=\"line\">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"要有静态资源\"><a href=\"#要有静态资源\" class=\"headerlink\" title=\"要有静态资源\"></a>要有静态资源</h2><p>将所有静态资源全部放入templates<br>修改settings.py中的静态文件位置配置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">STATIC_URL = <span class=\"string\">'/templates/'</span></span><br><span class=\"line\">STATICFILES_DIRS = (</span><br><span class=\"line\">    os.path.join(BASE_DIR, <span class=\"string\">\"templates\"</span>),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>在TEMPLATES的DIRS项中增加templates文件夹</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEMPLATES = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">'BACKEND'</span>: <span class=\"string\">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class=\"line\">        <span class=\"comment\"># 只有这个templates是我添加的哦</span></span><br><span class=\"line\">        <span class=\"string\">'DIRS'</span>: [<span class=\"string\">'templates'</span>],</span><br><span class=\"line\">        <span class=\"string\">'APP_DIRS'</span>: <span class=\"literal\">True</span>,</span><br><span class=\"line\">        <span class=\"string\">'OPTIONS'</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">'context_processors'</span>: [</span><br><span class=\"line\">                <span class=\"string\">'django.template.context_processors.debug'</span>,</span><br><span class=\"line\">                <span class=\"string\">'django.template.context_processors.request'</span>,</span><br><span class=\"line\">                <span class=\"string\">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class=\"line\">                <span class=\"string\">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class=\"line\">            ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"要有路由\"><a href=\"#要有路由\" class=\"headerlink\" title=\"要有路由\"></a>要有路由</h2><p>在project的urls.py文件中添加我们的路由</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlpatterns = [</span><br><span class=\"line\">    url(<span class=\"string\">r'^admin/'</span>, admin.site.urls),</span><br><span class=\"line\">    <span class=\"comment\"># 将knowledgepay这个url导向server这个app,让它自己处理</span></span><br><span class=\"line\">    url(<span class=\"string\">r'^knowledgepay/'</span>, include(<span class=\"string\">'server.urls'</span>, namespace=<span class=\"string\">\"server\"</span>)),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>在我们自己的app中创建一个urls.py, 定义app内部自己的路由</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是app内部的路由</span></span><br><span class=\"line\">urlpatterns = [</span><br><span class=\"line\">    url(<span class=\"string\">r'^$'</span>, views.homepage),</span><br><span class=\"line\">    url(<span class=\"string\">r'^home'</span>, views.homepage),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>在我们自己app的views.py文件中定义各种视图处理器</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Create your views here.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">homepage</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_to_response(<span class=\"string\">'login.html'</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"发挥吧\"><a href=\"#发挥吧\" class=\"headerlink\" title=\"发挥吧\"></a>发挥吧</h2><p>上面已经把基本的框架都搭好了.我们已经可以</p>\n<ul>\n<li>可以对url进行路由</li>\n<li>可以访问静态html文件</li>\n<li>可以访问数据库</li>\n<li>可以访问自定义的逻辑处理方法</li>\n</ul>\n<p>剩下的就是纯粹业务上的事情了.</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>如果觉得上面有些地方前后没有联系起来, 那么可以结合下面这个简单的菜鸟教程看看</p>\n<p><a href=\"https://www.runoob.com/django/django-tutorial.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/django/django-tutorial.html</a></p>\n<p>要详细了解, 这里还有Djang中文版文档可供参阅</p>\n<p><a href=\"https://docs.djangoproject.com/zh-hans/2.2/intro/\" target=\"_blank\" rel=\"noopener\">https://docs.djangoproject.com/zh-hans/2.2/intro/</a></p>\n<p>当然这里还有Django book的中文版翻译, 供君选择</p>\n<p><a href=\"http://docs.30c.org/djangobook2/index.html\" target=\"_blank\" rel=\"noopener\">http://docs.30c.org/djangobook2/index.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"要有project\"><a href=\"#要有project\" class=\"headerlink\" title=\"要有project\"></a>要有project</h2><p>创建一个基本的Project, 这样我们才能开始工作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">django-admin startproject &lt;工程名&gt;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"要能访问数据库\"><a href=\"#要能访问数据库\" class=\"headerlink\" title=\"要能访问数据库\"></a>要能访问数据库</h2><p>Django说, 要访问数据库必须创建app和model, 于是, 我们开始创建</p>\n<ul>\n<li><p>首先配置好数据库</p>\n<p>在settings.py中加上自己的数据库配置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATABASES = &#123;   </span><br><span class=\"line\">    <span class=\"string\">'default'</span>: &#123;        </span><br><span class=\"line\">        <span class=\"string\">'ENGINE'</span>: <span class=\"string\">'django.db.backends.sqlite3'</span>,       </span><br><span class=\"line\">        <span class=\"string\">'NAME'</span>: os.path.join(BASE_DIR, <span class=\"string\">'db.sqlite3'</span>),    </span><br><span class=\"line\">    &#125;,   </span><br><span class=\"line\">    <span class=\"comment\"># 如下是我的配置</span></span><br><span class=\"line\">    <span class=\"string\">'test'</span>: &#123;      </span><br><span class=\"line\">        <span class=\"string\">'ENGINE'</span>: <span class=\"string\">'django.db.backends.mysql'</span>,      </span><br><span class=\"line\">        <span class=\"string\">'NAME'</span>: <span class=\"string\">'test'</span>,      </span><br><span class=\"line\">        <span class=\"string\">'USER'</span>: <span class=\"string\">'test'</span>,        </span><br><span class=\"line\">        <span class=\"string\">'PASSWORD'</span>: <span class=\"string\">'test123'</span>,     </span><br><span class=\"line\">        <span class=\"string\">'HOST'</span>:<span class=\"string\">'localhost'</span>,      </span><br><span class=\"line\">        <span class=\"string\">'PORT'</span>:<span class=\"string\">'3306'</span>,   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后定义好模型</p>\n<p>在manager.py文件同目录下, 执行如下命令创建app</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">django-admin startapp KnowledgePayModel</span><br></pre></td></tr></table></figure>\n\n<p>然后可以看到如下目录结构</p>\n<p>[外链图片转存失败(img-hy2fdU5Z-1566125816334)(/home/floyd/.config/Typora/typora-user-images/1566014155470.png)]</p>\n<p>然后在project的settings.py下注册刚刚创建的APP</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTALLED_APPS = [</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.admin'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.auth'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.contenttypes'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.sessions'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.messages'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.staticfiles'</span>,</span><br><span class=\"line\">    <span class=\"comment\"># 这是我们自己创建的APP</span></span><br><span class=\"line\">    <span class=\"string\">'KnowledgePayModel'</span>,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>然后执行如下命令从现有数据表中导出模型</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python manager.py inspectdb 表名</span><br></pre></td></tr></table></figure>\n\n<p>我使用django + psycopg2 2.8.3执行上述命令时出现如下错误</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.db <span class=\"keyword\">import</span> models</span><br><span class=\"line\"><span class=\"comment\"># Unable to inspect table 'payalbum'</span></span><br><span class=\"line\"><span class=\"comment\"># The error was: sequence index must be integer, not 'slice'</span></span><br><span class=\"line\"><span class=\"comment\"># Unable to inspect table 'paycomment'</span></span><br><span class=\"line\"><span class=\"comment\"># The error was: sequence index must be integer, not 'slice'</span></span><br><span class=\"line\"><span class=\"comment\"># Unable to inspect table 'payprice'</span></span><br><span class=\"line\"><span class=\"comment\"># The error was: sequence index must be integer, not 'slice'</span></span><br><span class=\"line\"><span class=\"comment\"># Unable to inspect table 'payvideo'</span></span><br><span class=\"line\"><span class=\"comment\"># The error was: sequence index must be integer, not 'slice'</span></span><br></pre></td></tr></table></figure>\n\n<p>网上查询是版本兼容有问题, 于是将psycopg强制降级</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install psycopg2==2.7.7 --force-reinstall</span><br></pre></td></tr></table></figure>\n\n<p>然后就可以正常工作了, 结果如下, 将其复制到models.py中, 然后进行适当的修改即可使用. 注意生成的AutoField一定要指定为主键, 否则Django会认为没有主键, 从在再隐式给你加一个, 然后就会报说一个model中只能有一个AutoField域.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This is an auto-generated Django model module.</span></span><br><span class=\"line\"><span class=\"comment\"># You'll have to do the following manually to clean this up:</span></span><br><span class=\"line\"><span class=\"comment\">#   * Rearrange models' order</span></span><br><span class=\"line\"><span class=\"comment\">#   * Make sure each model has one field with primary_key=True</span></span><br><span class=\"line\"><span class=\"comment\">#   * Make sure each ForeignKey has `on_delete` set to the desired behavior.</span></span><br><span class=\"line\"><span class=\"comment\">#   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table</span></span><br><span class=\"line\"><span class=\"comment\"># Feel free to rename the models, but don't rename db_table values or field names.</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> unicode_literals</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> django.db <span class=\"keyword\">import</span> models</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Payalbum</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.AutoField()</span><br><span class=\"line\">    data = models.TextField()  <span class=\"comment\"># This field type is a guess.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"literal\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'payalbum'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Paycomment</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.AutoField()</span><br><span class=\"line\">    data = models.TextField()  <span class=\"comment\"># This field type is a guess.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"literal\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'paycomment'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Payprice</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.AutoField()</span><br><span class=\"line\">    data = models.TextField()  <span class=\"comment\"># This field type is a guess.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"literal\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'payprice'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Payvideo</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.AutoField()</span><br><span class=\"line\">    data = models.TextField()  <span class=\"comment\"># This field type is a guess.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"literal\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'payvideo'</span></span><br></pre></td></tr></table></figure>\n\n<p>如果想要使用Django自带的权限表之类的, 需要执行如下语句, 来生成一系列表</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python manager.py migrate</span><br></pre></td></tr></table></figure>\n\n<p>控制台执行结果如下:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Operations to perform:</span><br><span class=\"line\">  Apply all migrations: admin, auth, contenttypes, sessions</span><br><span class=\"line\">Running migrations:</span><br><span class=\"line\">  Applying contenttypes.0001_initial... OK</span><br><span class=\"line\">  Applying auth.0001_initial... OK</span><br><span class=\"line\">  Applying admin.0001_initial... OK</span><br><span class=\"line\">  Applying admin.0002_logentry_remove_auto_add... OK</span><br><span class=\"line\">  Applying contenttypes.0002_remove_content_type_name... OK</span><br><span class=\"line\">  Applying auth.0002_alter_permission_name_max_length... OK</span><br><span class=\"line\">  Applying auth.0003_alter_user_email_max_length... OK</span><br><span class=\"line\">  Applying auth.0004_alter_user_username_opts... OK</span><br><span class=\"line\">  Applying auth.0005_alter_user_last_login_null... OK</span><br><span class=\"line\">  Applying auth.0006_require_contenttypes_0002... OK</span><br><span class=\"line\">  Applying auth.0007_alter_validators_add_error_messages... OK</span><br><span class=\"line\">  Applying auth.0008_alter_user_username_max_length... OK</span><br><span class=\"line\">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"要有静态资源\"><a href=\"#要有静态资源\" class=\"headerlink\" title=\"要有静态资源\"></a>要有静态资源</h2><p>将所有静态资源全部放入templates<br>修改settings.py中的静态文件位置配置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">STATIC_URL = <span class=\"string\">'/templates/'</span></span><br><span class=\"line\">STATICFILES_DIRS = (</span><br><span class=\"line\">    os.path.join(BASE_DIR, <span class=\"string\">\"templates\"</span>),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>在TEMPLATES的DIRS项中增加templates文件夹</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEMPLATES = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">'BACKEND'</span>: <span class=\"string\">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class=\"line\">        <span class=\"comment\"># 只有这个templates是我添加的哦</span></span><br><span class=\"line\">        <span class=\"string\">'DIRS'</span>: [<span class=\"string\">'templates'</span>],</span><br><span class=\"line\">        <span class=\"string\">'APP_DIRS'</span>: <span class=\"literal\">True</span>,</span><br><span class=\"line\">        <span class=\"string\">'OPTIONS'</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">'context_processors'</span>: [</span><br><span class=\"line\">                <span class=\"string\">'django.template.context_processors.debug'</span>,</span><br><span class=\"line\">                <span class=\"string\">'django.template.context_processors.request'</span>,</span><br><span class=\"line\">                <span class=\"string\">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class=\"line\">                <span class=\"string\">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class=\"line\">            ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"要有路由\"><a href=\"#要有路由\" class=\"headerlink\" title=\"要有路由\"></a>要有路由</h2><p>在project的urls.py文件中添加我们的路由</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlpatterns = [</span><br><span class=\"line\">    url(<span class=\"string\">r'^admin/'</span>, admin.site.urls),</span><br><span class=\"line\">    <span class=\"comment\"># 将knowledgepay这个url导向server这个app,让它自己处理</span></span><br><span class=\"line\">    url(<span class=\"string\">r'^knowledgepay/'</span>, include(<span class=\"string\">'server.urls'</span>, namespace=<span class=\"string\">\"server\"</span>)),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>在我们自己的app中创建一个urls.py, 定义app内部自己的路由</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是app内部的路由</span></span><br><span class=\"line\">urlpatterns = [</span><br><span class=\"line\">    url(<span class=\"string\">r'^$'</span>, views.homepage),</span><br><span class=\"line\">    url(<span class=\"string\">r'^home'</span>, views.homepage),</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>在我们自己app的views.py文件中定义各种视图处理器</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Create your views here.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">homepage</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_to_response(<span class=\"string\">'login.html'</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"发挥吧\"><a href=\"#发挥吧\" class=\"headerlink\" title=\"发挥吧\"></a>发挥吧</h2><p>上面已经把基本的框架都搭好了.我们已经可以</p>\n<ul>\n<li>可以对url进行路由</li>\n<li>可以访问静态html文件</li>\n<li>可以访问数据库</li>\n<li>可以访问自定义的逻辑处理方法</li>\n</ul>\n<p>剩下的就是纯粹业务上的事情了.</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>如果觉得上面有些地方前后没有联系起来, 那么可以结合下面这个简单的菜鸟教程看看</p>\n<p><a href=\"https://www.runoob.com/django/django-tutorial.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/django/django-tutorial.html</a></p>\n<p>要详细了解, 这里还有Djang中文版文档可供参阅</p>\n<p><a href=\"https://docs.djangoproject.com/zh-hans/2.2/intro/\" target=\"_blank\" rel=\"noopener\">https://docs.djangoproject.com/zh-hans/2.2/intro/</a></p>\n<p>当然这里还有Django book的中文版翻译, 供君选择</p>\n<p><a href=\"http://docs.30c.org/djangobook2/index.html\" target=\"_blank\" rel=\"noopener\">http://docs.30c.org/djangobook2/index.html</a></p>"},{"title":"Spring Webflow - 视图状态","date":"2018-09-09T06:00:00.000Z","_content":"\n# 基础\n## 指定view-state的view属性的几种方式\n\n - 按照默认名称在相对路径下查找view\n\n```\n<!-- 在flow配置文件同目录下查找名为enterBookingDetails的视图 -->\n<view-state id=\"enterBookingDetails\">\n```\n\n - 指明view名称，在相对路径下查找view\n\n```\n<!-- 在flow配置文件同目录下查找名为bookingDetails.xhtml的视图 -->\n<view-state id=\"enterBookingDetails\" view=\"bookingDetails.xhtml\">\n```\n\n - 绝对路径查找view\n\n```\n<!-- 直接查找/WEB-INF/hotels/booking/bookingDetails.xhtml的视图 -->\n<view-state id=\"enterBookingDetails\" view=\"/WEB-INF/hotels/booking/bookingDetails.xhtml\">\n```\n\n - 按照逻辑ID定位view\n这是结合Spring提供的其它viewResolver来定位到其他组件中的view，如Tiles等。在前面 [配置](https://blog.csdn.net/zou8944/article/details/82391712) 一章中有讲\n\n```\n<!-- 结合viewResolver共同确定视图位 -->\n<view-state id=\"enterBookingDetails\" view=\"bookingDetails\">\n```\n## 在viewScope中分配变量\n\n - 直接分配\n\n```\n<var name=\"searchCriteria\" class=\"com.mycompany.myapp.hotels.SearchCriteria\" />\n```\n\n - 依靠运算结果分配\n\n```\n<on-render>\n  \t <evaluate expression=\"bookingService.findHotels(searchCriteria)\" result=\"viewScope.hotels\" />\n</on-render>\n```\n## 在viewScope中操作对象\n如下例子展示了如何在同一个view state的不同时机操作一系列对象\n\n```\n<view-state id=\"searchResults\">\n   \t<on-render>\n\t\t<evaluate expression=\"bookingService.findHotels(searchCriteria)\"\n                 result=\"viewScope.hotels\" />\n\t</on-render>\n\t<transition on=\"next\">\n\t\t<evaluate expression=\"searchCriteria.nextPage()\" />\n\t\t<render fragments=\"searchResultsFragment\" />\n\t</transition>\n\t<transition on=\"previous\">\n\t\t<evaluate expression=\"searchCriteria.previousPage()\" />\n\t\t<render fragments=\"searchResultsFragment\" />\n\t</transition>\n</view-state>\n<!-- 渲染view之前，首先执行findHotels方法，将结果放到viewScope的hotels中 -->\n<!-- 当返回next事件时，执行nextPage()方法， 然后渲染查找结果部分 -->\n<!-- 当返回previous事件时，执行前一页操作，然后渲染查找结果部分 -->\n```\n## `<on-render>`\n在view渲染前可以执行一个或多个action，**这些action将会在视图最开始渲染以及后续的任何刷新，甚至视图局部的重新渲染执行**。以上面的代码为例，在重新渲染结果之前，还会先执行一次findHotels方法。\n##数据绑定\n## 在view-state上绑定model\n使用model属性，可以将一个对象绑定到view中的表单中。web flow可以帮助完成对象属性和表单域的绑定和验证。\n\n```\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n```\n绑定时机是当view的event发生时\n\n - `view-to-model`绑定：在view完成并回发时，用户的输入域会被绑定到指定对象的属性上\n - `model`验证：绑定后，如果需要验证，验证逻辑会被调用。\n - 需要指出的是：只有当验证成功后才能transition到别的state，验证失败时会重新渲染该view，要求用户重新输入。\n##绑定model时的类型转换\n####基础\n由于客户端上传的表单数据都是字符串类型的， 因此需要进行类型转换\n\n - Web Flow类型转换和Spring MVC的类型转换的关系\n在web-flow 2.1以前，Sprign MVC和web-flow使用不同的类型转换机制，但是2.1以后，二者使用相同的类型转换\n**以前**，Web Flow使用`spring-binding-2.4.6.RELEASE.jar`包提供的API进行类型转换，相关的类有`org.springframework.binding.convert.service.DefaultConversionService`， `org.springframework.binding.convert.converters.Converter`等，通过实现`Converter`接口完成自定义转换器，再通过`DefaultConversionService`进行注册，就像如下所示的方式1那样；而且这样还能够注册带命名ID的转换器，可以结合`<bingding>`的`converter`属性进行使用，但这种方式已经非常不建议了。\n**目前**， Web Flow在执行conversionService时依然使用`org.springframework.binding.convert.service.DefaultConversionService`，但该服务已经不会去注册任何默认的转换器和格式化器了，而是将转换和格式任务全部委托给来自`spring-core-4.3.7.RELEASE.jar`包的`org.springframework.core.convert.ConversionService`完成。`DefaultConversionService`内部维护一个`ConversionService`对象，对`DefaultConversionService`中进行的大多数操作都被转变成对`ConversionService`的操作(对带命名ID转换器的管理除外)。值得一提的是，命名ID的转换器非常没有必要，因为在检测到相应类型后，系统会自动调用合适的转换器。\n\n - 方式一 传统方式添加Converter(不建议使用)\n\n```\nimport org.springframework.binding.convert.converters.Converter;\n// 定义自己的转换器\npublic class DateConverter implements Converter {\n\n    public Class<?> getSourceClass() {\n        return String.class;\n    }\n\n    public Class<?> getTargetClass() {\n        return java.util.Date.class;\n    }\n\n    public Object convertSourceToTargetClass(Object source, Class<?> targetClass) throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        \n        return sdf.parse(source.toString());\n    }\n\n}\n```\n\n```\n// 注册自己的转换器\npublic class ApplicationConversionService extends DefaultConversionService {\n\tpublic ApplicationConversionService() {\n   \t\taddConverter(new DateConverter());\n\t}\n}\n```\n\n```\n<!-- 使用转换器，什么都不用指定，当检测到model中的checkinDate属性为Date类型时，DateConverter会自动被调用 -->\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n   \t<binder>\n       \t<binding property=\"checkinDate\"/>\n   \t</binder>\n</view-state>\n```\n\n - 方式二 添加带ID的Converter(已过时，不推荐使用)\n\n```\nDateConverter的定义不变\n```\n\n```\n// 注册时指定id\npublic class ApplicationConversionService extends DefaultConversionService {\n\tpublic ApplicationConversionService() {\n\t\t// 该方法已被标为deprecated\n   \t\taddConverter(\"dateConverter\", new DateConverter());\n\t}\n}\n```\n\n```\n<!-- 使用时指定id -->\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n   \t<binder>\n       \t<binding property=\"checkinDate\" converter=\"dateConverter\"/>\n   \t</binder>\n</view-state>\n```\n - 方式三 - 配置通用的Converter和Formatter(推荐使用，当前版本鼓励的方式)\n\n```\n// 首先实现FormattingConversionServiceFactoryBean，添加自定义格式化器和转换器\npublic class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean {\n\n    @Override\n    public void setConverters(Set<?> converters) {\n        Converter<String, Date> converter = new Converter<String, Date>() {\n            public Date convert(String source) {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n                return sdf.parse(source);\n            }\n        };\n        \n        Set<Converter<String, Date>> set = new HashSet<Converter<String,Date>>();\n        set.add(converter);\n        super.setConverters(set);\n    }\n\n    @Override\n    public void setFormatters(Set<?> formatters) {\n        Set<Formatter<Date>> set= new HashSet<Formatter<Date>>();\n        set.add(new Formatter<Date>() {\n\n            public String print(Date object, Locale locale) {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n                return sdf.format(object);\n            }\n\n            public Date parse(String text, Locale locale) throws ParseException {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n                return sdf.parse(text);\n            }\n            \n        });\n        \n        super.setFormatters(set);\n    }\n\n}\n```\n\n```\n// 创建由ApplicationConversionServiceFactoryBean产生的ConversionService\n// 该ConversionService是Spring MVC中类型转换的核心，可以同时配置给Spring MVC和Web Flow\n@Bean(\"applicationConversionService\")\npublic ConversionService applicationConversionService() {\n    FormattingConversionServiceFactoryBean factory = new ApplicationConversionServiceFactoryBean();\n    // 添加自定义格式化器\n    factory.setFormatters(null);\n    // 添加自定义格式转换器\n    factory.setConverters(null);\n    // 生成ConversionService \n    factory.afterPropertiesSet();\n    // 返回ConversionService \n    return factory.getObject();\n}\n```\n\n```\n// 下面三个步骤用于配置给Web Flow\n\n@Bean(\"defaultConversionService\")\npublic DefaultConversionService conversionService(@Autowired ConversionService applicationConversionService) {\n    return new DefaultConversionService(applicationConversionService);\n}\n\n@Bean\npublic FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator, @Autowired DefaultConversionService defaultConversionService) {\n    return getFlowBuilderServicesBuilder()\n            .setConversionService(defaultConversionService)\n            .build();\n}\n\n// 注册flow\n@Bean(\"flowRegistry\")\npublic FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) {\n    \n    return getFlowDefinitionRegistryBuilder()\n            .setBasePath(\"/WEB-INF/jsp/flow\")\n            .addFlowLocation(\"/config/search-flow.xml\")\n            .setFlowBuilderServices(flowBuilderServices)\n            .build();\n}\n```\n\n```\n<!-- 下面的步骤用于注册给Spring MVC -->\n<mvc:annotation-driven conversion-service=\"applicationConversionService\" />\n```\n - 针对上述三种方式的说明\n  - 方式一表面上使用的是旧的转换器添加方式，但内部实现还是按照新的方式进行，在添加Converter时，会通过一个适配器类转换将`org.springframework.binding.convert.converters.Converter`转换为`org.springframework.core.convert.converter.GenericConverter`\n\n```\n// 源码片段\npublic void addConverter(Converter converter) {\n\t((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(converter));\n\tif (converter instanceof TwoWayConverter) {\n\t\tTwoWayConverter twoWayConverter = (TwoWayConverter) converter;\n\t\t((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(new ReverseConverter(\n\t\t\t\ttwoWayConverter)));\n\t}\n}\n```\n\n  - 方式二已过时，这里仅展示\n  - 方式三推荐使用，但这里仅展示了我自己实验成功的java config配置方式，xml配置方式可以参见[官网](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration)。\n  - 实际使用时，会发现方式一从视图提交到model时类型转换能够正常进行，但是从model回填到视图时并非自己最开始输入的数值，那是因为我们只设置了Converter，没有设置Formatter。\n  - 关于转换器的配置，只要认识到ConversionService是类型转换的核心，就会省事很多\n\n## Converter和Formatter的区别\n\n - `Converter`: 是`spring-core-4.3.7.RELEASE.jar`包提供的，用于`Object to Object`的转换\n - `Formatter`: 是`spring-context-4.3.7.RELEASE.jar`包提供的，用于`Object to String`的转换。\n\n## 格式化注解\n新的类型转换提供两个有用的注解，可以放在model类的属性上，和被@Controller类的方法参数中。\n\n - `NumberFormat`\n - `DateTimeFormat`： 该注解默认使用[`Joda Time`](http://www.joda.org/joda-time/)，需要在类路径中包含Joda Time的包。默认情况下Spring MVC和web flow都没有其他的日期相关的转换器和格式化器。因此定义我们自己的日期相关转换器和格式化器非常重要。\n - 此外，我们还可以参照上述两个注解定义自己的注解.\n\n## 关于绑定的另外两点\n\n - 取消绑定\n可以使用bind属性在特定情况下取消绑定。如下当触发cancel事件时不会执行绑定操作\n\n```\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n    <transition on=\"proceed\" to=\"reviewBooking\">\n    <transition on=\"cancel\" to=\"bookingCancelled\" bind=\"false\" />\n</view-state>\n```\n\n - 显式地指明绑定的字段\n使用<binder>标签可以显式指明需要绑定的字段，同时可以指明需要使用到的转换器，和是否允许为空。\n\n```\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n    <binder>\n        <binding property=\"checkinDate\" converter=\"shortDate\" required=\"true\" />\n        <binding property=\"checkoutDate\" converter=\"shortDate\" required=\"true\" />\n        <binding property=\"creditCard\" required=\"true\" />\n        <binding property=\"creditCardName\" required=\"true\" />\n        <binding property=\"creditCardExpiryMonth\" required=\"true\" />\n        <binding property=\"creditCardExpiryYear\" required=\"true\" />\n    </binder>\n    <transition on=\"proceed\" to=\"reviewBooking\">\n    <transition on=\"cancel\" to=\"bookingCancelled\" bind=\"false\" />\n</view-state>\n```\n\n> 注意事项\n> 1. 没有显式指定绑定字段时，所有model对象的公共属性都会被绑定；指定绑定字段时，则只有显式指定的字段会被绑定\n> 2. 没有显式声明转换器时，会使用自动检测的转换器\n> 3. 声明不允许为空时，若出现空，则会产生验证错误，并会重新绘制视图并报错。\n> ##绑定数据的验证\n> Web Flow支持自定义验证条件和JSR-303 Bean验证框架\n> ####JSR-303 Bean Validation\n>  -  基础配置\n> 首先类路径中需要有一个validator的jar包，然后按照如下配置后，validator会应用到所有的添加了条件注解的model属性中\n```\n<webflow:flow-registry flow-builder-services=\"flowBuilderServices\" />\n<webflow:flow-builder-services id=\"flowBuilderServices\" validator=\"validator\" />\n<bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\" />\n```\n&emsp;&emsp;form中按如下方式配置\n\n```\n@NotNull\n@Size(min = 2, max = 30, message=\"at least 3 chars\" )\nprivate String name;\n```\n&emsp;&emsp;前端按如下配置，使用`<sf:errors>`可将name属性的错误信息显示出来\n\n```\n<sf:form action=\"${flowExecutionUrl}&_eventId=submit\" commandName=\"searchForm\" method=\"post\">\n    Name: <sf:input path=\"name\"/> <sf:errors path=\"name\"></sf:errors><br/>\n       <input type=\"submit\" value=\"Submit\">\n</sf:form>\n```\n&emsp;&emsp;效果如下\n![这里写图片描述](https://img-blog.csdn.net/20180909184901856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n - 部分验证\nJSR-303支持部分验证，通过验证组的方式，使用如下(我在验证该方式时是不行的，提示viwe-state标签不允许出现validation-hints属性)\n\n```\n@NotNull\n@Size(min = 2, max = 30, groups = State1.class)\nprivate String name;\n```\n\n```\n<view-state id=\"state1\" model=\"myModel\" validation-hints=\"'group1,group2'\">\n```\n&emsp;&emsp;对该方法不做详细解释，最好还是参考一下JSR-303再来看\n## 自定义验证\nJSR-303仅支持对Bean的验证，如非空，字符串长度等。我们经常需要自定义验证逻辑，有如下两种方式进行自定义\n\n - 一是在model类内部定义一个以`validate${stateId}(ValidationContext)`为签名的方法，在view提交时会自动调用该验证方法。stateId是view-state的id\n\n```\n// 官方示例\npublic class Booking {\n    private Date checkinDate;\n    private Date checkoutDate;\n    ...\n\n    public void validateEnterBookingDetails(ValidationContext context) {\n        MessageContext messages = context.getMessageContext();\n        if (checkinDate.before(today())) {\n            messages.addMessage(new MessageBuilder().error().source(\"checkinDate\").\n                defaultText(\"Check in date must be a future date\").build());\n        } else if (!checkinDate.before(checkoutDate)) {\n            messages.addMessage(new MessageBuilder().error().source(\"checkoutDate\").\n                defaultText(\"Check out date must be later than check in date\").build());\n        }\n    }\n}\n```\n\n - 二是单独定义一个类，类名为`${model}Validator`，在其内部定义一个以`validate${stateId}(${model}, ValidationContext)`为签名的方法，然后将该类装载到Spring中。\n\n```\n// 官方示例\n@Component\npublic class BookingValidator {\n    public void validateEnterBookingDetails(Booking booking, ValidationContext context) {\n        MessageContext messages = context.getMessageContext();\n        if (booking.getCheckinDate().before(today())) {\n            messages.addMessage(new MessageBuilder().error().source(\"checkinDate\").\n                defaultText(\"Check in date must be a future date\").build());\n        } else if (!booking.getCheckinDate().before(booking.getCheckoutDate())) {\n            messages.addMessage(new MessageBuilder().error().source(\"checkoutDate\").\n                defaultText(\"Check out date must be later than check in date\").build());\n        }\n    }\n}\n```\n&emsp;&emsp;针对第二种情况也可以定义一个`validate(${model}, ValidationContext)`方法，这样无论在哪个view-state的view返回时，只要绑定了该moel，都会调用该验证方法。\n&emsp;&emsp;当`validate(${model}, ValidationContext)`和validate`${stateId}(${model}, ValidationContext)`都存在时，会先调用后者，再调用前者。\n\n## 多说两点\n\n - 失能验证\n通过如下方式可以在局部使得验证失效\n\n```\n<view-state id=\"chooseAmenities\" model=\"booking\">\n    <transition on=\"proceed\" to=\"reviewBooking\">\n    <transition on=\"back\" to=\"enterBookingDetails\" validate=\"false\" />\n</view-state>\n```\n# 转移\n在一个view-state中，可能发生各种转移\n\n -  转移之前执行操作\n可以在转移之前执行特定的操作，如一个方法， 当方法返回false或者发生错误时，转移不会继续进行下去。而是重新渲染相应的部分\n\n```\n<transition on=\"submit\" to=\"bookingConfirmed\">\n    <evaluate expression=\"bookingAction.makeBooking(booking, messageContext)\" />\n</transition>\n```\n\n - 全局转移\n定义全局有效的转移操作\n\n```\n<global-transitions>\n    <transition on=\"login\" to=\"login\" />\n    <transition on=\"logout\" to=\"logout\" />\n</global-transitions>\n```\n\n - 事件处理器\n可以利用transition标签只响应事件，而不做任何跳转操作，从而作为事件处理器\n\n```\n<transition on=\"event\">\n    <!-- Handle event -->\n</transition>\n```\n\n - 局部渲染\n利用`<render>`标签可以进行局部渲染，一般用于Ajax的局部刷新操作\n\n```\n<transition on=\"next\">\n    <evaluate expression=\"searchCriteria.nextPage()\" />\n    <render fragments=\"searchResultsFragment\" />\n</transition>\n```\n&emsp;&emsp;如上，当发生next事件时，首先执行翻页操作，然后重新刷新查询结果区域。fragment属性应该引用想要刷新的view的id,当刷新多个区域时，使用逗号隔开。\n# view的回退控制\n当我们从一个view跳转到另一个view时，通过浏览器的回退按钮，可以返回上一个view，我们可以对这个功能进行配置\n\n - 失能一个回退view，即当前view不能再下一个view上回退，回退到的是前一个view\n\n```\n<transition on=\"cancel\" to=\"bookingCancelled\" history=\"discard\">\n```\n\n - 失能所有回退view，即当前及之前所有view都是不能够被回退的。\n\n```\n<transition on=\"confirm\" to=\"bookingConfirmed\" history=\"invalidate\">\n```\n##MessageContext\nSpring web flow的MessageContext是用来记录在flow执行期间的信息的。而其中包含的信息都由MessageBuilder产生，可以手动添加，也可以由系统自动产生。\n\n## 手动添加信息\n\n - 手动添加普通文本\n\n```\nMessageContext context = ...（这里一般是从上一级获取到context对象）\nMessageBuilder builder = new MessageBuilder();\ncontext.addMessage(builder.error().source(\"checkinDate\")\n    .defaultText(\"Check in date must be a future date\").build());\ncontext.addMessage(builder.warn().source(\"smoking\")\n    .defaultText(\"Smoking is bad for your health\").build());\ncontext.addMessage(builder.info()\n    .defaultText(\"We have processed your reservation - thank you and enjoy your stay\").build());\n```\n\n - 添加Spring MessageSource得到的信息\n\n```\nMessageContext context = ...\nMessageBuilder builder = new MessageBuilder();\ncontext.addMessage(builder.error().source(\"checkinDate\").code(\"checkinDate.notFuture\").build());\ncontext.addMessage(builder.warn().source(\"smoking\").code(\"notHealthy\")\n    .resolvableArg(\"smoking\").build());\ncontext.addMessage(builder.info().code(\"reservationConfirmation\").build());\n```\n\n - 添加message bundle获取的信息\n可以直接在view或flow中使用`resourceBundle`这个EL变量来获取资源文件中的内容。(这个需要在web-flow同目录下放置一个`message.properties`文件)\n\n```\n<input value=\"#{resourceBundle.reservationConfirmation}\" />\n```\n## 系统自动产生信息\n&emsp;&emsp;有多重情况下web-flow会自动生成message,其中一种重要的情况是当view-to-model验证失败时，生成规则是，首先到资源文件中查找key为`${model}l.${property}.${errCode}`的资源，如果找不到，则直接查找key为`${errCode}`的资源。\n&emsp;&emsp; 举例：有model名为booking，验证其中的checkDate属性，当出现类型不匹配时，系统给出的错误代码为`typeMismatch`，则会在资源文件中查找如下key的资源\n `booking.checkDate.typeMismatch`  或 `typeMismatch`\n\n# 附\n下面大致列举一下Spring MVC会自动注册的转换器和格式化器(调用`ConversionService`的`toString()`方法)\n\n```\n@org.springframework.format.annotation.DateTimeFormat java.lang.Long -> java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,@org.springframework.format.annotation.NumberFormat java.lang.Long -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.DateTimeFormat java.time.LocalDate -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDate -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@1cb91eff\n@org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDateTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2918eadb\n@org.springframework.format.annotation.DateTimeFormat java.time.LocalTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@6d563cf9\n@org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetDateTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2f20d514\n@org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@19212c1c\n@org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.ZonedDateTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2e061032\n@org.springframework.format.annotation.DateTimeFormat java.util.Calendar -> java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed\n@org.springframework.format.annotation.NumberFormat java.lang.Byte -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.lang.Double -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.lang.Float -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.lang.Integer -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.lang.Short -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.math.BigDecimal -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.math.BigInteger -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.Boolean -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@839fe61\njava.lang.Character -> java.lang.Number : org.springframework.core.convert.support.CharacterToNumberFactory@30f9d9cf\njava.lang.Character -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@2062b73e\njava.lang.Enum -> java.lang.Integer : org.springframework.core.convert.support.EnumToIntegerConverter@65bd69cd\njava.lang.Enum -> java.lang.String : org.springframework.core.convert.support.EnumToStringConverter@24ccca42\njava.lang.Integer -> java.lang.Enum : org.springframework.core.convert.support.IntegerToEnumConverterFactory@22b0410c\njava.lang.Long -> java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$LongToInstantConverter@36c61628\njava.lang.Long -> java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@7a56bca3,java.lang.Long -> java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@32680fd1\njava.lang.Long -> java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@21f63842,java.lang.Long -> java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@3ae27639\njava.lang.Number -> java.lang.Character : org.springframework.core.convert.support.NumberToCharacterConverter@37dca65c\njava.lang.Number -> java.lang.Number : org.springframework.core.convert.support.NumberToNumberConverterFactory@5ad62efe\njava.lang.Number -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@5dbb5323\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.lang.Long: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,java.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Long: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.LocalDate: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.LocalDate: org.springframework.format.datetime.standard.TemporalAccessorParser@1a482c16\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.LocalDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@726b4b72\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.LocalTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.LocalTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7d025d62\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.OffsetDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7b82b59\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.OffsetTime: org.springframework.format.datetime.standard.TemporalAccessorParser@5d6bf8bc\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.ZonedDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@4100b1dd\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.util.Calendar: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Byte: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Double: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Float: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Integer: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Short: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.math.BigDecimal: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.math.BigInteger: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> java.lang.Boolean : org.springframework.core.convert.support.StringToBooleanConverter@3dd765a2\njava.lang.String -> java.lang.Character : org.springframework.core.convert.support.StringToCharacterConverter@4b28d17b\njava.lang.String -> java.lang.Enum : org.springframework.core.convert.support.StringToEnumConverterFactory@5a85577c\njava.lang.String -> java.lang.Number : org.springframework.core.convert.support.StringToNumberConverterFactory@4a4bac52\njava.lang.String -> java.nio.charset.Charset : org.springframework.core.convert.support.StringToCharsetConverter@77b7395f\njava.lang.String -> java.time.Duration: org.springframework.format.datetime.standard.DurationFormatter@223f8ade\njava.lang.String -> java.time.Instant: org.springframework.format.datetime.standard.InstantFormatter@744a1e70\njava.lang.String -> java.time.MonthDay: org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1\njava.lang.String -> java.time.Period: org.springframework.format.datetime.standard.PeriodFormatter@326e1143\njava.lang.String -> java.time.YearMonth: org.springframework.format.datetime.standard.YearMonthFormatter@2013283d\njava.lang.String -> java.util.Currency : org.springframework.core.convert.support.StringToCurrencyConverter@73d62889\njava.lang.String -> java.util.Date: cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,java.lang.String -> java.util.Date : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$1@bda7edf,java.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.util.Date: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed\njava.lang.String -> java.util.Locale : org.springframework.core.convert.support.StringToLocaleConverter@15f3ecb1\njava.lang.String -> java.util.Properties : org.springframework.core.convert.support.StringToPropertiesConverter@1734f8d8\njava.lang.String -> java.util.TimeZone : org.springframework.core.convert.support.StringToTimeZoneConverter@219e655b\njava.lang.String -> java.util.UUID : org.springframework.core.convert.support.StringToUUIDConverter@7a2a1350\njava.nio.charset.Charset -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@79cac565\njava.time.Duration -> java.lang.String : org.springframework.format.datetime.standard.DurationFormatter@223f8ade\njava.time.Instant -> java.lang.Long : org.springframework.format.datetime.standard.DateTimeConverters$InstantToLongConverter@bbf9adc\njava.time.Instant -> java.lang.String : org.springframework.format.datetime.standard.InstantFormatter@744a1e70\njava.time.LocalDateTime -> java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalDateConverter@224c05f6\njava.time.LocalDateTime -> java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalTimeConverter@bb6fc38\njava.time.MonthDay -> java.lang.String : org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1\njava.time.OffsetDateTime -> java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToInstantConverter@7e4083f\njava.time.OffsetDateTime -> java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateConverter@1e188fca\njava.time.OffsetDateTime -> java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateTimeConverter@79b804b1\njava.time.OffsetDateTime -> java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalTimeConverter@178638ba\njava.time.OffsetDateTime -> java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToZonedDateTimeConverter@5dd8aa91\njava.time.Period -> java.lang.String : org.springframework.format.datetime.standard.PeriodFormatter@326e1143\njava.time.YearMonth -> java.lang.String : org.springframework.format.datetime.standard.YearMonthFormatter@2013283d\njava.time.ZoneId -> java.util.TimeZone : org.springframework.core.convert.support.ZoneIdToTimeZoneConverter@375fe360\njava.time.ZonedDateTime -> java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToInstantConverter@5b6ff572\njava.time.ZonedDateTime -> java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateConverter@44caea49\njava.time.ZonedDateTime -> java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateTimeConverter@748fb300\njava.time.ZonedDateTime -> java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalTimeConverter@362e6386\njava.time.ZonedDateTime -> java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToOffsetDateTimeConverter@4864c695\njava.time.ZonedDateTime -> java.util.Calendar : org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter@53757723\njava.util.Calendar -> java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@3effd16f,java.util.Calendar -> java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@6625da72\njava.util.Calendar -> java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToInstantConverter@3ea63a04\njava.util.Calendar -> java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateConverter@311b3b\njava.util.Calendar -> java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateTimeConverter@b827cbe\njava.util.Calendar -> java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalTimeConverter@27334ef2\njava.util.Calendar -> java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToOffsetDateTimeConverter@18a5b69c\njava.util.Calendar -> java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToZonedDateTimeConverter@2181b391\njava.util.Calendar -> java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@43409a9e,java.util.Calendar -> java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@25a7d510\njava.util.Currency -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@59874f76\njava.util.Date -> java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@2d72afcb,java.util.Date -> java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@60b0c620\njava.util.Date -> java.lang.String : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,@org.springframework.format.annotation.DateTimeFormat java.util.Date -> java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed\njava.util.Date -> java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@635f0388,java.util.Date -> java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@7b746ecc\njava.util.Locale -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@572faa97\njava.util.Properties -> java.lang.String : org.springframework.core.convert.support.PropertiesToStringConverter@387ae6b6\njava.util.UUID -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@19b50f9c\n```","source":"_posts/Spring Webflow - 视图状态.md","raw":"---\ntitle: Spring Webflow - 视图状态\ndate: 2018-09-09 14:00:00\ntags: \n    - Spring\n    - Webflow\ncategories: \n    - Spring Webflow\n---\n\n# 基础\n## 指定view-state的view属性的几种方式\n\n - 按照默认名称在相对路径下查找view\n\n```\n<!-- 在flow配置文件同目录下查找名为enterBookingDetails的视图 -->\n<view-state id=\"enterBookingDetails\">\n```\n\n - 指明view名称，在相对路径下查找view\n\n```\n<!-- 在flow配置文件同目录下查找名为bookingDetails.xhtml的视图 -->\n<view-state id=\"enterBookingDetails\" view=\"bookingDetails.xhtml\">\n```\n\n - 绝对路径查找view\n\n```\n<!-- 直接查找/WEB-INF/hotels/booking/bookingDetails.xhtml的视图 -->\n<view-state id=\"enterBookingDetails\" view=\"/WEB-INF/hotels/booking/bookingDetails.xhtml\">\n```\n\n - 按照逻辑ID定位view\n这是结合Spring提供的其它viewResolver来定位到其他组件中的view，如Tiles等。在前面 [配置](https://blog.csdn.net/zou8944/article/details/82391712) 一章中有讲\n\n```\n<!-- 结合viewResolver共同确定视图位 -->\n<view-state id=\"enterBookingDetails\" view=\"bookingDetails\">\n```\n## 在viewScope中分配变量\n\n - 直接分配\n\n```\n<var name=\"searchCriteria\" class=\"com.mycompany.myapp.hotels.SearchCriteria\" />\n```\n\n - 依靠运算结果分配\n\n```\n<on-render>\n  \t <evaluate expression=\"bookingService.findHotels(searchCriteria)\" result=\"viewScope.hotels\" />\n</on-render>\n```\n## 在viewScope中操作对象\n如下例子展示了如何在同一个view state的不同时机操作一系列对象\n\n```\n<view-state id=\"searchResults\">\n   \t<on-render>\n\t\t<evaluate expression=\"bookingService.findHotels(searchCriteria)\"\n                 result=\"viewScope.hotels\" />\n\t</on-render>\n\t<transition on=\"next\">\n\t\t<evaluate expression=\"searchCriteria.nextPage()\" />\n\t\t<render fragments=\"searchResultsFragment\" />\n\t</transition>\n\t<transition on=\"previous\">\n\t\t<evaluate expression=\"searchCriteria.previousPage()\" />\n\t\t<render fragments=\"searchResultsFragment\" />\n\t</transition>\n</view-state>\n<!-- 渲染view之前，首先执行findHotels方法，将结果放到viewScope的hotels中 -->\n<!-- 当返回next事件时，执行nextPage()方法， 然后渲染查找结果部分 -->\n<!-- 当返回previous事件时，执行前一页操作，然后渲染查找结果部分 -->\n```\n## `<on-render>`\n在view渲染前可以执行一个或多个action，**这些action将会在视图最开始渲染以及后续的任何刷新，甚至视图局部的重新渲染执行**。以上面的代码为例，在重新渲染结果之前，还会先执行一次findHotels方法。\n##数据绑定\n## 在view-state上绑定model\n使用model属性，可以将一个对象绑定到view中的表单中。web flow可以帮助完成对象属性和表单域的绑定和验证。\n\n```\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n```\n绑定时机是当view的event发生时\n\n - `view-to-model`绑定：在view完成并回发时，用户的输入域会被绑定到指定对象的属性上\n - `model`验证：绑定后，如果需要验证，验证逻辑会被调用。\n - 需要指出的是：只有当验证成功后才能transition到别的state，验证失败时会重新渲染该view，要求用户重新输入。\n##绑定model时的类型转换\n####基础\n由于客户端上传的表单数据都是字符串类型的， 因此需要进行类型转换\n\n - Web Flow类型转换和Spring MVC的类型转换的关系\n在web-flow 2.1以前，Sprign MVC和web-flow使用不同的类型转换机制，但是2.1以后，二者使用相同的类型转换\n**以前**，Web Flow使用`spring-binding-2.4.6.RELEASE.jar`包提供的API进行类型转换，相关的类有`org.springframework.binding.convert.service.DefaultConversionService`， `org.springframework.binding.convert.converters.Converter`等，通过实现`Converter`接口完成自定义转换器，再通过`DefaultConversionService`进行注册，就像如下所示的方式1那样；而且这样还能够注册带命名ID的转换器，可以结合`<bingding>`的`converter`属性进行使用，但这种方式已经非常不建议了。\n**目前**， Web Flow在执行conversionService时依然使用`org.springframework.binding.convert.service.DefaultConversionService`，但该服务已经不会去注册任何默认的转换器和格式化器了，而是将转换和格式任务全部委托给来自`spring-core-4.3.7.RELEASE.jar`包的`org.springframework.core.convert.ConversionService`完成。`DefaultConversionService`内部维护一个`ConversionService`对象，对`DefaultConversionService`中进行的大多数操作都被转变成对`ConversionService`的操作(对带命名ID转换器的管理除外)。值得一提的是，命名ID的转换器非常没有必要，因为在检测到相应类型后，系统会自动调用合适的转换器。\n\n - 方式一 传统方式添加Converter(不建议使用)\n\n```\nimport org.springframework.binding.convert.converters.Converter;\n// 定义自己的转换器\npublic class DateConverter implements Converter {\n\n    public Class<?> getSourceClass() {\n        return String.class;\n    }\n\n    public Class<?> getTargetClass() {\n        return java.util.Date.class;\n    }\n\n    public Object convertSourceToTargetClass(Object source, Class<?> targetClass) throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        \n        return sdf.parse(source.toString());\n    }\n\n}\n```\n\n```\n// 注册自己的转换器\npublic class ApplicationConversionService extends DefaultConversionService {\n\tpublic ApplicationConversionService() {\n   \t\taddConverter(new DateConverter());\n\t}\n}\n```\n\n```\n<!-- 使用转换器，什么都不用指定，当检测到model中的checkinDate属性为Date类型时，DateConverter会自动被调用 -->\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n   \t<binder>\n       \t<binding property=\"checkinDate\"/>\n   \t</binder>\n</view-state>\n```\n\n - 方式二 添加带ID的Converter(已过时，不推荐使用)\n\n```\nDateConverter的定义不变\n```\n\n```\n// 注册时指定id\npublic class ApplicationConversionService extends DefaultConversionService {\n\tpublic ApplicationConversionService() {\n\t\t// 该方法已被标为deprecated\n   \t\taddConverter(\"dateConverter\", new DateConverter());\n\t}\n}\n```\n\n```\n<!-- 使用时指定id -->\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n   \t<binder>\n       \t<binding property=\"checkinDate\" converter=\"dateConverter\"/>\n   \t</binder>\n</view-state>\n```\n - 方式三 - 配置通用的Converter和Formatter(推荐使用，当前版本鼓励的方式)\n\n```\n// 首先实现FormattingConversionServiceFactoryBean，添加自定义格式化器和转换器\npublic class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean {\n\n    @Override\n    public void setConverters(Set<?> converters) {\n        Converter<String, Date> converter = new Converter<String, Date>() {\n            public Date convert(String source) {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n                return sdf.parse(source);\n            }\n        };\n        \n        Set<Converter<String, Date>> set = new HashSet<Converter<String,Date>>();\n        set.add(converter);\n        super.setConverters(set);\n    }\n\n    @Override\n    public void setFormatters(Set<?> formatters) {\n        Set<Formatter<Date>> set= new HashSet<Formatter<Date>>();\n        set.add(new Formatter<Date>() {\n\n            public String print(Date object, Locale locale) {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n                return sdf.format(object);\n            }\n\n            public Date parse(String text, Locale locale) throws ParseException {\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n                return sdf.parse(text);\n            }\n            \n        });\n        \n        super.setFormatters(set);\n    }\n\n}\n```\n\n```\n// 创建由ApplicationConversionServiceFactoryBean产生的ConversionService\n// 该ConversionService是Spring MVC中类型转换的核心，可以同时配置给Spring MVC和Web Flow\n@Bean(\"applicationConversionService\")\npublic ConversionService applicationConversionService() {\n    FormattingConversionServiceFactoryBean factory = new ApplicationConversionServiceFactoryBean();\n    // 添加自定义格式化器\n    factory.setFormatters(null);\n    // 添加自定义格式转换器\n    factory.setConverters(null);\n    // 生成ConversionService \n    factory.afterPropertiesSet();\n    // 返回ConversionService \n    return factory.getObject();\n}\n```\n\n```\n// 下面三个步骤用于配置给Web Flow\n\n@Bean(\"defaultConversionService\")\npublic DefaultConversionService conversionService(@Autowired ConversionService applicationConversionService) {\n    return new DefaultConversionService(applicationConversionService);\n}\n\n@Bean\npublic FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator, @Autowired DefaultConversionService defaultConversionService) {\n    return getFlowBuilderServicesBuilder()\n            .setConversionService(defaultConversionService)\n            .build();\n}\n\n// 注册flow\n@Bean(\"flowRegistry\")\npublic FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) {\n    \n    return getFlowDefinitionRegistryBuilder()\n            .setBasePath(\"/WEB-INF/jsp/flow\")\n            .addFlowLocation(\"/config/search-flow.xml\")\n            .setFlowBuilderServices(flowBuilderServices)\n            .build();\n}\n```\n\n```\n<!-- 下面的步骤用于注册给Spring MVC -->\n<mvc:annotation-driven conversion-service=\"applicationConversionService\" />\n```\n - 针对上述三种方式的说明\n  - 方式一表面上使用的是旧的转换器添加方式，但内部实现还是按照新的方式进行，在添加Converter时，会通过一个适配器类转换将`org.springframework.binding.convert.converters.Converter`转换为`org.springframework.core.convert.converter.GenericConverter`\n\n```\n// 源码片段\npublic void addConverter(Converter converter) {\n\t((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(converter));\n\tif (converter instanceof TwoWayConverter) {\n\t\tTwoWayConverter twoWayConverter = (TwoWayConverter) converter;\n\t\t((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(new ReverseConverter(\n\t\t\t\ttwoWayConverter)));\n\t}\n}\n```\n\n  - 方式二已过时，这里仅展示\n  - 方式三推荐使用，但这里仅展示了我自己实验成功的java config配置方式，xml配置方式可以参见[官网](https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration)。\n  - 实际使用时，会发现方式一从视图提交到model时类型转换能够正常进行，但是从model回填到视图时并非自己最开始输入的数值，那是因为我们只设置了Converter，没有设置Formatter。\n  - 关于转换器的配置，只要认识到ConversionService是类型转换的核心，就会省事很多\n\n## Converter和Formatter的区别\n\n - `Converter`: 是`spring-core-4.3.7.RELEASE.jar`包提供的，用于`Object to Object`的转换\n - `Formatter`: 是`spring-context-4.3.7.RELEASE.jar`包提供的，用于`Object to String`的转换。\n\n## 格式化注解\n新的类型转换提供两个有用的注解，可以放在model类的属性上，和被@Controller类的方法参数中。\n\n - `NumberFormat`\n - `DateTimeFormat`： 该注解默认使用[`Joda Time`](http://www.joda.org/joda-time/)，需要在类路径中包含Joda Time的包。默认情况下Spring MVC和web flow都没有其他的日期相关的转换器和格式化器。因此定义我们自己的日期相关转换器和格式化器非常重要。\n - 此外，我们还可以参照上述两个注解定义自己的注解.\n\n## 关于绑定的另外两点\n\n - 取消绑定\n可以使用bind属性在特定情况下取消绑定。如下当触发cancel事件时不会执行绑定操作\n\n```\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n    <transition on=\"proceed\" to=\"reviewBooking\">\n    <transition on=\"cancel\" to=\"bookingCancelled\" bind=\"false\" />\n</view-state>\n```\n\n - 显式地指明绑定的字段\n使用<binder>标签可以显式指明需要绑定的字段，同时可以指明需要使用到的转换器，和是否允许为空。\n\n```\n<view-state id=\"enterBookingDetails\" model=\"booking\">\n    <binder>\n        <binding property=\"checkinDate\" converter=\"shortDate\" required=\"true\" />\n        <binding property=\"checkoutDate\" converter=\"shortDate\" required=\"true\" />\n        <binding property=\"creditCard\" required=\"true\" />\n        <binding property=\"creditCardName\" required=\"true\" />\n        <binding property=\"creditCardExpiryMonth\" required=\"true\" />\n        <binding property=\"creditCardExpiryYear\" required=\"true\" />\n    </binder>\n    <transition on=\"proceed\" to=\"reviewBooking\">\n    <transition on=\"cancel\" to=\"bookingCancelled\" bind=\"false\" />\n</view-state>\n```\n\n> 注意事项\n> 1. 没有显式指定绑定字段时，所有model对象的公共属性都会被绑定；指定绑定字段时，则只有显式指定的字段会被绑定\n> 2. 没有显式声明转换器时，会使用自动检测的转换器\n> 3. 声明不允许为空时，若出现空，则会产生验证错误，并会重新绘制视图并报错。\n> ##绑定数据的验证\n> Web Flow支持自定义验证条件和JSR-303 Bean验证框架\n> ####JSR-303 Bean Validation\n>  -  基础配置\n> 首先类路径中需要有一个validator的jar包，然后按照如下配置后，validator会应用到所有的添加了条件注解的model属性中\n```\n<webflow:flow-registry flow-builder-services=\"flowBuilderServices\" />\n<webflow:flow-builder-services id=\"flowBuilderServices\" validator=\"validator\" />\n<bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\" />\n```\n&emsp;&emsp;form中按如下方式配置\n\n```\n@NotNull\n@Size(min = 2, max = 30, message=\"at least 3 chars\" )\nprivate String name;\n```\n&emsp;&emsp;前端按如下配置，使用`<sf:errors>`可将name属性的错误信息显示出来\n\n```\n<sf:form action=\"${flowExecutionUrl}&_eventId=submit\" commandName=\"searchForm\" method=\"post\">\n    Name: <sf:input path=\"name\"/> <sf:errors path=\"name\"></sf:errors><br/>\n       <input type=\"submit\" value=\"Submit\">\n</sf:form>\n```\n&emsp;&emsp;效果如下\n![这里写图片描述](https://img-blog.csdn.net/20180909184901856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n - 部分验证\nJSR-303支持部分验证，通过验证组的方式，使用如下(我在验证该方式时是不行的，提示viwe-state标签不允许出现validation-hints属性)\n\n```\n@NotNull\n@Size(min = 2, max = 30, groups = State1.class)\nprivate String name;\n```\n\n```\n<view-state id=\"state1\" model=\"myModel\" validation-hints=\"'group1,group2'\">\n```\n&emsp;&emsp;对该方法不做详细解释，最好还是参考一下JSR-303再来看\n## 自定义验证\nJSR-303仅支持对Bean的验证，如非空，字符串长度等。我们经常需要自定义验证逻辑，有如下两种方式进行自定义\n\n - 一是在model类内部定义一个以`validate${stateId}(ValidationContext)`为签名的方法，在view提交时会自动调用该验证方法。stateId是view-state的id\n\n```\n// 官方示例\npublic class Booking {\n    private Date checkinDate;\n    private Date checkoutDate;\n    ...\n\n    public void validateEnterBookingDetails(ValidationContext context) {\n        MessageContext messages = context.getMessageContext();\n        if (checkinDate.before(today())) {\n            messages.addMessage(new MessageBuilder().error().source(\"checkinDate\").\n                defaultText(\"Check in date must be a future date\").build());\n        } else if (!checkinDate.before(checkoutDate)) {\n            messages.addMessage(new MessageBuilder().error().source(\"checkoutDate\").\n                defaultText(\"Check out date must be later than check in date\").build());\n        }\n    }\n}\n```\n\n - 二是单独定义一个类，类名为`${model}Validator`，在其内部定义一个以`validate${stateId}(${model}, ValidationContext)`为签名的方法，然后将该类装载到Spring中。\n\n```\n// 官方示例\n@Component\npublic class BookingValidator {\n    public void validateEnterBookingDetails(Booking booking, ValidationContext context) {\n        MessageContext messages = context.getMessageContext();\n        if (booking.getCheckinDate().before(today())) {\n            messages.addMessage(new MessageBuilder().error().source(\"checkinDate\").\n                defaultText(\"Check in date must be a future date\").build());\n        } else if (!booking.getCheckinDate().before(booking.getCheckoutDate())) {\n            messages.addMessage(new MessageBuilder().error().source(\"checkoutDate\").\n                defaultText(\"Check out date must be later than check in date\").build());\n        }\n    }\n}\n```\n&emsp;&emsp;针对第二种情况也可以定义一个`validate(${model}, ValidationContext)`方法，这样无论在哪个view-state的view返回时，只要绑定了该moel，都会调用该验证方法。\n&emsp;&emsp;当`validate(${model}, ValidationContext)`和validate`${stateId}(${model}, ValidationContext)`都存在时，会先调用后者，再调用前者。\n\n## 多说两点\n\n - 失能验证\n通过如下方式可以在局部使得验证失效\n\n```\n<view-state id=\"chooseAmenities\" model=\"booking\">\n    <transition on=\"proceed\" to=\"reviewBooking\">\n    <transition on=\"back\" to=\"enterBookingDetails\" validate=\"false\" />\n</view-state>\n```\n# 转移\n在一个view-state中，可能发生各种转移\n\n -  转移之前执行操作\n可以在转移之前执行特定的操作，如一个方法， 当方法返回false或者发生错误时，转移不会继续进行下去。而是重新渲染相应的部分\n\n```\n<transition on=\"submit\" to=\"bookingConfirmed\">\n    <evaluate expression=\"bookingAction.makeBooking(booking, messageContext)\" />\n</transition>\n```\n\n - 全局转移\n定义全局有效的转移操作\n\n```\n<global-transitions>\n    <transition on=\"login\" to=\"login\" />\n    <transition on=\"logout\" to=\"logout\" />\n</global-transitions>\n```\n\n - 事件处理器\n可以利用transition标签只响应事件，而不做任何跳转操作，从而作为事件处理器\n\n```\n<transition on=\"event\">\n    <!-- Handle event -->\n</transition>\n```\n\n - 局部渲染\n利用`<render>`标签可以进行局部渲染，一般用于Ajax的局部刷新操作\n\n```\n<transition on=\"next\">\n    <evaluate expression=\"searchCriteria.nextPage()\" />\n    <render fragments=\"searchResultsFragment\" />\n</transition>\n```\n&emsp;&emsp;如上，当发生next事件时，首先执行翻页操作，然后重新刷新查询结果区域。fragment属性应该引用想要刷新的view的id,当刷新多个区域时，使用逗号隔开。\n# view的回退控制\n当我们从一个view跳转到另一个view时，通过浏览器的回退按钮，可以返回上一个view，我们可以对这个功能进行配置\n\n - 失能一个回退view，即当前view不能再下一个view上回退，回退到的是前一个view\n\n```\n<transition on=\"cancel\" to=\"bookingCancelled\" history=\"discard\">\n```\n\n - 失能所有回退view，即当前及之前所有view都是不能够被回退的。\n\n```\n<transition on=\"confirm\" to=\"bookingConfirmed\" history=\"invalidate\">\n```\n##MessageContext\nSpring web flow的MessageContext是用来记录在flow执行期间的信息的。而其中包含的信息都由MessageBuilder产生，可以手动添加，也可以由系统自动产生。\n\n## 手动添加信息\n\n - 手动添加普通文本\n\n```\nMessageContext context = ...（这里一般是从上一级获取到context对象）\nMessageBuilder builder = new MessageBuilder();\ncontext.addMessage(builder.error().source(\"checkinDate\")\n    .defaultText(\"Check in date must be a future date\").build());\ncontext.addMessage(builder.warn().source(\"smoking\")\n    .defaultText(\"Smoking is bad for your health\").build());\ncontext.addMessage(builder.info()\n    .defaultText(\"We have processed your reservation - thank you and enjoy your stay\").build());\n```\n\n - 添加Spring MessageSource得到的信息\n\n```\nMessageContext context = ...\nMessageBuilder builder = new MessageBuilder();\ncontext.addMessage(builder.error().source(\"checkinDate\").code(\"checkinDate.notFuture\").build());\ncontext.addMessage(builder.warn().source(\"smoking\").code(\"notHealthy\")\n    .resolvableArg(\"smoking\").build());\ncontext.addMessage(builder.info().code(\"reservationConfirmation\").build());\n```\n\n - 添加message bundle获取的信息\n可以直接在view或flow中使用`resourceBundle`这个EL变量来获取资源文件中的内容。(这个需要在web-flow同目录下放置一个`message.properties`文件)\n\n```\n<input value=\"#{resourceBundle.reservationConfirmation}\" />\n```\n## 系统自动产生信息\n&emsp;&emsp;有多重情况下web-flow会自动生成message,其中一种重要的情况是当view-to-model验证失败时，生成规则是，首先到资源文件中查找key为`${model}l.${property}.${errCode}`的资源，如果找不到，则直接查找key为`${errCode}`的资源。\n&emsp;&emsp; 举例：有model名为booking，验证其中的checkDate属性，当出现类型不匹配时，系统给出的错误代码为`typeMismatch`，则会在资源文件中查找如下key的资源\n `booking.checkDate.typeMismatch`  或 `typeMismatch`\n\n# 附\n下面大致列举一下Spring MVC会自动注册的转换器和格式化器(调用`ConversionService`的`toString()`方法)\n\n```\n@org.springframework.format.annotation.DateTimeFormat java.lang.Long -> java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,@org.springframework.format.annotation.NumberFormat java.lang.Long -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.DateTimeFormat java.time.LocalDate -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDate -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@1cb91eff\n@org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDateTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2918eadb\n@org.springframework.format.annotation.DateTimeFormat java.time.LocalTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@6d563cf9\n@org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetDateTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2f20d514\n@org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@19212c1c\n@org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime -> java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.ZonedDateTime -> java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2e061032\n@org.springframework.format.annotation.DateTimeFormat java.util.Calendar -> java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed\n@org.springframework.format.annotation.NumberFormat java.lang.Byte -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.lang.Double -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.lang.Float -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.lang.Integer -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.lang.Short -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.math.BigDecimal -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\n@org.springframework.format.annotation.NumberFormat java.math.BigInteger -> java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.Boolean -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@839fe61\njava.lang.Character -> java.lang.Number : org.springframework.core.convert.support.CharacterToNumberFactory@30f9d9cf\njava.lang.Character -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@2062b73e\njava.lang.Enum -> java.lang.Integer : org.springframework.core.convert.support.EnumToIntegerConverter@65bd69cd\njava.lang.Enum -> java.lang.String : org.springframework.core.convert.support.EnumToStringConverter@24ccca42\njava.lang.Integer -> java.lang.Enum : org.springframework.core.convert.support.IntegerToEnumConverterFactory@22b0410c\njava.lang.Long -> java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$LongToInstantConverter@36c61628\njava.lang.Long -> java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@7a56bca3,java.lang.Long -> java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@32680fd1\njava.lang.Long -> java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@21f63842,java.lang.Long -> java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@3ae27639\njava.lang.Number -> java.lang.Character : org.springframework.core.convert.support.NumberToCharacterConverter@37dca65c\njava.lang.Number -> java.lang.Number : org.springframework.core.convert.support.NumberToNumberConverterFactory@5ad62efe\njava.lang.Number -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@5dbb5323\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.lang.Long: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,java.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Long: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.LocalDate: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.LocalDate: org.springframework.format.datetime.standard.TemporalAccessorParser@1a482c16\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.LocalDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@726b4b72\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.LocalTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.LocalTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7d025d62\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.OffsetDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7b82b59\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.OffsetTime: org.springframework.format.datetime.standard.TemporalAccessorParser@5d6bf8bc\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -> java.time.ZonedDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@4100b1dd\njava.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.util.Calendar: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Byte: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Double: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Float: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Integer: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.lang.Short: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.math.BigDecimal: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> @org.springframework.format.annotation.NumberFormat java.math.BigInteger: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b\njava.lang.String -> java.lang.Boolean : org.springframework.core.convert.support.StringToBooleanConverter@3dd765a2\njava.lang.String -> java.lang.Character : org.springframework.core.convert.support.StringToCharacterConverter@4b28d17b\njava.lang.String -> java.lang.Enum : org.springframework.core.convert.support.StringToEnumConverterFactory@5a85577c\njava.lang.String -> java.lang.Number : org.springframework.core.convert.support.StringToNumberConverterFactory@4a4bac52\njava.lang.String -> java.nio.charset.Charset : org.springframework.core.convert.support.StringToCharsetConverter@77b7395f\njava.lang.String -> java.time.Duration: org.springframework.format.datetime.standard.DurationFormatter@223f8ade\njava.lang.String -> java.time.Instant: org.springframework.format.datetime.standard.InstantFormatter@744a1e70\njava.lang.String -> java.time.MonthDay: org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1\njava.lang.String -> java.time.Period: org.springframework.format.datetime.standard.PeriodFormatter@326e1143\njava.lang.String -> java.time.YearMonth: org.springframework.format.datetime.standard.YearMonthFormatter@2013283d\njava.lang.String -> java.util.Currency : org.springframework.core.convert.support.StringToCurrencyConverter@73d62889\njava.lang.String -> java.util.Date: cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,java.lang.String -> java.util.Date : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$1@bda7edf,java.lang.String -> @org.springframework.format.annotation.DateTimeFormat java.util.Date: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed\njava.lang.String -> java.util.Locale : org.springframework.core.convert.support.StringToLocaleConverter@15f3ecb1\njava.lang.String -> java.util.Properties : org.springframework.core.convert.support.StringToPropertiesConverter@1734f8d8\njava.lang.String -> java.util.TimeZone : org.springframework.core.convert.support.StringToTimeZoneConverter@219e655b\njava.lang.String -> java.util.UUID : org.springframework.core.convert.support.StringToUUIDConverter@7a2a1350\njava.nio.charset.Charset -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@79cac565\njava.time.Duration -> java.lang.String : org.springframework.format.datetime.standard.DurationFormatter@223f8ade\njava.time.Instant -> java.lang.Long : org.springframework.format.datetime.standard.DateTimeConverters$InstantToLongConverter@bbf9adc\njava.time.Instant -> java.lang.String : org.springframework.format.datetime.standard.InstantFormatter@744a1e70\njava.time.LocalDateTime -> java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalDateConverter@224c05f6\njava.time.LocalDateTime -> java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalTimeConverter@bb6fc38\njava.time.MonthDay -> java.lang.String : org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1\njava.time.OffsetDateTime -> java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToInstantConverter@7e4083f\njava.time.OffsetDateTime -> java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateConverter@1e188fca\njava.time.OffsetDateTime -> java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateTimeConverter@79b804b1\njava.time.OffsetDateTime -> java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalTimeConverter@178638ba\njava.time.OffsetDateTime -> java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToZonedDateTimeConverter@5dd8aa91\njava.time.Period -> java.lang.String : org.springframework.format.datetime.standard.PeriodFormatter@326e1143\njava.time.YearMonth -> java.lang.String : org.springframework.format.datetime.standard.YearMonthFormatter@2013283d\njava.time.ZoneId -> java.util.TimeZone : org.springframework.core.convert.support.ZoneIdToTimeZoneConverter@375fe360\njava.time.ZonedDateTime -> java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToInstantConverter@5b6ff572\njava.time.ZonedDateTime -> java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateConverter@44caea49\njava.time.ZonedDateTime -> java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateTimeConverter@748fb300\njava.time.ZonedDateTime -> java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalTimeConverter@362e6386\njava.time.ZonedDateTime -> java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToOffsetDateTimeConverter@4864c695\njava.time.ZonedDateTime -> java.util.Calendar : org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter@53757723\njava.util.Calendar -> java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@3effd16f,java.util.Calendar -> java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@6625da72\njava.util.Calendar -> java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToInstantConverter@3ea63a04\njava.util.Calendar -> java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateConverter@311b3b\njava.util.Calendar -> java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateTimeConverter@b827cbe\njava.util.Calendar -> java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalTimeConverter@27334ef2\njava.util.Calendar -> java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToOffsetDateTimeConverter@18a5b69c\njava.util.Calendar -> java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToZonedDateTimeConverter@2181b391\njava.util.Calendar -> java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@43409a9e,java.util.Calendar -> java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@25a7d510\njava.util.Currency -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@59874f76\njava.util.Date -> java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@2d72afcb,java.util.Date -> java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@60b0c620\njava.util.Date -> java.lang.String : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,@org.springframework.format.annotation.DateTimeFormat java.util.Date -> java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed\njava.util.Date -> java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@635f0388,java.util.Date -> java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@7b746ecc\njava.util.Locale -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@572faa97\njava.util.Properties -> java.lang.String : org.springframework.core.convert.support.PropertiesToStringConverter@387ae6b6\njava.util.UUID -> java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@19b50f9c\n```","slug":"Spring Webflow - 视图状态","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo9f000p00bnvar4wsgj","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"指定view-state的view属性的几种方式\"><a href=\"#指定view-state的view属性的几种方式\" class=\"headerlink\" title=\"指定view-state的view属性的几种方式\"></a>指定view-state的view属性的几种方式</h2><ul>\n<li>按照默认名称在相对路径下查找view</li>\n</ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在flow配置文件同目录下查找名为enterBookingDetails的视图 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot;&gt;</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n\n\n<ul>\n<li>指明view名称，在相对路径下查找view</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在flow配置文件同目录下查找名为bookingDetails.xhtml的视图 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;bookingDetails.xhtml&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>绝对路径查找view</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 直接查找/WEB-INF/hotels/booking/bookingDetails.xhtml的视图 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;/WEB-INF/hotels/booking/bookingDetails.xhtml&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照逻辑ID定位view<br>这是结合Spring提供的其它viewResolver来定位到其他组件中的view，如Tiles等。在前面 <a href=\"https://blog.csdn.net/zou8944/article/details/82391712\" target=\"_blank\" rel=\"noopener\">配置</a> 一章中有讲</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 结合viewResolver共同确定视图位 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;bookingDetails&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在viewScope中分配变量\"><a href=\"#在viewScope中分配变量\" class=\"headerlink\" title=\"在viewScope中分配变量\"></a>在viewScope中分配变量</h2><ul>\n<li>直接分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.SearchCriteria&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>依靠运算结果分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;on-render&gt;</span><br><span class=\"line\">  \t &lt;evaluate expression=&quot;bookingService.findHotels(searchCriteria)&quot; result=&quot;viewScope.hotels&quot; /&gt;</span><br><span class=\"line\">&lt;/on-render&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在viewScope中操作对象\"><a href=\"#在viewScope中操作对象\" class=\"headerlink\" title=\"在viewScope中操作对象\"></a>在viewScope中操作对象</h2><p>如下例子展示了如何在同一个view state的不同时机操作一系列对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;searchResults&quot;&gt;</span><br><span class=\"line\">   \t&lt;on-render&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;bookingService.findHotels(searchCriteria)&quot;</span><br><span class=\"line\">                 result=&quot;viewScope.hotels&quot; /&gt;</span><br><span class=\"line\">\t&lt;/on-render&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;next&quot;&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class=\"line\">\t&lt;/transition&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;previous&quot;&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;searchCriteria.previousPage()&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class=\"line\">\t&lt;/transition&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br><span class=\"line\">&lt;!-- 渲染view之前，首先执行findHotels方法，将结果放到viewScope的hotels中 --&gt;</span><br><span class=\"line\">&lt;!-- 当返回next事件时，执行nextPage()方法， 然后渲染查找结果部分 --&gt;</span><br><span class=\"line\">&lt;!-- 当返回previous事件时，执行前一页操作，然后渲染查找结果部分 --&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"lt-on-render-gt\"><a href=\"#lt-on-render-gt\" class=\"headerlink\" title=\"&lt;on-render&gt;\"></a><code>&lt;on-render&gt;</code></h2><p>在view渲染前可以执行一个或多个action，<strong>这些action将会在视图最开始渲染以及后续的任何刷新，甚至视图局部的重新渲染执行</strong>。以上面的代码为例，在重新渲染结果之前，还会先执行一次findHotels方法。</p>\n<p>##数据绑定</p>\n<h2 id=\"在view-state上绑定model\"><a href=\"#在view-state上绑定model\" class=\"headerlink\" title=\"在view-state上绑定model\"></a>在view-state上绑定model</h2><p>使用model属性，可以将一个对象绑定到view中的表单中。web flow可以帮助完成对象属性和表单域的绑定和验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>绑定时机是当view的event发生时</p>\n<ul>\n<li><p><code>view-to-model</code>绑定：在view完成并回发时，用户的输入域会被绑定到指定对象的属性上</p>\n</li>\n<li><p><code>model</code>验证：绑定后，如果需要验证，验证逻辑会被调用。</p>\n</li>\n<li><p>需要指出的是：只有当验证成功后才能transition到别的state，验证失败时会重新渲染该view，要求用户重新输入。<br>##绑定model时的类型转换<br>####基础<br>由于客户端上传的表单数据都是字符串类型的， 因此需要进行类型转换</p>\n</li>\n<li><p>Web Flow类型转换和Spring MVC的类型转换的关系<br>在web-flow 2.1以前，Sprign MVC和web-flow使用不同的类型转换机制，但是2.1以后，二者使用相同的类型转换<br><strong>以前</strong>，Web Flow使用<code>spring-binding-2.4.6.RELEASE.jar</code>包提供的API进行类型转换，相关的类有<code>org.springframework.binding.convert.service.DefaultConversionService</code>， <code>org.springframework.binding.convert.converters.Converter</code>等，通过实现<code>Converter</code>接口完成自定义转换器，再通过<code>DefaultConversionService</code>进行注册，就像如下所示的方式1那样；而且这样还能够注册带命名ID的转换器，可以结合<code>&lt;bingding&gt;</code>的<code>converter</code>属性进行使用，但这种方式已经非常不建议了。<br><strong>目前</strong>， Web Flow在执行conversionService时依然使用<code>org.springframework.binding.convert.service.DefaultConversionService</code>，但该服务已经不会去注册任何默认的转换器和格式化器了，而是将转换和格式任务全部委托给来自<code>spring-core-4.3.7.RELEASE.jar</code>包的<code>org.springframework.core.convert.ConversionService</code>完成。<code>DefaultConversionService</code>内部维护一个<code>ConversionService</code>对象，对<code>DefaultConversionService</code>中进行的大多数操作都被转变成对<code>ConversionService</code>的操作(对带命名ID转换器的管理除外)。值得一提的是，命名ID的转换器非常没有必要，因为在检测到相应类型后，系统会自动调用合适的转换器。</p>\n</li>\n<li><p>方式一 传统方式添加Converter(不建议使用)</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.binding.convert.converters.Converter;</span><br><span class=\"line\">// 定义自己的转换器</span><br><span class=\"line\">public class DateConverter implements Converter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Class&lt;?&gt; getSourceClass() &#123;</span><br><span class=\"line\">        return String.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Class&lt;?&gt; getTargetClass() &#123;</span><br><span class=\"line\">        return java.util.Date.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object convertSourceToTargetClass(Object source, Class&lt;?&gt; targetClass) throws Exception &#123;</span><br><span class=\"line\">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return sdf.parse(source.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注册自己的转换器</span><br><span class=\"line\">public class ApplicationConversionService extends DefaultConversionService &#123;</span><br><span class=\"line\">\tpublic ApplicationConversionService() &#123;</span><br><span class=\"line\">   \t\taddConverter(new DateConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 使用转换器，什么都不用指定，当检测到model中的checkinDate属性为Date类型时，DateConverter会自动被调用 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">   \t&lt;binder&gt;</span><br><span class=\"line\">       \t&lt;binding property=&quot;checkinDate&quot;/&gt;</span><br><span class=\"line\">   \t&lt;/binder&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方式二 添加带ID的Converter(已过时，不推荐使用)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateConverter的定义不变</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注册时指定id</span><br><span class=\"line\">public class ApplicationConversionService extends DefaultConversionService &#123;</span><br><span class=\"line\">\tpublic ApplicationConversionService() &#123;</span><br><span class=\"line\">\t\t// 该方法已被标为deprecated</span><br><span class=\"line\">   \t\taddConverter(&quot;dateConverter&quot;, new DateConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 使用时指定id --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">   \t&lt;binder&gt;</span><br><span class=\"line\">       \t&lt;binding property=&quot;checkinDate&quot; converter=&quot;dateConverter&quot;/&gt;</span><br><span class=\"line\">   \t&lt;/binder&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方式三 - 配置通用的Converter和Formatter(推荐使用，当前版本鼓励的方式)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先实现FormattingConversionServiceFactoryBean，添加自定义格式化器和转换器</span><br><span class=\"line\">public class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setConverters(Set&lt;?&gt; converters) &#123;</span><br><span class=\"line\">        Converter&lt;String, Date&gt; converter = new Converter&lt;String, Date&gt;() &#123;</span><br><span class=\"line\">            public Date convert(String source) &#123;</span><br><span class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">                return sdf.parse(source);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Set&lt;Converter&lt;String, Date&gt;&gt; set = new HashSet&lt;Converter&lt;String,Date&gt;&gt;();</span><br><span class=\"line\">        set.add(converter);</span><br><span class=\"line\">        super.setConverters(set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setFormatters(Set&lt;?&gt; formatters) &#123;</span><br><span class=\"line\">        Set&lt;Formatter&lt;Date&gt;&gt; set= new HashSet&lt;Formatter&lt;Date&gt;&gt;();</span><br><span class=\"line\">        set.add(new Formatter&lt;Date&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            public String print(Date object, Locale locale) &#123;</span><br><span class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">                return sdf.format(object);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            public Date parse(String text, Locale locale) throws ParseException &#123;</span><br><span class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">                return sdf.parse(text);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        super.setFormatters(set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建由ApplicationConversionServiceFactoryBean产生的ConversionService</span><br><span class=\"line\">// 该ConversionService是Spring MVC中类型转换的核心，可以同时配置给Spring MVC和Web Flow</span><br><span class=\"line\">@Bean(&quot;applicationConversionService&quot;)</span><br><span class=\"line\">public ConversionService applicationConversionService() &#123;</span><br><span class=\"line\">    FormattingConversionServiceFactoryBean factory = new ApplicationConversionServiceFactoryBean();</span><br><span class=\"line\">    // 添加自定义格式化器</span><br><span class=\"line\">    factory.setFormatters(null);</span><br><span class=\"line\">    // 添加自定义格式转换器</span><br><span class=\"line\">    factory.setConverters(null);</span><br><span class=\"line\">    // 生成ConversionService </span><br><span class=\"line\">    factory.afterPropertiesSet();</span><br><span class=\"line\">    // 返回ConversionService </span><br><span class=\"line\">    return factory.getObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下面三个步骤用于配置给Web Flow</span><br><span class=\"line\"></span><br><span class=\"line\">@Bean(&quot;defaultConversionService&quot;)</span><br><span class=\"line\">public DefaultConversionService conversionService(@Autowired ConversionService applicationConversionService) &#123;</span><br><span class=\"line\">    return new DefaultConversionService(applicationConversionService);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Bean</span><br><span class=\"line\">public FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator, @Autowired DefaultConversionService defaultConversionService) &#123;</span><br><span class=\"line\">    return getFlowBuilderServicesBuilder()</span><br><span class=\"line\">            .setConversionService(defaultConversionService)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 注册flow</span><br><span class=\"line\">@Bean(&quot;flowRegistry&quot;)</span><br><span class=\"line\">public FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return getFlowDefinitionRegistryBuilder()</span><br><span class=\"line\">            .setBasePath(&quot;/WEB-INF/jsp/flow&quot;)</span><br><span class=\"line\">            .addFlowLocation(&quot;/config/search-flow.xml&quot;)</span><br><span class=\"line\">            .setFlowBuilderServices(flowBuilderServices)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 下面的步骤用于注册给Spring MVC --&gt;</span><br><span class=\"line\">&lt;mvc:annotation-driven conversion-service=&quot;applicationConversionService&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>针对上述三种方式的说明<ul>\n<li>方式一表面上使用的是旧的转换器添加方式，但内部实现还是按照新的方式进行，在添加Converter时，会通过一个适配器类转换将<code>org.springframework.binding.convert.converters.Converter</code>转换为<code>org.springframework.core.convert.converter.GenericConverter</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源码片段</span><br><span class=\"line\">public void addConverter(Converter converter) &#123;</span><br><span class=\"line\">\t((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(converter));</span><br><span class=\"line\">\tif (converter instanceof TwoWayConverter) &#123;</span><br><span class=\"line\">\t\tTwoWayConverter twoWayConverter = (TwoWayConverter) converter;</span><br><span class=\"line\">\t\t((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(new ReverseConverter(</span><br><span class=\"line\">\t\t\t\ttwoWayConverter)));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方式二已过时，这里仅展示</li>\n<li>方式三推荐使用，但这里仅展示了我自己实验成功的java config配置方式，xml配置方式可以参见<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration\" target=\"_blank\" rel=\"noopener\">官网</a>。</li>\n<li>实际使用时，会发现方式一从视图提交到model时类型转换能够正常进行，但是从model回填到视图时并非自己最开始输入的数值，那是因为我们只设置了Converter，没有设置Formatter。</li>\n<li>关于转换器的配置，只要认识到ConversionService是类型转换的核心，就会省事很多</li>\n</ul>\n<h2 id=\"Converter和Formatter的区别\"><a href=\"#Converter和Formatter的区别\" class=\"headerlink\" title=\"Converter和Formatter的区别\"></a>Converter和Formatter的区别</h2><ul>\n<li><code>Converter</code>: 是<code>spring-core-4.3.7.RELEASE.jar</code>包提供的，用于<code>Object to Object</code>的转换</li>\n<li><code>Formatter</code>: 是<code>spring-context-4.3.7.RELEASE.jar</code>包提供的，用于<code>Object to String</code>的转换。</li>\n</ul>\n<h2 id=\"格式化注解\"><a href=\"#格式化注解\" class=\"headerlink\" title=\"格式化注解\"></a>格式化注解</h2><p>新的类型转换提供两个有用的注解，可以放在model类的属性上，和被@Controller类的方法参数中。</p>\n<ul>\n<li><code>NumberFormat</code></li>\n<li><code>DateTimeFormat</code>： 该注解默认使用<a href=\"http://www.joda.org/joda-time/\" target=\"_blank\" rel=\"noopener\"><code>Joda Time</code></a>，需要在类路径中包含Joda Time的包。默认情况下Spring MVC和web flow都没有其他的日期相关的转换器和格式化器。因此定义我们自己的日期相关转换器和格式化器非常重要。</li>\n<li>此外，我们还可以参照上述两个注解定义自己的注解.</li>\n</ul>\n<h2 id=\"关于绑定的另外两点\"><a href=\"#关于绑定的另外两点\" class=\"headerlink\" title=\"关于绑定的另外两点\"></a>关于绑定的另外两点</h2><ul>\n<li>取消绑定<br>可以使用bind属性在特定情况下取消绑定。如下当触发cancel事件时不会执行绑定操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; bind=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>显式地指明绑定的字段<br>使用<binder>标签可以显式指明需要绑定的字段，同时可以指明需要使用到的转换器，和是否允许为空。</binder></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">    &lt;binder&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;checkinDate&quot; converter=&quot;shortDate&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;checkoutDate&quot; converter=&quot;shortDate&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;creditCard&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;creditCardName&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;creditCardExpiryMonth&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;creditCardExpiryYear&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">    &lt;/binder&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; bind=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意事项</p>\n<ol>\n<li>没有显式指定绑定字段时，所有model对象的公共属性都会被绑定；指定绑定字段时，则只有显式指定的字段会被绑定</li>\n<li>没有显式声明转换器时，会使用自动检测的转换器</li>\n<li>声明不允许为空时，若出现空，则会产生验证错误，并会重新绘制视图并报错。<br>##绑定数据的验证<br>Web Flow支持自定义验证条件和JSR-303 Bean验证框架<br>####JSR-303 Bean Validation<ul>\n<li>基础配置<br>首先类路径中需要有一个validator的jar包，然后按照如下配置后，validator会应用到所有的添加了条件注解的model属性中</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry flow-builder-services=&quot;flowBuilderServices&quot; /&gt;</span><br><span class=\"line\">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; validator=&quot;validator&quot; /&gt;</span><br><span class=\"line\">&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;form中按如下方式配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NotNull</span><br><span class=\"line\">@Size(min = 2, max = 30, message=&quot;at least 3 chars&quot; )</span><br><span class=\"line\">private String name;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;前端按如下配置，使用<code>&lt;sf:errors&gt;</code>可将name属性的错误信息显示出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">    Name: &lt;sf:input path=&quot;name&quot;/&gt; &lt;sf:errors path=&quot;name&quot;&gt;&lt;/sf:errors&gt;&lt;br/&gt;</span><br><span class=\"line\">       &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class=\"line\">&lt;/sf:form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;效果如下<br><img src=\"https://img-blog.csdn.net/20180909184901856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>部分验证<br>JSR-303支持部分验证，通过验证组的方式，使用如下(我在验证该方式时是不行的，提示viwe-state标签不允许出现validation-hints属性)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NotNull</span><br><span class=\"line\">@Size(min = 2, max = 30, groups = State1.class)</span><br><span class=\"line\">private String name;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;state1&quot; model=&quot;myModel&quot; validation-hints=&quot;&apos;group1,group2&apos;&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;对该方法不做详细解释，最好还是参考一下JSR-303再来看</p>\n<h2 id=\"自定义验证\"><a href=\"#自定义验证\" class=\"headerlink\" title=\"自定义验证\"></a>自定义验证</h2><p>JSR-303仅支持对Bean的验证，如非空，字符串长度等。我们经常需要自定义验证逻辑，有如下两种方式进行自定义</p>\n<ul>\n<li>一是在model类内部定义一个以<code>validate${stateId}(ValidationContext)</code>为签名的方法，在view提交时会自动调用该验证方法。stateId是view-state的id</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 官方示例</span><br><span class=\"line\">public class Booking &#123;</span><br><span class=\"line\">    private Date checkinDate;</span><br><span class=\"line\">    private Date checkoutDate;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void validateEnterBookingDetails(ValidationContext context) &#123;</span><br><span class=\"line\">        MessageContext messages = context.getMessageContext();</span><br><span class=\"line\">        if (checkinDate.before(today())) &#123;</span><br><span class=\"line\">            messages.addMessage(new MessageBuilder().error().source(&quot;checkinDate&quot;).</span><br><span class=\"line\">                defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class=\"line\">        &#125; else if (!checkinDate.before(checkoutDate)) &#123;</span><br><span class=\"line\">            messages.addMessage(new MessageBuilder().error().source(&quot;checkoutDate&quot;).</span><br><span class=\"line\">                defaultText(&quot;Check out date must be later than check in date&quot;).build());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>二是单独定义一个类，类名为<code>${model}Validator</code>，在其内部定义一个以<code>validate${stateId}(${model}, ValidationContext)</code>为签名的方法，然后将该类装载到Spring中。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 官方示例</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class BookingValidator &#123;</span><br><span class=\"line\">    public void validateEnterBookingDetails(Booking booking, ValidationContext context) &#123;</span><br><span class=\"line\">        MessageContext messages = context.getMessageContext();</span><br><span class=\"line\">        if (booking.getCheckinDate().before(today())) &#123;</span><br><span class=\"line\">            messages.addMessage(new MessageBuilder().error().source(&quot;checkinDate&quot;).</span><br><span class=\"line\">                defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class=\"line\">        &#125; else if (!booking.getCheckinDate().before(booking.getCheckoutDate())) &#123;</span><br><span class=\"line\">            messages.addMessage(new MessageBuilder().error().source(&quot;checkoutDate&quot;).</span><br><span class=\"line\">                defaultText(&quot;Check out date must be later than check in date&quot;).build());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;针对第二种情况也可以定义一个<code>validate(${model}, ValidationContext)</code>方法，这样无论在哪个view-state的view返回时，只要绑定了该moel，都会调用该验证方法。<br>&emsp;&emsp;当<code>validate(${model}, ValidationContext)</code>和validate<code>${stateId}(${model}, ValidationContext)</code>都存在时，会先调用后者，再调用前者。</p>\n<h2 id=\"多说两点\"><a href=\"#多说两点\" class=\"headerlink\" title=\"多说两点\"></a>多说两点</h2><ul>\n<li>失能验证<br>通过如下方式可以在局部使得验证失效</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;chooseAmenities&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;back&quot; to=&quot;enterBookingDetails&quot; validate=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"转移\"><a href=\"#转移\" class=\"headerlink\" title=\"转移\"></a>转移</h1><p>在一个view-state中，可能发生各种转移</p>\n<ul>\n<li>转移之前执行操作<br>可以在转移之前执行特定的操作，如一个方法， 当方法返回false或者发生错误时，转移不会继续进行下去。而是重新渲染相应的部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;submit&quot; to=&quot;bookingConfirmed&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate expression=&quot;bookingAction.makeBooking(booking, messageContext)&quot; /&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局转移<br>定义全局有效的转移操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;global-transitions&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;login&quot; to=&quot;login&quot; /&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;logout&quot; to=&quot;logout&quot; /&gt;</span><br><span class=\"line\">&lt;/global-transitions&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>事件处理器<br>可以利用transition标签只响应事件，而不做任何跳转操作，从而作为事件处理器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;event&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Handle event --&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>局部渲染<br>利用<code>&lt;render&gt;</code>标签可以进行局部渲染，一般用于Ajax的局部刷新操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;next&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br><span class=\"line\">    &lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;如上，当发生next事件时，首先执行翻页操作，然后重新刷新查询结果区域。fragment属性应该引用想要刷新的view的id,当刷新多个区域时，使用逗号隔开。</p>\n<h1 id=\"view的回退控制\"><a href=\"#view的回退控制\" class=\"headerlink\" title=\"view的回退控制\"></a>view的回退控制</h1><p>当我们从一个view跳转到另一个view时，通过浏览器的回退按钮，可以返回上一个view，我们可以对这个功能进行配置</p>\n<ul>\n<li>失能一个回退view，即当前view不能再下一个view上回退，回退到的是前一个view</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; history=&quot;discard&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>失能所有回退view，即当前及之前所有view都是不能够被回退的。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;confirm&quot; to=&quot;bookingConfirmed&quot; history=&quot;invalidate&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>##MessageContext<br>Spring web flow的MessageContext是用来记录在flow执行期间的信息的。而其中包含的信息都由MessageBuilder产生，可以手动添加，也可以由系统自动产生。</p>\n<h2 id=\"手动添加信息\"><a href=\"#手动添加信息\" class=\"headerlink\" title=\"手动添加信息\"></a>手动添加信息</h2><ul>\n<li>手动添加普通文本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageContext context = ...（这里一般是从上一级获取到context对象）</span><br><span class=\"line\">MessageBuilder builder = new MessageBuilder();</span><br><span class=\"line\">context.addMessage(builder.error().source(&quot;checkinDate&quot;)</span><br><span class=\"line\">    .defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class=\"line\">context.addMessage(builder.warn().source(&quot;smoking&quot;)</span><br><span class=\"line\">    .defaultText(&quot;Smoking is bad for your health&quot;).build());</span><br><span class=\"line\">context.addMessage(builder.info()</span><br><span class=\"line\">    .defaultText(&quot;We have processed your reservation - thank you and enjoy your stay&quot;).build());</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>添加Spring MessageSource得到的信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageContext context = ...</span><br><span class=\"line\">MessageBuilder builder = new MessageBuilder();</span><br><span class=\"line\">context.addMessage(builder.error().source(&quot;checkinDate&quot;).code(&quot;checkinDate.notFuture&quot;).build());</span><br><span class=\"line\">context.addMessage(builder.warn().source(&quot;smoking&quot;).code(&quot;notHealthy&quot;)</span><br><span class=\"line\">    .resolvableArg(&quot;smoking&quot;).build());</span><br><span class=\"line\">context.addMessage(builder.info().code(&quot;reservationConfirmation&quot;).build());</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>添加message bundle获取的信息<br>可以直接在view或flow中使用<code>resourceBundle</code>这个EL变量来获取资源文件中的内容。(这个需要在web-flow同目录下放置一个<code>message.properties</code>文件)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input value=&quot;#&#123;resourceBundle.reservationConfirmation&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"系统自动产生信息\"><a href=\"#系统自动产生信息\" class=\"headerlink\" title=\"系统自动产生信息\"></a>系统自动产生信息</h2><p>&emsp;&emsp;有多重情况下web-flow会自动生成message,其中一种重要的情况是当view-to-model验证失败时，生成规则是，首先到资源文件中查找key为<code>${model}l.${property}.${errCode}</code>的资源，如果找不到，则直接查找key为<code>${errCode}</code>的资源。<br>&emsp;&emsp; 举例：有model名为booking，验证其中的checkDate属性，当出现类型不匹配时，系统给出的错误代码为<code>typeMismatch</code>，则会在资源文件中查找如下key的资源<br> <code>booking.checkDate.typeMismatch</code>  或 <code>typeMismatch</code></p>\n<h1 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h1><p>下面大致列举一下Spring MVC会自动注册的转换器和格式化器(调用<code>ConversionService</code>的<code>toString()</code>方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.lang.Long -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,@org.springframework.format.annotation.NumberFormat java.lang.Long -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.LocalDate -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDate -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@1cb91eff</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2918eadb</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.LocalTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@6d563cf9</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2f20d514</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@19212c1c</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.ZonedDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2e061032</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.util.Calendar -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Byte -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Double -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Float -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Integer -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Short -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.math.BigDecimal -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.math.BigInteger -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.Boolean -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@839fe61</span><br><span class=\"line\">java.lang.Character -&gt; java.lang.Number : org.springframework.core.convert.support.CharacterToNumberFactory@30f9d9cf</span><br><span class=\"line\">java.lang.Character -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@2062b73e</span><br><span class=\"line\">java.lang.Enum -&gt; java.lang.Integer : org.springframework.core.convert.support.EnumToIntegerConverter@65bd69cd</span><br><span class=\"line\">java.lang.Enum -&gt; java.lang.String : org.springframework.core.convert.support.EnumToStringConverter@24ccca42</span><br><span class=\"line\">java.lang.Integer -&gt; java.lang.Enum : org.springframework.core.convert.support.IntegerToEnumConverterFactory@22b0410c</span><br><span class=\"line\">java.lang.Long -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$LongToInstantConverter@36c61628</span><br><span class=\"line\">java.lang.Long -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@7a56bca3,java.lang.Long -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@32680fd1</span><br><span class=\"line\">java.lang.Long -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@21f63842,java.lang.Long -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@3ae27639</span><br><span class=\"line\">java.lang.Number -&gt; java.lang.Character : org.springframework.core.convert.support.NumberToCharacterConverter@37dca65c</span><br><span class=\"line\">java.lang.Number -&gt; java.lang.Number : org.springframework.core.convert.support.NumberToNumberConverterFactory@5ad62efe</span><br><span class=\"line\">java.lang.Number -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@5dbb5323</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.lang.Long: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Long: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalDate: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalDate: org.springframework.format.datetime.standard.TemporalAccessorParser@1a482c16</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@726b4b72</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7d025d62</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.OffsetDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7b82b59</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.OffsetTime: org.springframework.format.datetime.standard.TemporalAccessorParser@5d6bf8bc</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.ZonedDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@4100b1dd</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.util.Calendar: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Byte: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Double: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Float: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Integer: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Short: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.math.BigDecimal: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.math.BigInteger: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; java.lang.Boolean : org.springframework.core.convert.support.StringToBooleanConverter@3dd765a2</span><br><span class=\"line\">java.lang.String -&gt; java.lang.Character : org.springframework.core.convert.support.StringToCharacterConverter@4b28d17b</span><br><span class=\"line\">java.lang.String -&gt; java.lang.Enum : org.springframework.core.convert.support.StringToEnumConverterFactory@5a85577c</span><br><span class=\"line\">java.lang.String -&gt; java.lang.Number : org.springframework.core.convert.support.StringToNumberConverterFactory@4a4bac52</span><br><span class=\"line\">java.lang.String -&gt; java.nio.charset.Charset : org.springframework.core.convert.support.StringToCharsetConverter@77b7395f</span><br><span class=\"line\">java.lang.String -&gt; java.time.Duration: org.springframework.format.datetime.standard.DurationFormatter@223f8ade</span><br><span class=\"line\">java.lang.String -&gt; java.time.Instant: org.springframework.format.datetime.standard.InstantFormatter@744a1e70</span><br><span class=\"line\">java.lang.String -&gt; java.time.MonthDay: org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1</span><br><span class=\"line\">java.lang.String -&gt; java.time.Period: org.springframework.format.datetime.standard.PeriodFormatter@326e1143</span><br><span class=\"line\">java.lang.String -&gt; java.time.YearMonth: org.springframework.format.datetime.standard.YearMonthFormatter@2013283d</span><br><span class=\"line\">java.lang.String -&gt; java.util.Currency : org.springframework.core.convert.support.StringToCurrencyConverter@73d62889</span><br><span class=\"line\">java.lang.String -&gt; java.util.Date: cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,java.lang.String -&gt; java.util.Date : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$1@bda7edf,java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.util.Date: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class=\"line\">java.lang.String -&gt; java.util.Locale : org.springframework.core.convert.support.StringToLocaleConverter@15f3ecb1</span><br><span class=\"line\">java.lang.String -&gt; java.util.Properties : org.springframework.core.convert.support.StringToPropertiesConverter@1734f8d8</span><br><span class=\"line\">java.lang.String -&gt; java.util.TimeZone : org.springframework.core.convert.support.StringToTimeZoneConverter@219e655b</span><br><span class=\"line\">java.lang.String -&gt; java.util.UUID : org.springframework.core.convert.support.StringToUUIDConverter@7a2a1350</span><br><span class=\"line\">java.nio.charset.Charset -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@79cac565</span><br><span class=\"line\">java.time.Duration -&gt; java.lang.String : org.springframework.format.datetime.standard.DurationFormatter@223f8ade</span><br><span class=\"line\">java.time.Instant -&gt; java.lang.Long : org.springframework.format.datetime.standard.DateTimeConverters$InstantToLongConverter@bbf9adc</span><br><span class=\"line\">java.time.Instant -&gt; java.lang.String : org.springframework.format.datetime.standard.InstantFormatter@744a1e70</span><br><span class=\"line\">java.time.LocalDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalDateConverter@224c05f6</span><br><span class=\"line\">java.time.LocalDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalTimeConverter@bb6fc38</span><br><span class=\"line\">java.time.MonthDay -&gt; java.lang.String : org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToInstantConverter@7e4083f</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateConverter@1e188fca</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateTimeConverter@79b804b1</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalTimeConverter@178638ba</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToZonedDateTimeConverter@5dd8aa91</span><br><span class=\"line\">java.time.Period -&gt; java.lang.String : org.springframework.format.datetime.standard.PeriodFormatter@326e1143</span><br><span class=\"line\">java.time.YearMonth -&gt; java.lang.String : org.springframework.format.datetime.standard.YearMonthFormatter@2013283d</span><br><span class=\"line\">java.time.ZoneId -&gt; java.util.TimeZone : org.springframework.core.convert.support.ZoneIdToTimeZoneConverter@375fe360</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToInstantConverter@5b6ff572</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateConverter@44caea49</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateTimeConverter@748fb300</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalTimeConverter@362e6386</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToOffsetDateTimeConverter@4864c695</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.util.Calendar : org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter@53757723</span><br><span class=\"line\">java.util.Calendar -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@3effd16f,java.util.Calendar -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@6625da72</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToInstantConverter@3ea63a04</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateConverter@311b3b</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateTimeConverter@b827cbe</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalTimeConverter@27334ef2</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToOffsetDateTimeConverter@18a5b69c</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToZonedDateTimeConverter@2181b391</span><br><span class=\"line\">java.util.Calendar -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@43409a9e,java.util.Calendar -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@25a7d510</span><br><span class=\"line\">java.util.Currency -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@59874f76</span><br><span class=\"line\">java.util.Date -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@2d72afcb,java.util.Date -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@60b0c620</span><br><span class=\"line\">java.util.Date -&gt; java.lang.String : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,@org.springframework.format.annotation.DateTimeFormat java.util.Date -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class=\"line\">java.util.Date -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@635f0388,java.util.Date -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@7b746ecc</span><br><span class=\"line\">java.util.Locale -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@572faa97</span><br><span class=\"line\">java.util.Properties -&gt; java.lang.String : org.springframework.core.convert.support.PropertiesToStringConverter@387ae6b6</span><br><span class=\"line\">java.util.UUID -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@19b50f9c</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"指定view-state的view属性的几种方式\"><a href=\"#指定view-state的view属性的几种方式\" class=\"headerlink\" title=\"指定view-state的view属性的几种方式\"></a>指定view-state的view属性的几种方式</h2><ul>\n<li>按照默认名称在相对路径下查找view</li>\n</ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在flow配置文件同目录下查找名为enterBookingDetails的视图 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot;&gt;</span><br></pre></td></tr></table></figure>","more":"\n\n\n<ul>\n<li>指明view名称，在相对路径下查找view</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在flow配置文件同目录下查找名为bookingDetails.xhtml的视图 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;bookingDetails.xhtml&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>绝对路径查找view</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 直接查找/WEB-INF/hotels/booking/bookingDetails.xhtml的视图 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;/WEB-INF/hotels/booking/bookingDetails.xhtml&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按照逻辑ID定位view<br>这是结合Spring提供的其它viewResolver来定位到其他组件中的view，如Tiles等。在前面 <a href=\"https://blog.csdn.net/zou8944/article/details/82391712\" target=\"_blank\" rel=\"noopener\">配置</a> 一章中有讲</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 结合viewResolver共同确定视图位 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; view=&quot;bookingDetails&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在viewScope中分配变量\"><a href=\"#在viewScope中分配变量\" class=\"headerlink\" title=\"在viewScope中分配变量\"></a>在viewScope中分配变量</h2><ul>\n<li>直接分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;var name=&quot;searchCriteria&quot; class=&quot;com.mycompany.myapp.hotels.SearchCriteria&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>依靠运算结果分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;on-render&gt;</span><br><span class=\"line\">  \t &lt;evaluate expression=&quot;bookingService.findHotels(searchCriteria)&quot; result=&quot;viewScope.hotels&quot; /&gt;</span><br><span class=\"line\">&lt;/on-render&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在viewScope中操作对象\"><a href=\"#在viewScope中操作对象\" class=\"headerlink\" title=\"在viewScope中操作对象\"></a>在viewScope中操作对象</h2><p>如下例子展示了如何在同一个view state的不同时机操作一系列对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;searchResults&quot;&gt;</span><br><span class=\"line\">   \t&lt;on-render&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;bookingService.findHotels(searchCriteria)&quot;</span><br><span class=\"line\">                 result=&quot;viewScope.hotels&quot; /&gt;</span><br><span class=\"line\">\t&lt;/on-render&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;next&quot;&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class=\"line\">\t&lt;/transition&gt;</span><br><span class=\"line\">\t&lt;transition on=&quot;previous&quot;&gt;</span><br><span class=\"line\">\t\t&lt;evaluate expression=&quot;searchCriteria.previousPage()&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class=\"line\">\t&lt;/transition&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br><span class=\"line\">&lt;!-- 渲染view之前，首先执行findHotels方法，将结果放到viewScope的hotels中 --&gt;</span><br><span class=\"line\">&lt;!-- 当返回next事件时，执行nextPage()方法， 然后渲染查找结果部分 --&gt;</span><br><span class=\"line\">&lt;!-- 当返回previous事件时，执行前一页操作，然后渲染查找结果部分 --&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"lt-on-render-gt\"><a href=\"#lt-on-render-gt\" class=\"headerlink\" title=\"&lt;on-render&gt;\"></a><code>&lt;on-render&gt;</code></h2><p>在view渲染前可以执行一个或多个action，<strong>这些action将会在视图最开始渲染以及后续的任何刷新，甚至视图局部的重新渲染执行</strong>。以上面的代码为例，在重新渲染结果之前，还会先执行一次findHotels方法。</p>\n<p>##数据绑定</p>\n<h2 id=\"在view-state上绑定model\"><a href=\"#在view-state上绑定model\" class=\"headerlink\" title=\"在view-state上绑定model\"></a>在view-state上绑定model</h2><p>使用model属性，可以将一个对象绑定到view中的表单中。web flow可以帮助完成对象属性和表单域的绑定和验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>绑定时机是当view的event发生时</p>\n<ul>\n<li><p><code>view-to-model</code>绑定：在view完成并回发时，用户的输入域会被绑定到指定对象的属性上</p>\n</li>\n<li><p><code>model</code>验证：绑定后，如果需要验证，验证逻辑会被调用。</p>\n</li>\n<li><p>需要指出的是：只有当验证成功后才能transition到别的state，验证失败时会重新渲染该view，要求用户重新输入。<br>##绑定model时的类型转换<br>####基础<br>由于客户端上传的表单数据都是字符串类型的， 因此需要进行类型转换</p>\n</li>\n<li><p>Web Flow类型转换和Spring MVC的类型转换的关系<br>在web-flow 2.1以前，Sprign MVC和web-flow使用不同的类型转换机制，但是2.1以后，二者使用相同的类型转换<br><strong>以前</strong>，Web Flow使用<code>spring-binding-2.4.6.RELEASE.jar</code>包提供的API进行类型转换，相关的类有<code>org.springframework.binding.convert.service.DefaultConversionService</code>， <code>org.springframework.binding.convert.converters.Converter</code>等，通过实现<code>Converter</code>接口完成自定义转换器，再通过<code>DefaultConversionService</code>进行注册，就像如下所示的方式1那样；而且这样还能够注册带命名ID的转换器，可以结合<code>&lt;bingding&gt;</code>的<code>converter</code>属性进行使用，但这种方式已经非常不建议了。<br><strong>目前</strong>， Web Flow在执行conversionService时依然使用<code>org.springframework.binding.convert.service.DefaultConversionService</code>，但该服务已经不会去注册任何默认的转换器和格式化器了，而是将转换和格式任务全部委托给来自<code>spring-core-4.3.7.RELEASE.jar</code>包的<code>org.springframework.core.convert.ConversionService</code>完成。<code>DefaultConversionService</code>内部维护一个<code>ConversionService</code>对象，对<code>DefaultConversionService</code>中进行的大多数操作都被转变成对<code>ConversionService</code>的操作(对带命名ID转换器的管理除外)。值得一提的是，命名ID的转换器非常没有必要，因为在检测到相应类型后，系统会自动调用合适的转换器。</p>\n</li>\n<li><p>方式一 传统方式添加Converter(不建议使用)</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.binding.convert.converters.Converter;</span><br><span class=\"line\">// 定义自己的转换器</span><br><span class=\"line\">public class DateConverter implements Converter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Class&lt;?&gt; getSourceClass() &#123;</span><br><span class=\"line\">        return String.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Class&lt;?&gt; getTargetClass() &#123;</span><br><span class=\"line\">        return java.util.Date.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object convertSourceToTargetClass(Object source, Class&lt;?&gt; targetClass) throws Exception &#123;</span><br><span class=\"line\">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        return sdf.parse(source.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注册自己的转换器</span><br><span class=\"line\">public class ApplicationConversionService extends DefaultConversionService &#123;</span><br><span class=\"line\">\tpublic ApplicationConversionService() &#123;</span><br><span class=\"line\">   \t\taddConverter(new DateConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 使用转换器，什么都不用指定，当检测到model中的checkinDate属性为Date类型时，DateConverter会自动被调用 --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">   \t&lt;binder&gt;</span><br><span class=\"line\">       \t&lt;binding property=&quot;checkinDate&quot;/&gt;</span><br><span class=\"line\">   \t&lt;/binder&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方式二 添加带ID的Converter(已过时，不推荐使用)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateConverter的定义不变</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注册时指定id</span><br><span class=\"line\">public class ApplicationConversionService extends DefaultConversionService &#123;</span><br><span class=\"line\">\tpublic ApplicationConversionService() &#123;</span><br><span class=\"line\">\t\t// 该方法已被标为deprecated</span><br><span class=\"line\">   \t\taddConverter(&quot;dateConverter&quot;, new DateConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 使用时指定id --&gt;</span><br><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">   \t&lt;binder&gt;</span><br><span class=\"line\">       \t&lt;binding property=&quot;checkinDate&quot; converter=&quot;dateConverter&quot;/&gt;</span><br><span class=\"line\">   \t&lt;/binder&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方式三 - 配置通用的Converter和Formatter(推荐使用，当前版本鼓励的方式)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先实现FormattingConversionServiceFactoryBean，添加自定义格式化器和转换器</span><br><span class=\"line\">public class ApplicationConversionServiceFactoryBean extends FormattingConversionServiceFactoryBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setConverters(Set&lt;?&gt; converters) &#123;</span><br><span class=\"line\">        Converter&lt;String, Date&gt; converter = new Converter&lt;String, Date&gt;() &#123;</span><br><span class=\"line\">            public Date convert(String source) &#123;</span><br><span class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">                return sdf.parse(source);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Set&lt;Converter&lt;String, Date&gt;&gt; set = new HashSet&lt;Converter&lt;String,Date&gt;&gt;();</span><br><span class=\"line\">        set.add(converter);</span><br><span class=\"line\">        super.setConverters(set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setFormatters(Set&lt;?&gt; formatters) &#123;</span><br><span class=\"line\">        Set&lt;Formatter&lt;Date&gt;&gt; set= new HashSet&lt;Formatter&lt;Date&gt;&gt;();</span><br><span class=\"line\">        set.add(new Formatter&lt;Date&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            public String print(Date object, Locale locale) &#123;</span><br><span class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">                return sdf.format(object);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            public Date parse(String text, Locale locale) throws ParseException &#123;</span><br><span class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class=\"line\">                return sdf.parse(text);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        super.setFormatters(set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建由ApplicationConversionServiceFactoryBean产生的ConversionService</span><br><span class=\"line\">// 该ConversionService是Spring MVC中类型转换的核心，可以同时配置给Spring MVC和Web Flow</span><br><span class=\"line\">@Bean(&quot;applicationConversionService&quot;)</span><br><span class=\"line\">public ConversionService applicationConversionService() &#123;</span><br><span class=\"line\">    FormattingConversionServiceFactoryBean factory = new ApplicationConversionServiceFactoryBean();</span><br><span class=\"line\">    // 添加自定义格式化器</span><br><span class=\"line\">    factory.setFormatters(null);</span><br><span class=\"line\">    // 添加自定义格式转换器</span><br><span class=\"line\">    factory.setConverters(null);</span><br><span class=\"line\">    // 生成ConversionService </span><br><span class=\"line\">    factory.afterPropertiesSet();</span><br><span class=\"line\">    // 返回ConversionService </span><br><span class=\"line\">    return factory.getObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下面三个步骤用于配置给Web Flow</span><br><span class=\"line\"></span><br><span class=\"line\">@Bean(&quot;defaultConversionService&quot;)</span><br><span class=\"line\">public DefaultConversionService conversionService(@Autowired ConversionService applicationConversionService) &#123;</span><br><span class=\"line\">    return new DefaultConversionService(applicationConversionService);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Bean</span><br><span class=\"line\">public FlowBuilderServices flowBuilderServices(@Autowired MvcViewFactoryCreator mvcViewFactoryCreator, @Autowired DefaultConversionService defaultConversionService) &#123;</span><br><span class=\"line\">    return getFlowBuilderServicesBuilder()</span><br><span class=\"line\">            .setConversionService(defaultConversionService)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 注册flow</span><br><span class=\"line\">@Bean(&quot;flowRegistry&quot;)</span><br><span class=\"line\">public FlowDefinitionRegistry flowRegistry(@Autowired FlowBuilderServices flowBuilderServices) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return getFlowDefinitionRegistryBuilder()</span><br><span class=\"line\">            .setBasePath(&quot;/WEB-INF/jsp/flow&quot;)</span><br><span class=\"line\">            .addFlowLocation(&quot;/config/search-flow.xml&quot;)</span><br><span class=\"line\">            .setFlowBuilderServices(flowBuilderServices)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 下面的步骤用于注册给Spring MVC --&gt;</span><br><span class=\"line\">&lt;mvc:annotation-driven conversion-service=&quot;applicationConversionService&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>针对上述三种方式的说明<ul>\n<li>方式一表面上使用的是旧的转换器添加方式，但内部实现还是按照新的方式进行，在添加Converter时，会通过一个适配器类转换将<code>org.springframework.binding.convert.converters.Converter</code>转换为<code>org.springframework.core.convert.converter.GenericConverter</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源码片段</span><br><span class=\"line\">public void addConverter(Converter converter) &#123;</span><br><span class=\"line\">\t((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(converter));</span><br><span class=\"line\">\tif (converter instanceof TwoWayConverter) &#123;</span><br><span class=\"line\">\t\tTwoWayConverter twoWayConverter = (TwoWayConverter) converter;</span><br><span class=\"line\">\t\t((ConverterRegistry) delegate).addConverter(new SpringBindingConverterAdapter(new ReverseConverter(</span><br><span class=\"line\">\t\t\t\ttwoWayConverter)));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方式二已过时，这里仅展示</li>\n<li>方式三推荐使用，但这里仅展示了我自己实验成功的java config配置方式，xml配置方式可以参见<a href=\"https://docs.spring.io/spring-webflow/docs/2.4.5.RELEASE/reference/html/views.html#converter-configuration\" target=\"_blank\" rel=\"noopener\">官网</a>。</li>\n<li>实际使用时，会发现方式一从视图提交到model时类型转换能够正常进行，但是从model回填到视图时并非自己最开始输入的数值，那是因为我们只设置了Converter，没有设置Formatter。</li>\n<li>关于转换器的配置，只要认识到ConversionService是类型转换的核心，就会省事很多</li>\n</ul>\n<h2 id=\"Converter和Formatter的区别\"><a href=\"#Converter和Formatter的区别\" class=\"headerlink\" title=\"Converter和Formatter的区别\"></a>Converter和Formatter的区别</h2><ul>\n<li><code>Converter</code>: 是<code>spring-core-4.3.7.RELEASE.jar</code>包提供的，用于<code>Object to Object</code>的转换</li>\n<li><code>Formatter</code>: 是<code>spring-context-4.3.7.RELEASE.jar</code>包提供的，用于<code>Object to String</code>的转换。</li>\n</ul>\n<h2 id=\"格式化注解\"><a href=\"#格式化注解\" class=\"headerlink\" title=\"格式化注解\"></a>格式化注解</h2><p>新的类型转换提供两个有用的注解，可以放在model类的属性上，和被@Controller类的方法参数中。</p>\n<ul>\n<li><code>NumberFormat</code></li>\n<li><code>DateTimeFormat</code>： 该注解默认使用<a href=\"http://www.joda.org/joda-time/\" target=\"_blank\" rel=\"noopener\"><code>Joda Time</code></a>，需要在类路径中包含Joda Time的包。默认情况下Spring MVC和web flow都没有其他的日期相关的转换器和格式化器。因此定义我们自己的日期相关转换器和格式化器非常重要。</li>\n<li>此外，我们还可以参照上述两个注解定义自己的注解.</li>\n</ul>\n<h2 id=\"关于绑定的另外两点\"><a href=\"#关于绑定的另外两点\" class=\"headerlink\" title=\"关于绑定的另外两点\"></a>关于绑定的另外两点</h2><ul>\n<li>取消绑定<br>可以使用bind属性在特定情况下取消绑定。如下当触发cancel事件时不会执行绑定操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; bind=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>显式地指明绑定的字段<br>使用<binder>标签可以显式指明需要绑定的字段，同时可以指明需要使用到的转换器，和是否允许为空。</binder></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;enterBookingDetails&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">    &lt;binder&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;checkinDate&quot; converter=&quot;shortDate&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;checkoutDate&quot; converter=&quot;shortDate&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;creditCard&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;creditCardName&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;creditCardExpiryMonth&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;binding property=&quot;creditCardExpiryYear&quot; required=&quot;true&quot; /&gt;</span><br><span class=\"line\">    &lt;/binder&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; bind=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意事项</p>\n<ol>\n<li>没有显式指定绑定字段时，所有model对象的公共属性都会被绑定；指定绑定字段时，则只有显式指定的字段会被绑定</li>\n<li>没有显式声明转换器时，会使用自动检测的转换器</li>\n<li>声明不允许为空时，若出现空，则会产生验证错误，并会重新绘制视图并报错。<br>##绑定数据的验证<br>Web Flow支持自定义验证条件和JSR-303 Bean验证框架<br>####JSR-303 Bean Validation<ul>\n<li>基础配置<br>首先类路径中需要有一个validator的jar包，然后按照如下配置后，validator会应用到所有的添加了条件注解的model属性中</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;webflow:flow-registry flow-builder-services=&quot;flowBuilderServices&quot; /&gt;</span><br><span class=\"line\">&lt;webflow:flow-builder-services id=&quot;flowBuilderServices&quot; validator=&quot;validator&quot; /&gt;</span><br><span class=\"line\">&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;form中按如下方式配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NotNull</span><br><span class=\"line\">@Size(min = 2, max = 30, message=&quot;at least 3 chars&quot; )</span><br><span class=\"line\">private String name;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;前端按如下配置，使用<code>&lt;sf:errors&gt;</code>可将name属性的错误信息显示出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;sf:form action=&quot;$&#123;flowExecutionUrl&#125;&amp;_eventId=submit&quot; commandName=&quot;searchForm&quot; method=&quot;post&quot;&gt;</span><br><span class=\"line\">    Name: &lt;sf:input path=&quot;name&quot;/&gt; &lt;sf:errors path=&quot;name&quot;&gt;&lt;/sf:errors&gt;&lt;br/&gt;</span><br><span class=\"line\">       &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class=\"line\">&lt;/sf:form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;效果如下<br><img src=\"https://img-blog.csdn.net/20180909184901856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pvdTg5NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>部分验证<br>JSR-303支持部分验证，通过验证组的方式，使用如下(我在验证该方式时是不行的，提示viwe-state标签不允许出现validation-hints属性)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NotNull</span><br><span class=\"line\">@Size(min = 2, max = 30, groups = State1.class)</span><br><span class=\"line\">private String name;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;state1&quot; model=&quot;myModel&quot; validation-hints=&quot;&apos;group1,group2&apos;&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;对该方法不做详细解释，最好还是参考一下JSR-303再来看</p>\n<h2 id=\"自定义验证\"><a href=\"#自定义验证\" class=\"headerlink\" title=\"自定义验证\"></a>自定义验证</h2><p>JSR-303仅支持对Bean的验证，如非空，字符串长度等。我们经常需要自定义验证逻辑，有如下两种方式进行自定义</p>\n<ul>\n<li>一是在model类内部定义一个以<code>validate${stateId}(ValidationContext)</code>为签名的方法，在view提交时会自动调用该验证方法。stateId是view-state的id</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 官方示例</span><br><span class=\"line\">public class Booking &#123;</span><br><span class=\"line\">    private Date checkinDate;</span><br><span class=\"line\">    private Date checkoutDate;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    public void validateEnterBookingDetails(ValidationContext context) &#123;</span><br><span class=\"line\">        MessageContext messages = context.getMessageContext();</span><br><span class=\"line\">        if (checkinDate.before(today())) &#123;</span><br><span class=\"line\">            messages.addMessage(new MessageBuilder().error().source(&quot;checkinDate&quot;).</span><br><span class=\"line\">                defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class=\"line\">        &#125; else if (!checkinDate.before(checkoutDate)) &#123;</span><br><span class=\"line\">            messages.addMessage(new MessageBuilder().error().source(&quot;checkoutDate&quot;).</span><br><span class=\"line\">                defaultText(&quot;Check out date must be later than check in date&quot;).build());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>二是单独定义一个类，类名为<code>${model}Validator</code>，在其内部定义一个以<code>validate${stateId}(${model}, ValidationContext)</code>为签名的方法，然后将该类装载到Spring中。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 官方示例</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class BookingValidator &#123;</span><br><span class=\"line\">    public void validateEnterBookingDetails(Booking booking, ValidationContext context) &#123;</span><br><span class=\"line\">        MessageContext messages = context.getMessageContext();</span><br><span class=\"line\">        if (booking.getCheckinDate().before(today())) &#123;</span><br><span class=\"line\">            messages.addMessage(new MessageBuilder().error().source(&quot;checkinDate&quot;).</span><br><span class=\"line\">                defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class=\"line\">        &#125; else if (!booking.getCheckinDate().before(booking.getCheckoutDate())) &#123;</span><br><span class=\"line\">            messages.addMessage(new MessageBuilder().error().source(&quot;checkoutDate&quot;).</span><br><span class=\"line\">                defaultText(&quot;Check out date must be later than check in date&quot;).build());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;针对第二种情况也可以定义一个<code>validate(${model}, ValidationContext)</code>方法，这样无论在哪个view-state的view返回时，只要绑定了该moel，都会调用该验证方法。<br>&emsp;&emsp;当<code>validate(${model}, ValidationContext)</code>和validate<code>${stateId}(${model}, ValidationContext)</code>都存在时，会先调用后者，再调用前者。</p>\n<h2 id=\"多说两点\"><a href=\"#多说两点\" class=\"headerlink\" title=\"多说两点\"></a>多说两点</h2><ul>\n<li>失能验证<br>通过如下方式可以在局部使得验证失效</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view-state id=&quot;chooseAmenities&quot; model=&quot;booking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;proceed&quot; to=&quot;reviewBooking&quot;&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;back&quot; to=&quot;enterBookingDetails&quot; validate=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/view-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"转移\"><a href=\"#转移\" class=\"headerlink\" title=\"转移\"></a>转移</h1><p>在一个view-state中，可能发生各种转移</p>\n<ul>\n<li>转移之前执行操作<br>可以在转移之前执行特定的操作，如一个方法， 当方法返回false或者发生错误时，转移不会继续进行下去。而是重新渲染相应的部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;submit&quot; to=&quot;bookingConfirmed&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate expression=&quot;bookingAction.makeBooking(booking, messageContext)&quot; /&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局转移<br>定义全局有效的转移操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;global-transitions&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;login&quot; to=&quot;login&quot; /&gt;</span><br><span class=\"line\">    &lt;transition on=&quot;logout&quot; to=&quot;logout&quot; /&gt;</span><br><span class=\"line\">&lt;/global-transitions&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>事件处理器<br>可以利用transition标签只响应事件，而不做任何跳转操作，从而作为事件处理器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;event&quot;&gt;</span><br><span class=\"line\">    &lt;!-- Handle event --&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>局部渲染<br>利用<code>&lt;render&gt;</code>标签可以进行局部渲染，一般用于Ajax的局部刷新操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;next&quot;&gt;</span><br><span class=\"line\">    &lt;evaluate expression=&quot;searchCriteria.nextPage()&quot; /&gt;</span><br><span class=\"line\">    &lt;render fragments=&quot;searchResultsFragment&quot; /&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;如上，当发生next事件时，首先执行翻页操作，然后重新刷新查询结果区域。fragment属性应该引用想要刷新的view的id,当刷新多个区域时，使用逗号隔开。</p>\n<h1 id=\"view的回退控制\"><a href=\"#view的回退控制\" class=\"headerlink\" title=\"view的回退控制\"></a>view的回退控制</h1><p>当我们从一个view跳转到另一个view时，通过浏览器的回退按钮，可以返回上一个view，我们可以对这个功能进行配置</p>\n<ul>\n<li>失能一个回退view，即当前view不能再下一个view上回退，回退到的是前一个view</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;cancel&quot; to=&quot;bookingCancelled&quot; history=&quot;discard&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>失能所有回退view，即当前及之前所有view都是不能够被回退的。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition on=&quot;confirm&quot; to=&quot;bookingConfirmed&quot; history=&quot;invalidate&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>##MessageContext<br>Spring web flow的MessageContext是用来记录在flow执行期间的信息的。而其中包含的信息都由MessageBuilder产生，可以手动添加，也可以由系统自动产生。</p>\n<h2 id=\"手动添加信息\"><a href=\"#手动添加信息\" class=\"headerlink\" title=\"手动添加信息\"></a>手动添加信息</h2><ul>\n<li>手动添加普通文本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageContext context = ...（这里一般是从上一级获取到context对象）</span><br><span class=\"line\">MessageBuilder builder = new MessageBuilder();</span><br><span class=\"line\">context.addMessage(builder.error().source(&quot;checkinDate&quot;)</span><br><span class=\"line\">    .defaultText(&quot;Check in date must be a future date&quot;).build());</span><br><span class=\"line\">context.addMessage(builder.warn().source(&quot;smoking&quot;)</span><br><span class=\"line\">    .defaultText(&quot;Smoking is bad for your health&quot;).build());</span><br><span class=\"line\">context.addMessage(builder.info()</span><br><span class=\"line\">    .defaultText(&quot;We have processed your reservation - thank you and enjoy your stay&quot;).build());</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>添加Spring MessageSource得到的信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageContext context = ...</span><br><span class=\"line\">MessageBuilder builder = new MessageBuilder();</span><br><span class=\"line\">context.addMessage(builder.error().source(&quot;checkinDate&quot;).code(&quot;checkinDate.notFuture&quot;).build());</span><br><span class=\"line\">context.addMessage(builder.warn().source(&quot;smoking&quot;).code(&quot;notHealthy&quot;)</span><br><span class=\"line\">    .resolvableArg(&quot;smoking&quot;).build());</span><br><span class=\"line\">context.addMessage(builder.info().code(&quot;reservationConfirmation&quot;).build());</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>添加message bundle获取的信息<br>可以直接在view或flow中使用<code>resourceBundle</code>这个EL变量来获取资源文件中的内容。(这个需要在web-flow同目录下放置一个<code>message.properties</code>文件)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input value=&quot;#&#123;resourceBundle.reservationConfirmation&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"系统自动产生信息\"><a href=\"#系统自动产生信息\" class=\"headerlink\" title=\"系统自动产生信息\"></a>系统自动产生信息</h2><p>&emsp;&emsp;有多重情况下web-flow会自动生成message,其中一种重要的情况是当view-to-model验证失败时，生成规则是，首先到资源文件中查找key为<code>${model}l.${property}.${errCode}</code>的资源，如果找不到，则直接查找key为<code>${errCode}</code>的资源。<br>&emsp;&emsp; 举例：有model名为booking，验证其中的checkDate属性，当出现类型不匹配时，系统给出的错误代码为<code>typeMismatch</code>，则会在资源文件中查找如下key的资源<br> <code>booking.checkDate.typeMismatch</code>  或 <code>typeMismatch</code></p>\n<h1 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h1><p>下面大致列举一下Spring MVC会自动注册的转换器和格式化器(调用<code>ConversionService</code>的<code>toString()</code>方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.lang.Long -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,@org.springframework.format.annotation.NumberFormat java.lang.Long -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.LocalDate -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDate -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@1cb91eff</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2918eadb</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.LocalTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.LocalTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@6d563cf9</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2f20d514</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.OffsetTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@19212c1c</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime -&gt; java.lang.String: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.time.ZonedDateTime -&gt; java.lang.String : org.springframework.format.datetime.standard.TemporalAccessorPrinter@2e061032</span><br><span class=\"line\">@org.springframework.format.annotation.DateTimeFormat java.util.Calendar -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Byte -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Double -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Float -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Integer -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.lang.Short -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.math.BigDecimal -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">@org.springframework.format.annotation.NumberFormat java.math.BigInteger -&gt; java.lang.String: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.Boolean -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@839fe61</span><br><span class=\"line\">java.lang.Character -&gt; java.lang.Number : org.springframework.core.convert.support.CharacterToNumberFactory@30f9d9cf</span><br><span class=\"line\">java.lang.Character -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@2062b73e</span><br><span class=\"line\">java.lang.Enum -&gt; java.lang.Integer : org.springframework.core.convert.support.EnumToIntegerConverter@65bd69cd</span><br><span class=\"line\">java.lang.Enum -&gt; java.lang.String : org.springframework.core.convert.support.EnumToStringConverter@24ccca42</span><br><span class=\"line\">java.lang.Integer -&gt; java.lang.Enum : org.springframework.core.convert.support.IntegerToEnumConverterFactory@22b0410c</span><br><span class=\"line\">java.lang.Long -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$LongToInstantConverter@36c61628</span><br><span class=\"line\">java.lang.Long -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@7a56bca3,java.lang.Long -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$LongToCalendarConverter@32680fd1</span><br><span class=\"line\">java.lang.Long -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@21f63842,java.lang.Long -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$LongToDateConverter@3ae27639</span><br><span class=\"line\">java.lang.Number -&gt; java.lang.Character : org.springframework.core.convert.support.NumberToCharacterConverter@37dca65c</span><br><span class=\"line\">java.lang.Number -&gt; java.lang.Number : org.springframework.core.convert.support.NumberToNumberConverterFactory@5ad62efe</span><br><span class=\"line\">java.lang.Number -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@5dbb5323</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.lang.Long: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed,java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Long: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalDate: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalDate: org.springframework.format.datetime.standard.TemporalAccessorParser@1a482c16</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@726b4b72</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.LocalTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.LocalTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7d025d62</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.OffsetDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.OffsetDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@7b82b59</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.OffsetTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.OffsetTime: org.springframework.format.datetime.standard.TemporalAccessorParser@5d6bf8bc</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.time.ZonedDateTime: org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory@13c06099,java.lang.String -&gt; java.time.ZonedDateTime: org.springframework.format.datetime.standard.TemporalAccessorParser@4100b1dd</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.util.Calendar: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Byte: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Double: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Float: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Integer: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.lang.Short: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.math.BigDecimal: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; @org.springframework.format.annotation.NumberFormat java.math.BigInteger: org.springframework.format.number.NumberFormatAnnotationFormatterFactory@806d8b</span><br><span class=\"line\">java.lang.String -&gt; java.lang.Boolean : org.springframework.core.convert.support.StringToBooleanConverter@3dd765a2</span><br><span class=\"line\">java.lang.String -&gt; java.lang.Character : org.springframework.core.convert.support.StringToCharacterConverter@4b28d17b</span><br><span class=\"line\">java.lang.String -&gt; java.lang.Enum : org.springframework.core.convert.support.StringToEnumConverterFactory@5a85577c</span><br><span class=\"line\">java.lang.String -&gt; java.lang.Number : org.springframework.core.convert.support.StringToNumberConverterFactory@4a4bac52</span><br><span class=\"line\">java.lang.String -&gt; java.nio.charset.Charset : org.springframework.core.convert.support.StringToCharsetConverter@77b7395f</span><br><span class=\"line\">java.lang.String -&gt; java.time.Duration: org.springframework.format.datetime.standard.DurationFormatter@223f8ade</span><br><span class=\"line\">java.lang.String -&gt; java.time.Instant: org.springframework.format.datetime.standard.InstantFormatter@744a1e70</span><br><span class=\"line\">java.lang.String -&gt; java.time.MonthDay: org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1</span><br><span class=\"line\">java.lang.String -&gt; java.time.Period: org.springframework.format.datetime.standard.PeriodFormatter@326e1143</span><br><span class=\"line\">java.lang.String -&gt; java.time.YearMonth: org.springframework.format.datetime.standard.YearMonthFormatter@2013283d</span><br><span class=\"line\">java.lang.String -&gt; java.util.Currency : org.springframework.core.convert.support.StringToCurrencyConverter@73d62889</span><br><span class=\"line\">java.lang.String -&gt; java.util.Date: cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,java.lang.String -&gt; java.util.Date : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$1@bda7edf,java.lang.String -&gt; @org.springframework.format.annotation.DateTimeFormat java.util.Date: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class=\"line\">java.lang.String -&gt; java.util.Locale : org.springframework.core.convert.support.StringToLocaleConverter@15f3ecb1</span><br><span class=\"line\">java.lang.String -&gt; java.util.Properties : org.springframework.core.convert.support.StringToPropertiesConverter@1734f8d8</span><br><span class=\"line\">java.lang.String -&gt; java.util.TimeZone : org.springframework.core.convert.support.StringToTimeZoneConverter@219e655b</span><br><span class=\"line\">java.lang.String -&gt; java.util.UUID : org.springframework.core.convert.support.StringToUUIDConverter@7a2a1350</span><br><span class=\"line\">java.nio.charset.Charset -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@79cac565</span><br><span class=\"line\">java.time.Duration -&gt; java.lang.String : org.springframework.format.datetime.standard.DurationFormatter@223f8ade</span><br><span class=\"line\">java.time.Instant -&gt; java.lang.Long : org.springframework.format.datetime.standard.DateTimeConverters$InstantToLongConverter@bbf9adc</span><br><span class=\"line\">java.time.Instant -&gt; java.lang.String : org.springframework.format.datetime.standard.InstantFormatter@744a1e70</span><br><span class=\"line\">java.time.LocalDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalDateConverter@224c05f6</span><br><span class=\"line\">java.time.LocalDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$LocalDateTimeToLocalTimeConverter@bb6fc38</span><br><span class=\"line\">java.time.MonthDay -&gt; java.lang.String : org.springframework.format.datetime.standard.MonthDayFormatter@48e0bd1</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToInstantConverter@7e4083f</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateConverter@1e188fca</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalDateTimeConverter@79b804b1</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToLocalTimeConverter@178638ba</span><br><span class=\"line\">java.time.OffsetDateTime -&gt; java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$OffsetDateTimeToZonedDateTimeConverter@5dd8aa91</span><br><span class=\"line\">java.time.Period -&gt; java.lang.String : org.springframework.format.datetime.standard.PeriodFormatter@326e1143</span><br><span class=\"line\">java.time.YearMonth -&gt; java.lang.String : org.springframework.format.datetime.standard.YearMonthFormatter@2013283d</span><br><span class=\"line\">java.time.ZoneId -&gt; java.util.TimeZone : org.springframework.core.convert.support.ZoneIdToTimeZoneConverter@375fe360</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToInstantConverter@5b6ff572</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateConverter@44caea49</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalDateTimeConverter@748fb300</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToLocalTimeConverter@362e6386</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$ZonedDateTimeToOffsetDateTimeConverter@4864c695</span><br><span class=\"line\">java.time.ZonedDateTime -&gt; java.util.Calendar : org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter@53757723</span><br><span class=\"line\">java.util.Calendar -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@3effd16f,java.util.Calendar -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToLongConverter@6625da72</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.Instant : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToInstantConverter@3ea63a04</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.LocalDate : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateConverter@311b3b</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.LocalDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalDateTimeConverter@b827cbe</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.LocalTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToLocalTimeConverter@27334ef2</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.OffsetDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToOffsetDateTimeConverter@18a5b69c</span><br><span class=\"line\">java.util.Calendar -&gt; java.time.ZonedDateTime : org.springframework.format.datetime.standard.DateTimeConverters$CalendarToZonedDateTimeConverter@2181b391</span><br><span class=\"line\">java.util.Calendar -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@43409a9e,java.util.Calendar -&gt; java.util.Date : org.springframework.format.datetime.DateFormatterRegistrar$CalendarToDateConverter@25a7d510</span><br><span class=\"line\">java.util.Currency -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@59874f76</span><br><span class=\"line\">java.util.Date -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@2d72afcb,java.util.Date -&gt; java.lang.Long : org.springframework.format.datetime.DateFormatterRegistrar$DateToLongConverter@60b0c620</span><br><span class=\"line\">java.util.Date -&gt; java.lang.String : cn.floyd.pw.flow.converter.ApplicationConversionServiceFactoryBean$2@c01b01e,@org.springframework.format.annotation.DateTimeFormat java.util.Date -&gt; java.lang.String: org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory@3de4aaed</span><br><span class=\"line\">java.util.Date -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@635f0388,java.util.Date -&gt; java.util.Calendar : org.springframework.format.datetime.DateFormatterRegistrar$DateToCalendarConverter@7b746ecc</span><br><span class=\"line\">java.util.Locale -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@572faa97</span><br><span class=\"line\">java.util.Properties -&gt; java.lang.String : org.springframework.core.convert.support.PropertiesToStringConverter@387ae6b6</span><br><span class=\"line\">java.util.UUID -&gt; java.lang.String : org.springframework.core.convert.support.ObjectToStringConverter@19b50f9c</span><br></pre></td></tr></table></figure>"},{"title":"我有点想要写博客了","date":"2019-09-06T14:31:33.000Z","_content":"> 自从入职新公司，在印象中应该是一直没有打开过自己的CSDN主页，甚至完全忘记了自己还有一个博客这件事。\n> 今天偶然间看到一篇博文，说的是搭建一个自己的博客。想着自己也一直有着这样的想法，于是回来看了看。并想着：我得重新开始写博客\n<!-- more -->\n## 这篇博文的目的\n这就是一个随笔，不是技术文章\n## 这段时间干啥了\n翻看了一下记录，上次写博客已经是非常久以前了，多久呢，得追溯到四月份。从年前开始，我一直在筹备着换工作，原来在一家外包公司，着实没有什么发展前途，学不到什么东西，博主这渣渣水平在里面都算优秀的。于是年假一回来就提了辞呈，领导也很痛快，反正外包公司不愁没人。\n三月中旬正式离职，两份工作之间间隔了整整一个月。前两周结合离职前几个失败的面试经历整理了一下技能树，补充了一些急需的知识盲区。第三周正式开始投简历找工作，统计了一下，前后面试了十几家公司，实力所限，没有大厂。不过最终也拿到了令人满意的offer。\n我算是一个半路出家的Coder，以前是做硬件的，自学得来的技术栈也相当有限，第一份工作对自己提升实在有限。新公司所用技术比较新，可以说入司时的技术栈和公司使用的技术栈唯一重合点就是Java这门语言以及一些通用知识，所以免不得很忙，哪怕工作还算轻松，但多数时间都花在学习上。\n新的工作氛围和新同事都很棒。技术氛围浓厚，尽管我尚未适应，但这就是我想要的。在这里我新学习了很多好玩的东西：函数式编程、Kotlin语言、Vertx、Postgresql、Python、Django、Rxjava。一个项目里根据不同的需要，尽量结合各种技术的优点加以应用，有很大灵活空间。这在我之前是很难想象的，以前无论是看各种网络教程还是Java相关文章，学习路线大多千篇一律，且看起来枯燥乏味。现在有了新的思路：去接触更多好玩的技术，学习它所专注解决的问题。技术不断在演进，要让自己跟着时代走。\n## 怎么想起写博客了\n今天看到一篇博文，有一句话：不会分享的程序员技术实力再强大，最终也只能做一个Coder。这不一定对，但我认为非常好。\n### 从技术分享说起\n新公司有个不成文的规定，每个员工都要做技术分享，轮着来。之前由于自己确实太渣，学习都来不及，也没啥可分享给别人的，就一直没做。现在转正了，不做也确实说不过去。于是想着就分享Kotlin吧，虽然也是新学习的，但好歹用了一个多月了。\n进入准备PPT阶段，自己头脑中有无数个想法，感觉能够讲的点很多，但真到写PPT时，竟然不知道该从何写起。而且针对每个技术点，也只能三言两语进行描述，无法深层次地进行解释。于是一个一个问题地钻，并进行记录，我第一次如此深切地感受到通过记录进行知识梳理能够如此有用。\n试想：如果针对自己学习的每一门知识，在学完之后都通过整理PPT的方式进行知识梳理，这应该会解决很多原本一知半解的问题。对技术实力的提升是很有帮助的\n### 我的一篇博文访问量破了1.8W\n这是我万万没想到的事情，随便写一写的博文竟然会有1.8W的访问量，而且有好几个评论和点赞。第一次感受到通过网络文章给自己带来的快乐。这让我觉得，花时间和经历维护一个博客获取是一件不错的事情。\n### 自己搭建网站\n前段时间参加公司发起的阿里云团购，买了一台ECS，想着也没有别的用途，也不能浪费，那就搭建一个自己的网站吧，毕竟不能浪费钱。而且自己建站也不是空穴来风，这个想法都想了很久了。那篇1.8W访问量的博文就是在之前准备网页时写的。\n最初是想从零开始搭建，现在想想也是没啥意义，完全可以使用WordPress或DJango搭建嘛，这样周期较短，自己也不容易被劝退。\n### 立个Flag\n一个月内自己的网站要建好，且每个月最少发布两篇博文，CSDN和自建网站同步更新。\n网友提的问题必须要回答（CKEditor的问题，恕在下实在忘记了，无法回答）\n\n","source":"_posts/我有点想要写博客了.md","raw":"---\ntitle: 我有点想要写博客了\ndate: 2019-09-06 22:31:33\ntags: \n    - 随笔\n    - 博客\ncategories: \n    - 随笔\n---\n> 自从入职新公司，在印象中应该是一直没有打开过自己的CSDN主页，甚至完全忘记了自己还有一个博客这件事。\n> 今天偶然间看到一篇博文，说的是搭建一个自己的博客。想着自己也一直有着这样的想法，于是回来看了看。并想着：我得重新开始写博客\n<!-- more -->\n## 这篇博文的目的\n这就是一个随笔，不是技术文章\n## 这段时间干啥了\n翻看了一下记录，上次写博客已经是非常久以前了，多久呢，得追溯到四月份。从年前开始，我一直在筹备着换工作，原来在一家外包公司，着实没有什么发展前途，学不到什么东西，博主这渣渣水平在里面都算优秀的。于是年假一回来就提了辞呈，领导也很痛快，反正外包公司不愁没人。\n三月中旬正式离职，两份工作之间间隔了整整一个月。前两周结合离职前几个失败的面试经历整理了一下技能树，补充了一些急需的知识盲区。第三周正式开始投简历找工作，统计了一下，前后面试了十几家公司，实力所限，没有大厂。不过最终也拿到了令人满意的offer。\n我算是一个半路出家的Coder，以前是做硬件的，自学得来的技术栈也相当有限，第一份工作对自己提升实在有限。新公司所用技术比较新，可以说入司时的技术栈和公司使用的技术栈唯一重合点就是Java这门语言以及一些通用知识，所以免不得很忙，哪怕工作还算轻松，但多数时间都花在学习上。\n新的工作氛围和新同事都很棒。技术氛围浓厚，尽管我尚未适应，但这就是我想要的。在这里我新学习了很多好玩的东西：函数式编程、Kotlin语言、Vertx、Postgresql、Python、Django、Rxjava。一个项目里根据不同的需要，尽量结合各种技术的优点加以应用，有很大灵活空间。这在我之前是很难想象的，以前无论是看各种网络教程还是Java相关文章，学习路线大多千篇一律，且看起来枯燥乏味。现在有了新的思路：去接触更多好玩的技术，学习它所专注解决的问题。技术不断在演进，要让自己跟着时代走。\n## 怎么想起写博客了\n今天看到一篇博文，有一句话：不会分享的程序员技术实力再强大，最终也只能做一个Coder。这不一定对，但我认为非常好。\n### 从技术分享说起\n新公司有个不成文的规定，每个员工都要做技术分享，轮着来。之前由于自己确实太渣，学习都来不及，也没啥可分享给别人的，就一直没做。现在转正了，不做也确实说不过去。于是想着就分享Kotlin吧，虽然也是新学习的，但好歹用了一个多月了。\n进入准备PPT阶段，自己头脑中有无数个想法，感觉能够讲的点很多，但真到写PPT时，竟然不知道该从何写起。而且针对每个技术点，也只能三言两语进行描述，无法深层次地进行解释。于是一个一个问题地钻，并进行记录，我第一次如此深切地感受到通过记录进行知识梳理能够如此有用。\n试想：如果针对自己学习的每一门知识，在学完之后都通过整理PPT的方式进行知识梳理，这应该会解决很多原本一知半解的问题。对技术实力的提升是很有帮助的\n### 我的一篇博文访问量破了1.8W\n这是我万万没想到的事情，随便写一写的博文竟然会有1.8W的访问量，而且有好几个评论和点赞。第一次感受到通过网络文章给自己带来的快乐。这让我觉得，花时间和经历维护一个博客获取是一件不错的事情。\n### 自己搭建网站\n前段时间参加公司发起的阿里云团购，买了一台ECS，想着也没有别的用途，也不能浪费，那就搭建一个自己的网站吧，毕竟不能浪费钱。而且自己建站也不是空穴来风，这个想法都想了很久了。那篇1.8W访问量的博文就是在之前准备网页时写的。\n最初是想从零开始搭建，现在想想也是没啥意义，完全可以使用WordPress或DJango搭建嘛，这样周期较短，自己也不容易被劝退。\n### 立个Flag\n一个月内自己的网站要建好，且每个月最少发布两篇博文，CSDN和自建网站同步更新。\n网友提的问题必须要回答（CKEditor的问题，恕在下实在忘记了，无法回答）\n\n","slug":"我有点想要写博客了","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo9f000r00bnusyzryhj","content":"<blockquote>\n<p>自从入职新公司，在印象中应该是一直没有打开过自己的CSDN主页，甚至完全忘记了自己还有一个博客这件事。<br>今天偶然间看到一篇博文，说的是搭建一个自己的博客。想着自己也一直有着这样的想法，于是回来看了看。并想着：我得重新开始写博客</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"这篇博文的目的\"><a href=\"#这篇博文的目的\" class=\"headerlink\" title=\"这篇博文的目的\"></a>这篇博文的目的</h2><p>这就是一个随笔，不是技术文章</p>\n<h2 id=\"这段时间干啥了\"><a href=\"#这段时间干啥了\" class=\"headerlink\" title=\"这段时间干啥了\"></a>这段时间干啥了</h2><p>翻看了一下记录，上次写博客已经是非常久以前了，多久呢，得追溯到四月份。从年前开始，我一直在筹备着换工作，原来在一家外包公司，着实没有什么发展前途，学不到什么东西，博主这渣渣水平在里面都算优秀的。于是年假一回来就提了辞呈，领导也很痛快，反正外包公司不愁没人。<br>三月中旬正式离职，两份工作之间间隔了整整一个月。前两周结合离职前几个失败的面试经历整理了一下技能树，补充了一些急需的知识盲区。第三周正式开始投简历找工作，统计了一下，前后面试了十几家公司，实力所限，没有大厂。不过最终也拿到了令人满意的offer。<br>我算是一个半路出家的Coder，以前是做硬件的，自学得来的技术栈也相当有限，第一份工作对自己提升实在有限。新公司所用技术比较新，可以说入司时的技术栈和公司使用的技术栈唯一重合点就是Java这门语言以及一些通用知识，所以免不得很忙，哪怕工作还算轻松，但多数时间都花在学习上。<br>新的工作氛围和新同事都很棒。技术氛围浓厚，尽管我尚未适应，但这就是我想要的。在这里我新学习了很多好玩的东西：函数式编程、Kotlin语言、Vertx、Postgresql、Python、Django、Rxjava。一个项目里根据不同的需要，尽量结合各种技术的优点加以应用，有很大灵活空间。这在我之前是很难想象的，以前无论是看各种网络教程还是Java相关文章，学习路线大多千篇一律，且看起来枯燥乏味。现在有了新的思路：去接触更多好玩的技术，学习它所专注解决的问题。技术不断在演进，要让自己跟着时代走。</p>\n<h2 id=\"怎么想起写博客了\"><a href=\"#怎么想起写博客了\" class=\"headerlink\" title=\"怎么想起写博客了\"></a>怎么想起写博客了</h2><p>今天看到一篇博文，有一句话：不会分享的程序员技术实力再强大，最终也只能做一个Coder。这不一定对，但我认为非常好。</p>\n<h3 id=\"从技术分享说起\"><a href=\"#从技术分享说起\" class=\"headerlink\" title=\"从技术分享说起\"></a>从技术分享说起</h3><p>新公司有个不成文的规定，每个员工都要做技术分享，轮着来。之前由于自己确实太渣，学习都来不及，也没啥可分享给别人的，就一直没做。现在转正了，不做也确实说不过去。于是想着就分享Kotlin吧，虽然也是新学习的，但好歹用了一个多月了。<br>进入准备PPT阶段，自己头脑中有无数个想法，感觉能够讲的点很多，但真到写PPT时，竟然不知道该从何写起。而且针对每个技术点，也只能三言两语进行描述，无法深层次地进行解释。于是一个一个问题地钻，并进行记录，我第一次如此深切地感受到通过记录进行知识梳理能够如此有用。<br>试想：如果针对自己学习的每一门知识，在学完之后都通过整理PPT的方式进行知识梳理，这应该会解决很多原本一知半解的问题。对技术实力的提升是很有帮助的</p>\n<h3 id=\"我的一篇博文访问量破了1-8W\"><a href=\"#我的一篇博文访问量破了1-8W\" class=\"headerlink\" title=\"我的一篇博文访问量破了1.8W\"></a>我的一篇博文访问量破了1.8W</h3><p>这是我万万没想到的事情，随便写一写的博文竟然会有1.8W的访问量，而且有好几个评论和点赞。第一次感受到通过网络文章给自己带来的快乐。这让我觉得，花时间和经历维护一个博客获取是一件不错的事情。</p>\n<h3 id=\"自己搭建网站\"><a href=\"#自己搭建网站\" class=\"headerlink\" title=\"自己搭建网站\"></a>自己搭建网站</h3><p>前段时间参加公司发起的阿里云团购，买了一台ECS，想着也没有别的用途，也不能浪费，那就搭建一个自己的网站吧，毕竟不能浪费钱。而且自己建站也不是空穴来风，这个想法都想了很久了。那篇1.8W访问量的博文就是在之前准备网页时写的。<br>最初是想从零开始搭建，现在想想也是没啥意义，完全可以使用WordPress或DJango搭建嘛，这样周期较短，自己也不容易被劝退。</p>\n<h3 id=\"立个Flag\"><a href=\"#立个Flag\" class=\"headerlink\" title=\"立个Flag\"></a>立个Flag</h3><p>一个月内自己的网站要建好，且每个月最少发布两篇博文，CSDN和自建网站同步更新。<br>网友提的问题必须要回答（CKEditor的问题，恕在下实在忘记了，无法回答）</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>自从入职新公司，在印象中应该是一直没有打开过自己的CSDN主页，甚至完全忘记了自己还有一个博客这件事。<br>今天偶然间看到一篇博文，说的是搭建一个自己的博客。想着自己也一直有着这样的想法，于是回来看了看。并想着：我得重新开始写博客</p>\n</blockquote>","more":"<h2 id=\"这篇博文的目的\"><a href=\"#这篇博文的目的\" class=\"headerlink\" title=\"这篇博文的目的\"></a>这篇博文的目的</h2><p>这就是一个随笔，不是技术文章</p>\n<h2 id=\"这段时间干啥了\"><a href=\"#这段时间干啥了\" class=\"headerlink\" title=\"这段时间干啥了\"></a>这段时间干啥了</h2><p>翻看了一下记录，上次写博客已经是非常久以前了，多久呢，得追溯到四月份。从年前开始，我一直在筹备着换工作，原来在一家外包公司，着实没有什么发展前途，学不到什么东西，博主这渣渣水平在里面都算优秀的。于是年假一回来就提了辞呈，领导也很痛快，反正外包公司不愁没人。<br>三月中旬正式离职，两份工作之间间隔了整整一个月。前两周结合离职前几个失败的面试经历整理了一下技能树，补充了一些急需的知识盲区。第三周正式开始投简历找工作，统计了一下，前后面试了十几家公司，实力所限，没有大厂。不过最终也拿到了令人满意的offer。<br>我算是一个半路出家的Coder，以前是做硬件的，自学得来的技术栈也相当有限，第一份工作对自己提升实在有限。新公司所用技术比较新，可以说入司时的技术栈和公司使用的技术栈唯一重合点就是Java这门语言以及一些通用知识，所以免不得很忙，哪怕工作还算轻松，但多数时间都花在学习上。<br>新的工作氛围和新同事都很棒。技术氛围浓厚，尽管我尚未适应，但这就是我想要的。在这里我新学习了很多好玩的东西：函数式编程、Kotlin语言、Vertx、Postgresql、Python、Django、Rxjava。一个项目里根据不同的需要，尽量结合各种技术的优点加以应用，有很大灵活空间。这在我之前是很难想象的，以前无论是看各种网络教程还是Java相关文章，学习路线大多千篇一律，且看起来枯燥乏味。现在有了新的思路：去接触更多好玩的技术，学习它所专注解决的问题。技术不断在演进，要让自己跟着时代走。</p>\n<h2 id=\"怎么想起写博客了\"><a href=\"#怎么想起写博客了\" class=\"headerlink\" title=\"怎么想起写博客了\"></a>怎么想起写博客了</h2><p>今天看到一篇博文，有一句话：不会分享的程序员技术实力再强大，最终也只能做一个Coder。这不一定对，但我认为非常好。</p>\n<h3 id=\"从技术分享说起\"><a href=\"#从技术分享说起\" class=\"headerlink\" title=\"从技术分享说起\"></a>从技术分享说起</h3><p>新公司有个不成文的规定，每个员工都要做技术分享，轮着来。之前由于自己确实太渣，学习都来不及，也没啥可分享给别人的，就一直没做。现在转正了，不做也确实说不过去。于是想着就分享Kotlin吧，虽然也是新学习的，但好歹用了一个多月了。<br>进入准备PPT阶段，自己头脑中有无数个想法，感觉能够讲的点很多，但真到写PPT时，竟然不知道该从何写起。而且针对每个技术点，也只能三言两语进行描述，无法深层次地进行解释。于是一个一个问题地钻，并进行记录，我第一次如此深切地感受到通过记录进行知识梳理能够如此有用。<br>试想：如果针对自己学习的每一门知识，在学完之后都通过整理PPT的方式进行知识梳理，这应该会解决很多原本一知半解的问题。对技术实力的提升是很有帮助的</p>\n<h3 id=\"我的一篇博文访问量破了1-8W\"><a href=\"#我的一篇博文访问量破了1-8W\" class=\"headerlink\" title=\"我的一篇博文访问量破了1.8W\"></a>我的一篇博文访问量破了1.8W</h3><p>这是我万万没想到的事情，随便写一写的博文竟然会有1.8W的访问量，而且有好几个评论和点赞。第一次感受到通过网络文章给自己带来的快乐。这让我觉得，花时间和经历维护一个博客获取是一件不错的事情。</p>\n<h3 id=\"自己搭建网站\"><a href=\"#自己搭建网站\" class=\"headerlink\" title=\"自己搭建网站\"></a>自己搭建网站</h3><p>前段时间参加公司发起的阿里云团购，买了一台ECS，想着也没有别的用途，也不能浪费，那就搭建一个自己的网站吧，毕竟不能浪费钱。而且自己建站也不是空穴来风，这个想法都想了很久了。那篇1.8W访问量的博文就是在之前准备网页时写的。<br>最初是想从零开始搭建，现在想想也是没啥意义，完全可以使用WordPress或DJango搭建嘛，这样周期较短，自己也不容易被劝退。</p>\n<h3 id=\"立个Flag\"><a href=\"#立个Flag\" class=\"headerlink\" title=\"立个Flag\"></a>立个Flag</h3><p>一个月内自己的网站要建好，且每个月最少发布两篇博文，CSDN和自建网站同步更新。<br>网友提的问题必须要回答（CKEditor的问题，恕在下实在忘记了，无法回答）</p>"},{"title":"推荐系统 - 概述","date":"2019-09-08T04:03:04.000Z","_content":"# 什么是推荐系统\n\n推荐系统让用户能够发现对自己有价值的信息，另一方面，能够让信息展现在对它感兴趣的用户面前。实现消费者和生产者的双赢。\n<!-- more -->\n\n# 几个理论\n\n## 长尾理论\n\n来自市场营销上的说法。即传统认为，厂商80%的收入很可能来自20%热门商品。但在互联网条件下，由于铺货成本极其低廉，那些不热门的商品销售数量可能极其庞大，使得其销售收入与热门商品相当甚至更多。推荐系统就是基于长尾理论, 将长尾商品推荐给用户, 实现收益增加\n\n## 幂律分布\n\n一种分布， 曲线如下。长尾理论就是幂律分布的通俗体现。常见幂律分布：英文单词、个人收入等\n\n![img](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=8ab03b31e2fe9925cf0c6e5204a95ee4/cc11728b4710b9127865d50ac1fdfc0393452299.jpg)\n\n## 马太效应\n\n即两极分化效应，强者越强， 弱者越弱\n\n出自《新约·马太福音》： “凡有的，还要加倍给他叫他多余；没有的，连他所有的也要夺过来”\n\n# 推荐系统原理\n\n推荐系统并没有特别高深的理论，它只不过将我们平常的检索进行了自动化\n\n- 社会化推荐：对应于向好友咨询\n- 基于内容的推荐：对应于我们手动搜索电影片名或演员名\n- 基于协同过滤的推荐：对应于查看排行榜，找到广受好评的电影\n\n推荐的本质是将用户和物品联系起来。而不同的推荐系统只是利用了不同的联系方式\n\n# 推荐做得好的应用\n\n- 亚马逊\n  - 让每个用户像是拥有自己的专属商店一样\n  - 20-30%收入来自推荐系统\n- Netflix\n  - 举办了推荐系统比赛\n  - 自己宣称有60%的用户是通过推荐系统找到自己喜欢的影片的\n- Youtube\n  - 其实验表明。个性化推荐的视频点击率是热门视频点击率的两倍\n- 音乐电台\n  - 豆瓣电台：用户无法自己选取歌曲。只能标记喜欢或不喜欢，模型建立完成后就能够推荐用户感兴趣的歌曲。\n- facebook\n  - 利用推荐系统推荐广告、推荐信息流、推荐好友\n  - 退出了API，称为Instant Personalization，能够推荐用户的好友喜欢的物品。\n- 阅读推荐\n  - 今日头条等\n\n# 什么是好的推荐系统\n\n合格的满足如下三点\n\n- 用户能够得到自己的感兴趣的推荐内容\n- 商品提供方的物品要能够被推荐到合适的用户手中\n- 能够收集到高质量的用户反馈， 从而不断完善推荐系统， 提高推荐准确性。\n\n好的推荐系统还满足一点\n\n- 不仅能够预测用户的行为， 还能扩展用户的视野，帮助其发现潜在的新东西\n\n注意， 准确性并不能完全决定推荐算法的好坏。 比如预测太阳从东方升起，这是100%准确的预测， 但是也是一个毫无意义的预测。\n\n# 如何测试推荐系统\n\n- 离线测试：即使用现有的数据集对系统进行测试\n- 用户调查：直接上线前的测试，先做用户调查，让用户为推荐系统进行评价\n- 在线实验：用户调查完成后上线。评价的标准是做AB test，即和原有的算法进行比较。\n\n上面三个处于推荐系统的不同开发阶段。先离线测试，OK后做用户调查，OK后上线实验\n\n## 测试标准\n\n- 用户满意度\n\n- 预测准确度\n\n- 覆盖率：即对长尾物品的发掘能力。如果所有物品都出现在推荐列表中， 并且出现次数差不多， 则长尾发掘能力就好很多\n\n  两个指标定义覆盖率\n\n  - 信息熵：https://www.cnblogs.com/IamJiangXiaoKun/p/9455689.html。简单说，信息熵就是对一个不确定事件发生所可能产生的信息量的期望。而信息量和该时间发生概率的对数的倒数有关。即一个事件发生概率越高，则产生的信息量越小；概率越低，产生的信息量越大。\n\n  - 基尼系数：用于衡量收入分配是否均匀之类的问题。计算方法是A/B。当A为0时，基尼系数为0.说明绝对平等了。当A很大时，说明非常不平衡。\n\n    ![img](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2c95402b392ac65c73086e219a9bd974/b812c8fcc3cec3fdea113b3eda88d43f87942749.jpg)\n\n- 多样性：推荐多种多样的商品\n\n- 新颖性：推荐用户没听说过的商品\n\n- 惊喜度：相比新颖性，还能让用户感觉使用之后很惊喜\n\n- 信任度：涉及推荐的方式，要让用户新人所推荐的内容，愿意购买商品\n\n- 实时性：比如用户新买了一个iphone，及时给他推荐手机壳之类的\n\n- 健壮性：抗击作弊\n\n","source":"_posts/推荐系统-概述.md","raw":"---\ntitle: 推荐系统 - 概述\ndate: 2019-09-08 12:03:04\ntags:\n    - 推荐\n    - 长尾\n    - 马太效应\ncategories:\n    - 推荐系统\n---\n# 什么是推荐系统\n\n推荐系统让用户能够发现对自己有价值的信息，另一方面，能够让信息展现在对它感兴趣的用户面前。实现消费者和生产者的双赢。\n<!-- more -->\n\n# 几个理论\n\n## 长尾理论\n\n来自市场营销上的说法。即传统认为，厂商80%的收入很可能来自20%热门商品。但在互联网条件下，由于铺货成本极其低廉，那些不热门的商品销售数量可能极其庞大，使得其销售收入与热门商品相当甚至更多。推荐系统就是基于长尾理论, 将长尾商品推荐给用户, 实现收益增加\n\n## 幂律分布\n\n一种分布， 曲线如下。长尾理论就是幂律分布的通俗体现。常见幂律分布：英文单词、个人收入等\n\n![img](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=8ab03b31e2fe9925cf0c6e5204a95ee4/cc11728b4710b9127865d50ac1fdfc0393452299.jpg)\n\n## 马太效应\n\n即两极分化效应，强者越强， 弱者越弱\n\n出自《新约·马太福音》： “凡有的，还要加倍给他叫他多余；没有的，连他所有的也要夺过来”\n\n# 推荐系统原理\n\n推荐系统并没有特别高深的理论，它只不过将我们平常的检索进行了自动化\n\n- 社会化推荐：对应于向好友咨询\n- 基于内容的推荐：对应于我们手动搜索电影片名或演员名\n- 基于协同过滤的推荐：对应于查看排行榜，找到广受好评的电影\n\n推荐的本质是将用户和物品联系起来。而不同的推荐系统只是利用了不同的联系方式\n\n# 推荐做得好的应用\n\n- 亚马逊\n  - 让每个用户像是拥有自己的专属商店一样\n  - 20-30%收入来自推荐系统\n- Netflix\n  - 举办了推荐系统比赛\n  - 自己宣称有60%的用户是通过推荐系统找到自己喜欢的影片的\n- Youtube\n  - 其实验表明。个性化推荐的视频点击率是热门视频点击率的两倍\n- 音乐电台\n  - 豆瓣电台：用户无法自己选取歌曲。只能标记喜欢或不喜欢，模型建立完成后就能够推荐用户感兴趣的歌曲。\n- facebook\n  - 利用推荐系统推荐广告、推荐信息流、推荐好友\n  - 退出了API，称为Instant Personalization，能够推荐用户的好友喜欢的物品。\n- 阅读推荐\n  - 今日头条等\n\n# 什么是好的推荐系统\n\n合格的满足如下三点\n\n- 用户能够得到自己的感兴趣的推荐内容\n- 商品提供方的物品要能够被推荐到合适的用户手中\n- 能够收集到高质量的用户反馈， 从而不断完善推荐系统， 提高推荐准确性。\n\n好的推荐系统还满足一点\n\n- 不仅能够预测用户的行为， 还能扩展用户的视野，帮助其发现潜在的新东西\n\n注意， 准确性并不能完全决定推荐算法的好坏。 比如预测太阳从东方升起，这是100%准确的预测， 但是也是一个毫无意义的预测。\n\n# 如何测试推荐系统\n\n- 离线测试：即使用现有的数据集对系统进行测试\n- 用户调查：直接上线前的测试，先做用户调查，让用户为推荐系统进行评价\n- 在线实验：用户调查完成后上线。评价的标准是做AB test，即和原有的算法进行比较。\n\n上面三个处于推荐系统的不同开发阶段。先离线测试，OK后做用户调查，OK后上线实验\n\n## 测试标准\n\n- 用户满意度\n\n- 预测准确度\n\n- 覆盖率：即对长尾物品的发掘能力。如果所有物品都出现在推荐列表中， 并且出现次数差不多， 则长尾发掘能力就好很多\n\n  两个指标定义覆盖率\n\n  - 信息熵：https://www.cnblogs.com/IamJiangXiaoKun/p/9455689.html。简单说，信息熵就是对一个不确定事件发生所可能产生的信息量的期望。而信息量和该时间发生概率的对数的倒数有关。即一个事件发生概率越高，则产生的信息量越小；概率越低，产生的信息量越大。\n\n  - 基尼系数：用于衡量收入分配是否均匀之类的问题。计算方法是A/B。当A为0时，基尼系数为0.说明绝对平等了。当A很大时，说明非常不平衡。\n\n    ![img](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2c95402b392ac65c73086e219a9bd974/b812c8fcc3cec3fdea113b3eda88d43f87942749.jpg)\n\n- 多样性：推荐多种多样的商品\n\n- 新颖性：推荐用户没听说过的商品\n\n- 惊喜度：相比新颖性，还能让用户感觉使用之后很惊喜\n\n- 信任度：涉及推荐的方式，要让用户新人所推荐的内容，愿意购买商品\n\n- 实时性：比如用户新买了一个iphone，及时给他推荐手机壳之类的\n\n- 健壮性：抗击作弊\n\n","slug":"推荐系统-概述","published":1,"updated":"2019-09-08T10:18:04.540Z","_id":"ck0atmo9h000w00bnc93j4y6o","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是推荐系统\"><a href=\"#什么是推荐系统\" class=\"headerlink\" title=\"什么是推荐系统\"></a>什么是推荐系统</h1><p>推荐系统让用户能够发现对自己有价值的信息，另一方面，能够让信息展现在对它感兴趣的用户面前。实现消费者和生产者的双赢。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"几个理论\"><a href=\"#几个理论\" class=\"headerlink\" title=\"几个理论\"></a>几个理论</h1><h2 id=\"长尾理论\"><a href=\"#长尾理论\" class=\"headerlink\" title=\"长尾理论\"></a>长尾理论</h2><p>来自市场营销上的说法。即传统认为，厂商80%的收入很可能来自20%热门商品。但在互联网条件下，由于铺货成本极其低廉，那些不热门的商品销售数量可能极其庞大，使得其销售收入与热门商品相当甚至更多。推荐系统就是基于长尾理论, 将长尾商品推荐给用户, 实现收益增加</p>\n<h2 id=\"幂律分布\"><a href=\"#幂律分布\" class=\"headerlink\" title=\"幂律分布\"></a>幂律分布</h2><p>一种分布， 曲线如下。长尾理论就是幂律分布的通俗体现。常见幂律分布：英文单词、个人收入等</p>\n<p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=8ab03b31e2fe9925cf0c6e5204a95ee4/cc11728b4710b9127865d50ac1fdfc0393452299.jpg\" alt=\"img\"></p>\n<h2 id=\"马太效应\"><a href=\"#马太效应\" class=\"headerlink\" title=\"马太效应\"></a>马太效应</h2><p>即两极分化效应，强者越强， 弱者越弱</p>\n<p>出自《新约·马太福音》： “凡有的，还要加倍给他叫他多余；没有的，连他所有的也要夺过来”</p>\n<h1 id=\"推荐系统原理\"><a href=\"#推荐系统原理\" class=\"headerlink\" title=\"推荐系统原理\"></a>推荐系统原理</h1><p>推荐系统并没有特别高深的理论，它只不过将我们平常的检索进行了自动化</p>\n<ul>\n<li>社会化推荐：对应于向好友咨询</li>\n<li>基于内容的推荐：对应于我们手动搜索电影片名或演员名</li>\n<li>基于协同过滤的推荐：对应于查看排行榜，找到广受好评的电影</li>\n</ul>\n<p>推荐的本质是将用户和物品联系起来。而不同的推荐系统只是利用了不同的联系方式</p>\n<h1 id=\"推荐做得好的应用\"><a href=\"#推荐做得好的应用\" class=\"headerlink\" title=\"推荐做得好的应用\"></a>推荐做得好的应用</h1><ul>\n<li>亚马逊<ul>\n<li>让每个用户像是拥有自己的专属商店一样</li>\n<li>20-30%收入来自推荐系统</li>\n</ul>\n</li>\n<li>Netflix<ul>\n<li>举办了推荐系统比赛</li>\n<li>自己宣称有60%的用户是通过推荐系统找到自己喜欢的影片的</li>\n</ul>\n</li>\n<li>Youtube<ul>\n<li>其实验表明。个性化推荐的视频点击率是热门视频点击率的两倍</li>\n</ul>\n</li>\n<li>音乐电台<ul>\n<li>豆瓣电台：用户无法自己选取歌曲。只能标记喜欢或不喜欢，模型建立完成后就能够推荐用户感兴趣的歌曲。</li>\n</ul>\n</li>\n<li>facebook<ul>\n<li>利用推荐系统推荐广告、推荐信息流、推荐好友</li>\n<li>退出了API，称为Instant Personalization，能够推荐用户的好友喜欢的物品。</li>\n</ul>\n</li>\n<li>阅读推荐<ul>\n<li>今日头条等</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"什么是好的推荐系统\"><a href=\"#什么是好的推荐系统\" class=\"headerlink\" title=\"什么是好的推荐系统\"></a>什么是好的推荐系统</h1><p>合格的满足如下三点</p>\n<ul>\n<li>用户能够得到自己的感兴趣的推荐内容</li>\n<li>商品提供方的物品要能够被推荐到合适的用户手中</li>\n<li>能够收集到高质量的用户反馈， 从而不断完善推荐系统， 提高推荐准确性。</li>\n</ul>\n<p>好的推荐系统还满足一点</p>\n<ul>\n<li>不仅能够预测用户的行为， 还能扩展用户的视野，帮助其发现潜在的新东西</li>\n</ul>\n<p>注意， 准确性并不能完全决定推荐算法的好坏。 比如预测太阳从东方升起，这是100%准确的预测， 但是也是一个毫无意义的预测。</p>\n<h1 id=\"如何测试推荐系统\"><a href=\"#如何测试推荐系统\" class=\"headerlink\" title=\"如何测试推荐系统\"></a>如何测试推荐系统</h1><ul>\n<li>离线测试：即使用现有的数据集对系统进行测试</li>\n<li>用户调查：直接上线前的测试，先做用户调查，让用户为推荐系统进行评价</li>\n<li>在线实验：用户调查完成后上线。评价的标准是做AB test，即和原有的算法进行比较。</li>\n</ul>\n<p>上面三个处于推荐系统的不同开发阶段。先离线测试，OK后做用户调查，OK后上线实验</p>\n<h2 id=\"测试标准\"><a href=\"#测试标准\" class=\"headerlink\" title=\"测试标准\"></a>测试标准</h2><ul>\n<li><p>用户满意度</p>\n</li>\n<li><p>预测准确度</p>\n</li>\n<li><p>覆盖率：即对长尾物品的发掘能力。如果所有物品都出现在推荐列表中， 并且出现次数差不多， 则长尾发掘能力就好很多</p>\n<p>两个指标定义覆盖率</p>\n<ul>\n<li><p>信息熵：<a href=\"https://www.cnblogs.com/IamJiangXiaoKun/p/9455689.html。简单说，信息熵就是对一个不确定事件发生所可能产生的信息量的期望。而信息量和该时间发生概率的对数的倒数有关。即一个事件发生概率越高，则产生的信息量越小；概率越低，产生的信息量越大。\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/IamJiangXiaoKun/p/9455689.html。简单说，信息熵就是对一个不确定事件发生所可能产生的信息量的期望。而信息量和该时间发生概率的对数的倒数有关。即一个事件发生概率越高，则产生的信息量越小；概率越低，产生的信息量越大。</a></p>\n</li>\n<li><p>基尼系数：用于衡量收入分配是否均匀之类的问题。计算方法是A/B。当A为0时，基尼系数为0.说明绝对平等了。当A很大时，说明非常不平衡。</p>\n<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2c95402b392ac65c73086e219a9bd974/b812c8fcc3cec3fdea113b3eda88d43f87942749.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>多样性：推荐多种多样的商品</p>\n</li>\n<li><p>新颖性：推荐用户没听说过的商品</p>\n</li>\n<li><p>惊喜度：相比新颖性，还能让用户感觉使用之后很惊喜</p>\n</li>\n<li><p>信任度：涉及推荐的方式，要让用户新人所推荐的内容，愿意购买商品</p>\n</li>\n<li><p>实时性：比如用户新买了一个iphone，及时给他推荐手机壳之类的</p>\n</li>\n<li><p>健壮性：抗击作弊</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是推荐系统\"><a href=\"#什么是推荐系统\" class=\"headerlink\" title=\"什么是推荐系统\"></a>什么是推荐系统</h1><p>推荐系统让用户能够发现对自己有价值的信息，另一方面，能够让信息展现在对它感兴趣的用户面前。实现消费者和生产者的双赢。</p>","more":"<h1 id=\"几个理论\"><a href=\"#几个理论\" class=\"headerlink\" title=\"几个理论\"></a>几个理论</h1><h2 id=\"长尾理论\"><a href=\"#长尾理论\" class=\"headerlink\" title=\"长尾理论\"></a>长尾理论</h2><p>来自市场营销上的说法。即传统认为，厂商80%的收入很可能来自20%热门商品。但在互联网条件下，由于铺货成本极其低廉，那些不热门的商品销售数量可能极其庞大，使得其销售收入与热门商品相当甚至更多。推荐系统就是基于长尾理论, 将长尾商品推荐给用户, 实现收益增加</p>\n<h2 id=\"幂律分布\"><a href=\"#幂律分布\" class=\"headerlink\" title=\"幂律分布\"></a>幂律分布</h2><p>一种分布， 曲线如下。长尾理论就是幂律分布的通俗体现。常见幂律分布：英文单词、个人收入等</p>\n<p><img src=\"https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=8ab03b31e2fe9925cf0c6e5204a95ee4/cc11728b4710b9127865d50ac1fdfc0393452299.jpg\" alt=\"img\"></p>\n<h2 id=\"马太效应\"><a href=\"#马太效应\" class=\"headerlink\" title=\"马太效应\"></a>马太效应</h2><p>即两极分化效应，强者越强， 弱者越弱</p>\n<p>出自《新约·马太福音》： “凡有的，还要加倍给他叫他多余；没有的，连他所有的也要夺过来”</p>\n<h1 id=\"推荐系统原理\"><a href=\"#推荐系统原理\" class=\"headerlink\" title=\"推荐系统原理\"></a>推荐系统原理</h1><p>推荐系统并没有特别高深的理论，它只不过将我们平常的检索进行了自动化</p>\n<ul>\n<li>社会化推荐：对应于向好友咨询</li>\n<li>基于内容的推荐：对应于我们手动搜索电影片名或演员名</li>\n<li>基于协同过滤的推荐：对应于查看排行榜，找到广受好评的电影</li>\n</ul>\n<p>推荐的本质是将用户和物品联系起来。而不同的推荐系统只是利用了不同的联系方式</p>\n<h1 id=\"推荐做得好的应用\"><a href=\"#推荐做得好的应用\" class=\"headerlink\" title=\"推荐做得好的应用\"></a>推荐做得好的应用</h1><ul>\n<li>亚马逊<ul>\n<li>让每个用户像是拥有自己的专属商店一样</li>\n<li>20-30%收入来自推荐系统</li>\n</ul>\n</li>\n<li>Netflix<ul>\n<li>举办了推荐系统比赛</li>\n<li>自己宣称有60%的用户是通过推荐系统找到自己喜欢的影片的</li>\n</ul>\n</li>\n<li>Youtube<ul>\n<li>其实验表明。个性化推荐的视频点击率是热门视频点击率的两倍</li>\n</ul>\n</li>\n<li>音乐电台<ul>\n<li>豆瓣电台：用户无法自己选取歌曲。只能标记喜欢或不喜欢，模型建立完成后就能够推荐用户感兴趣的歌曲。</li>\n</ul>\n</li>\n<li>facebook<ul>\n<li>利用推荐系统推荐广告、推荐信息流、推荐好友</li>\n<li>退出了API，称为Instant Personalization，能够推荐用户的好友喜欢的物品。</li>\n</ul>\n</li>\n<li>阅读推荐<ul>\n<li>今日头条等</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"什么是好的推荐系统\"><a href=\"#什么是好的推荐系统\" class=\"headerlink\" title=\"什么是好的推荐系统\"></a>什么是好的推荐系统</h1><p>合格的满足如下三点</p>\n<ul>\n<li>用户能够得到自己的感兴趣的推荐内容</li>\n<li>商品提供方的物品要能够被推荐到合适的用户手中</li>\n<li>能够收集到高质量的用户反馈， 从而不断完善推荐系统， 提高推荐准确性。</li>\n</ul>\n<p>好的推荐系统还满足一点</p>\n<ul>\n<li>不仅能够预测用户的行为， 还能扩展用户的视野，帮助其发现潜在的新东西</li>\n</ul>\n<p>注意， 准确性并不能完全决定推荐算法的好坏。 比如预测太阳从东方升起，这是100%准确的预测， 但是也是一个毫无意义的预测。</p>\n<h1 id=\"如何测试推荐系统\"><a href=\"#如何测试推荐系统\" class=\"headerlink\" title=\"如何测试推荐系统\"></a>如何测试推荐系统</h1><ul>\n<li>离线测试：即使用现有的数据集对系统进行测试</li>\n<li>用户调查：直接上线前的测试，先做用户调查，让用户为推荐系统进行评价</li>\n<li>在线实验：用户调查完成后上线。评价的标准是做AB test，即和原有的算法进行比较。</li>\n</ul>\n<p>上面三个处于推荐系统的不同开发阶段。先离线测试，OK后做用户调查，OK后上线实验</p>\n<h2 id=\"测试标准\"><a href=\"#测试标准\" class=\"headerlink\" title=\"测试标准\"></a>测试标准</h2><ul>\n<li><p>用户满意度</p>\n</li>\n<li><p>预测准确度</p>\n</li>\n<li><p>覆盖率：即对长尾物品的发掘能力。如果所有物品都出现在推荐列表中， 并且出现次数差不多， 则长尾发掘能力就好很多</p>\n<p>两个指标定义覆盖率</p>\n<ul>\n<li><p>信息熵：<a href=\"https://www.cnblogs.com/IamJiangXiaoKun/p/9455689.html。简单说，信息熵就是对一个不确定事件发生所可能产生的信息量的期望。而信息量和该时间发生概率的对数的倒数有关。即一个事件发生概率越高，则产生的信息量越小；概率越低，产生的信息量越大。\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/IamJiangXiaoKun/p/9455689.html。简单说，信息熵就是对一个不确定事件发生所可能产生的信息量的期望。而信息量和该时间发生概率的对数的倒数有关。即一个事件发生概率越高，则产生的信息量越小；概率越低，产生的信息量越大。</a></p>\n</li>\n<li><p>基尼系数：用于衡量收入分配是否均匀之类的问题。计算方法是A/B。当A为0时，基尼系数为0.说明绝对平等了。当A很大时，说明非常不平衡。</p>\n<p><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2c95402b392ac65c73086e219a9bd974/b812c8fcc3cec3fdea113b3eda88d43f87942749.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>多样性：推荐多种多样的商品</p>\n</li>\n<li><p>新颖性：推荐用户没听说过的商品</p>\n</li>\n<li><p>惊喜度：相比新颖性，还能让用户感觉使用之后很惊喜</p>\n</li>\n<li><p>信任度：涉及推荐的方式，要让用户新人所推荐的内容，愿意购买商品</p>\n</li>\n<li><p>实时性：比如用户新买了一个iphone，及时给他推荐手机壳之类的</p>\n</li>\n<li><p>健壮性：抗击作弊</p>\n</li>\n</ul>"},{"title":"RxJava - 读书笔记","date":"2019-09-08T03:00:21.000Z","_content":"\n## Observable\n\n ReactiveX中, 应用的是观察者模式, 一个观察者订阅一个被观察者. 然后该观察者根据被观察者释放的任何信息进行反应. 这样能够使得并发称为可能, 观察者不必阻塞等待被观察者的响应内容, 而是创建一个哨兵, 并随时准备在未来的任何时候响应被观察者释放出的内容\n <!-- more -->\nObservable通过调用Observer的方法向其发送通知\n如下图片能够展示一个被观察者释放的一系列数据, 以及对这些数据进行转换的操作\n\n![1564802038820](1564802038820.png)\n\n本文中称的观察者, 在别的文档中有时也被称为订阅者, 也叫作反应器. 该模型对应于 反应式模型\n\n### 建立一个Observable\n\n- 定义一个结果处理的方法, 该方法是观察者的一部分\n- 将异步调用本身定义为被观察者\n- 通过订阅的方式, 将观察者附加到被观察者身上. \n\n### OnNext, OnCompleted, OnError\n\n这些是观察者的一部分. 三个方法被调用的时机不同\n\n- OnNext\n  被观察者每次释放一个数据都会调用它\n\n- OnError\n  当被观察者发生错误时会调用, 调用该方法后, OnNext和OnCompleted方法都不会再被调用\n\n- OnCompleted\n  在调用最后一次OnNext时会调用OnCompleted\n\n我们管OnNext叫做释放数据, 管OnError和OnCompleted叫通知.\n\n### 观察者约定(The Observable Contract)\n\n该约定尝试对被观察者做一个正式的定义, 他会出现在Rx文档的很多地方\n\n#### 通知\n\n一个被观察者通过如下方式和它的观察者们交流\n\n- OnNext: 从被观察者向观察者传送一个item\n- OnCompleted: 表明被观察者已经成功地完成, 并且不会再释放数据\n- OnError: 表明被观察者已经被某个原因中止, 并且不会再释放数据\n- OnSubscribe(背压): 表明被观察者已经准备好接收来自观察者的请求通知\n\n一个观察者通过如下方式和它的被观察者交流\n\n- Subscribe: 表明观察者已经准备好接收来自被观察者的通知\n- UnSubscribe: 表明观察者已经不想要再接收到被观察者的通知了\n- Request(背压): 表明观察者只希望接收到不超过特定数量的来自被观察者的通知(通过OnNext发送过来的)\n\n#### 约定\n\n一个被观察者可能调用0次或多次OnNext, OnCompleted和OnError只会且一定会调用其一, 且其后不得再发送任何通知\n\n一个被观察者可能根本不会释放任何数据, 也可能因为永远不停止而不会发出OnCompleted和OnError. 即: 观察者可能不发出任何通知, 可能发出OnCompleted和OnError通知, 也可能仅发出OnNext通知\n\n一个被观察者发送给观察者的通知必须是串行的, 他们可以在不同的线程发出, 但必须有一个先行发生原则确保其顺序\n\n#### 被观察者的中止\n\n如果被观察者没有发出完成或错误通知, 观察者会认为它仍然是活动的, 并且可能会给他发送通知(如unsubscribe和request通知等).\n如果被观察者发出了完成或错误通知, 该被观察者会释放其资源, 其观察者不应试图与其有进一步的沟通\n一个OnError通知必须包含错误原因, 就是说传入一个null的OnError是无效的\n被观察者停止自己之前, 必须先向它的所有订阅者发出OnCompleted或OnError消息\n\n#### 订阅和取消订阅\n\n被观察者可以在收到观察者发出的Subscribe通知后马上开始向其发送通知\n当观察者发送UnSubscribe通知给被观察者时, 被观察者会试图停止向其发送通知, 但这是不被保证的, \n被观察者发送OnCompleted或OnError通知给观察者时, 它们的订阅关系将会自动结束. 不需要再由观察者发送UnSubscribe消息给被观察者\n\n#### 多个订阅者\n\n如果第二个观察者订阅了一个已经向第一个观察者释放了一些数据的被观察者, 那么第二个观察者收到的消息可能如下\n\n- 从订阅开始, 所有订阅者将收到一样的消息,(即新的订阅者会收不到已经释放原来订阅者的消息)\n- 重新向新的订阅者发送完全相同的数据\n- 新的订阅者将会收到顺序完全不同的数据\n\n上面这些都是可能的, 具体哪一种取决于被观察者的实现. \n\n没有一个通用的约定说两个多个观察者能够得到一样顺序的消息\n\n#### 背压\n\n背压是可选的, 并非所有ReactiveX实现都包括背压.而且在哪些包括了背压的实现中, 也并非所有被观察者都支持背压.\n如果一个被观察者实现了背压，并且它的观察者使用了背压，那么该被观察者不会在订阅后立即向观察者发出项目。相反，它将向观察者发出一个onsubscribe通知。\n观察者收到onsubscribe消息后, 会发送一个请求通知给被观察者, 指定需要数据的数量, 被观察者就会释放不多于该数量的数据. 当然, 被观察者也可以主动发出OnCompleted和OnError通知, 甚至在观察者发送请求通知前发出以结束订阅.\n\n对于没有实现背压的被观察者, 当它收到来自观察者的请求通知时, 应该回敬一个OnError通知, 说明自己并不支持背压\n\n请求是累积的: 如果一个观察者发出了三个请求通知, 分别请求3,5,10条数据, 则被观察者将会至多发送18条数据, 不会因为说刚发了两条时马上来了一个5条的请求就把原本剩下的那一条忽略掉.\n如果被观察者产生了多余请求数量的数据, 多出来的数据的处理方式完全看被观察者自己.\n\n### 热 , 冷 的被观察者\n\n- 热: 指的是被观察者从一开始就释放数据, 这样观察者从订阅开始就只能从中途获取数据\n- 冷: 指的是被观察者在被定于后才开始释放数据, 这样就能保证获取完整的数据\n- connectable: 这是在部分ReactiveX实现中的被观察者, 只有当connect方法被调用时才会释放数据, 而不管有没有观察者订阅他\n\n### 被观察者操作符的组合\n\n被观察者和观察者仅仅是ReactiveX的开始, 他们本身只是标准的观察者模式的轻量级扩展, 更适合处理一连串事件, 而不是单个回调\n其真正厉害的地方在于通过操作符转换, 组合, 运算由被观察者释放出来的一系列数据\n\n## Operators\n\n### 操作分类\n\n#### 创建被观察者\n\n- create: 通知显式调用订阅者方法来创建Observable\n- defer: 观察者订阅时才创建, 不订阅就不创建, 且为每个新的观察者创建一个新的被观察者\n- interval: 创建一个每隔一段时间释放一个数据的被观察者\n\n#### 处理操作\n\n- buffer: 被观察者一个一个地发送数据, 该操作设定缓存个数, 缓存满了之后将整个缓存一起释放\n- flatMap: 将多个被观察者释放的数据合并到一个被观察者中\n- groupBy: 将单个被观察者切分成多个被观察者, 每次只从原被观察者处释放一组\n- scan: 对每个释放的数据应用一个函数, 将结果释放出去, 一次运算释放的值会作为下一次运算的输入\n\n#### 过滤操作\n\n- debounce: 只释放这样的数据, 该数据被释放之后, 指定的一段时间内没有新数据的出现, 则释放该数据.否则对新释放的数据继续做此判断\n- elementAt: 只获取释放的第n个元素\n- first: 只释放第一个数据, 或满足条件的数据\n- last: 只释放最后一个数据\n- sample: 获取一段时间内被观察者释放的最后一个数据\n- take: 只获取头几个释放的数据\n- takeLast: 只获取最后几个释放的数据\n\n#### 组合操作\n\n将多个被观察者合并为一个被观察者\n\n- combineLatest: 将一个被观察者释放的数据和另一个被观察者释放的最近的一个数据组合起来\n\n![1564822583394](1564822583394.png)\n\n- join: 将两个被观察者释放的在一个时间窗中的数据进行合并\n\n![1564823248295](1564823248295.png)\n\n- merge: 直接将两个释放合并\n\n![1564823342178](1564823342178.png)\n\n- startWith: 在释放常规数据前, 先释放指定的数据\n\n![1564823975876](1564823975876.png)\n\n- switch: 将释放数据为Observable的几个被观察者转换成一个释放所有这些数据的被观察者\n\n![Switch](switch.c.png)\n\n- zip: 将多个被观察者释放的数据以一定的方法合并到一个被观察者上\n\n![1564824218864](1564824218864.png)\n\n#### 错误处理操作\n\n- catch: 从错误中恢复出来, 使原被观察者继续执行\n- retry: 被观察者抛出错误时, 重新订阅它\n\n#### 被观察者的工具操作\n\n- delay: 每个元素都延迟释放\n- doOnEach: 为每个元素执行一个操作\n- materialize: 将释放的消息和发送的通知都当做释放的消息\n- observeOn: 指定观察者将会在哪个schedudler上对被观察者进行观察\n- subscribe: 将被观察者绑定到观察者\n- timeInterval: 将一个释放普通元素的被观察者转换为释放元素之间的时间间隔的被观察者\n- timeout: 一个元素释放后的指定时间内不再释放新的元素时, 停止该被观察者\n- timestamp: 为每一个释放的元素绑定一个时间戳\n\n#### 条件和布尔操作\n\n- all: 判断是否释放的所有元素都满足给定条件\n- amb: 给定多个被观察者, 只获取最先释放数据的被观察者的所有数据\n- contains: 判断释放的元素是否包含指定元素\n- sequenceEqual: 判断两个被观察者是否释放了一样的数据流\n\n#### 数学和聚集操作\n\n- concat:  将两个被观察者连接起来, 一个被观察者释放完所有数据后, 另一个被观察者才继续释放它的所有数据\n- reduce: 对每个释放的数据应用某个函数, 并输出最终结果\n\n![1564825542157](1564825542157.png)\n\n#### 背压操作\n\n这是用来应对生产数据快过消费数据的情况\n\n#### Connectable Observable的操作\n\n- connect: 开始释放数据\n- publish: 将原本的observable转换成一个Connectable Observable\n- refcount: 使Connectable Observable向一个原始Observable一样工作\n- replay: 确保所有观察者都能够看到相同顺序的数据, 即使他们在不同时刻订阅\n\n#### Observable转换操作\n\n- to:  将一个Observable转换成其它对象或数据结构\n\n## Single\n\nSingle是Observable的一个变体, 不同于Observable是释放一系列数据, Single仅释放一个数据, 或触发一次错误.因此, Single中, 仅能使用OnSuccess与OnError同观察者交流. 当上述两个方法中任意一个被调用了, 另一个都不会再被调用, Single也停止了, 订阅关系也自动解除了.\n也就是说, Single没有结束一说, 只有成功和错误两个时机, 因此调用doOnCompleted是不会被触发的\n\n### Single中值得记住的方法\n\n- doOnSuccess/doOnError: 在调用OnSuccess和OnError方法时, 会同时触发该方法\n\n## Subject\n\nSubject在某些实现中有做, 它可以看做是一个桥梁或是一个代理, 能够同时充当订阅者, 获取其它被观察者的消息, 也能够充当被观察者, 向其它观察者发送消息.\n\nSubject有四种变形, 分别用在不同的场景下\n\n### AsyncSubject\n\nAsyncSubject在源Observable结束时, 释放源Observable的最后一个元素, 如果源Observable一个元素都没有释放, 则AsyncSubject也会什么都不释放, 然后结束. 如果源Observable发生错误, 则AsyncSubject会直接将该错误释放, 不会释放其它数据\n\n### BehaviorSubject\n\nBehaviorSubject会释放源Observable最近释放过的数据, 如果没有最近释放过的数据, 则返回指定的默认值.\n\n当源Observable发生错误时, BehaviorSubject不会释放任何数据. 而是直接释放该数据\n\n### PublishSubject\n\nPublishSubject直接将源Observable的数据进行原样释放, 源Observable来一个它就释放一个, 这意味着较晚订阅它的订阅者会丢失订阅之前的消息\n\n### ReplaySubject\n\nReplaySubject会将源Observable所释放的数据全部再次释放一遍.\n\n## Scheduler\n\nScheduler用于做线程调度.\n\n默认情况下, Observable及其操作链将会工作在subscribe调用时的线程上. 可以通过ObserveOn操作符改变该行为. 该方法指定一个线程调度器, Observable会在其上运行.\n\nSubscribeOn指定了Observable将会在哪个调度器上进行操作, 即观察者所在的线程.","source":"_posts/读书笔记-RxJava.md","raw":"---\ntitle: RxJava - 读书笔记\ndate: 2019-09-08 11:00:21\ntags: \n    - RxJava\ncategories: \n    - RxJava\n---\n\n## Observable\n\n ReactiveX中, 应用的是观察者模式, 一个观察者订阅一个被观察者. 然后该观察者根据被观察者释放的任何信息进行反应. 这样能够使得并发称为可能, 观察者不必阻塞等待被观察者的响应内容, 而是创建一个哨兵, 并随时准备在未来的任何时候响应被观察者释放出的内容\n <!-- more -->\nObservable通过调用Observer的方法向其发送通知\n如下图片能够展示一个被观察者释放的一系列数据, 以及对这些数据进行转换的操作\n\n![1564802038820](1564802038820.png)\n\n本文中称的观察者, 在别的文档中有时也被称为订阅者, 也叫作反应器. 该模型对应于 反应式模型\n\n### 建立一个Observable\n\n- 定义一个结果处理的方法, 该方法是观察者的一部分\n- 将异步调用本身定义为被观察者\n- 通过订阅的方式, 将观察者附加到被观察者身上. \n\n### OnNext, OnCompleted, OnError\n\n这些是观察者的一部分. 三个方法被调用的时机不同\n\n- OnNext\n  被观察者每次释放一个数据都会调用它\n\n- OnError\n  当被观察者发生错误时会调用, 调用该方法后, OnNext和OnCompleted方法都不会再被调用\n\n- OnCompleted\n  在调用最后一次OnNext时会调用OnCompleted\n\n我们管OnNext叫做释放数据, 管OnError和OnCompleted叫通知.\n\n### 观察者约定(The Observable Contract)\n\n该约定尝试对被观察者做一个正式的定义, 他会出现在Rx文档的很多地方\n\n#### 通知\n\n一个被观察者通过如下方式和它的观察者们交流\n\n- OnNext: 从被观察者向观察者传送一个item\n- OnCompleted: 表明被观察者已经成功地完成, 并且不会再释放数据\n- OnError: 表明被观察者已经被某个原因中止, 并且不会再释放数据\n- OnSubscribe(背压): 表明被观察者已经准备好接收来自观察者的请求通知\n\n一个观察者通过如下方式和它的被观察者交流\n\n- Subscribe: 表明观察者已经准备好接收来自被观察者的通知\n- UnSubscribe: 表明观察者已经不想要再接收到被观察者的通知了\n- Request(背压): 表明观察者只希望接收到不超过特定数量的来自被观察者的通知(通过OnNext发送过来的)\n\n#### 约定\n\n一个被观察者可能调用0次或多次OnNext, OnCompleted和OnError只会且一定会调用其一, 且其后不得再发送任何通知\n\n一个被观察者可能根本不会释放任何数据, 也可能因为永远不停止而不会发出OnCompleted和OnError. 即: 观察者可能不发出任何通知, 可能发出OnCompleted和OnError通知, 也可能仅发出OnNext通知\n\n一个被观察者发送给观察者的通知必须是串行的, 他们可以在不同的线程发出, 但必须有一个先行发生原则确保其顺序\n\n#### 被观察者的中止\n\n如果被观察者没有发出完成或错误通知, 观察者会认为它仍然是活动的, 并且可能会给他发送通知(如unsubscribe和request通知等).\n如果被观察者发出了完成或错误通知, 该被观察者会释放其资源, 其观察者不应试图与其有进一步的沟通\n一个OnError通知必须包含错误原因, 就是说传入一个null的OnError是无效的\n被观察者停止自己之前, 必须先向它的所有订阅者发出OnCompleted或OnError消息\n\n#### 订阅和取消订阅\n\n被观察者可以在收到观察者发出的Subscribe通知后马上开始向其发送通知\n当观察者发送UnSubscribe通知给被观察者时, 被观察者会试图停止向其发送通知, 但这是不被保证的, \n被观察者发送OnCompleted或OnError通知给观察者时, 它们的订阅关系将会自动结束. 不需要再由观察者发送UnSubscribe消息给被观察者\n\n#### 多个订阅者\n\n如果第二个观察者订阅了一个已经向第一个观察者释放了一些数据的被观察者, 那么第二个观察者收到的消息可能如下\n\n- 从订阅开始, 所有订阅者将收到一样的消息,(即新的订阅者会收不到已经释放原来订阅者的消息)\n- 重新向新的订阅者发送完全相同的数据\n- 新的订阅者将会收到顺序完全不同的数据\n\n上面这些都是可能的, 具体哪一种取决于被观察者的实现. \n\n没有一个通用的约定说两个多个观察者能够得到一样顺序的消息\n\n#### 背压\n\n背压是可选的, 并非所有ReactiveX实现都包括背压.而且在哪些包括了背压的实现中, 也并非所有被观察者都支持背压.\n如果一个被观察者实现了背压，并且它的观察者使用了背压，那么该被观察者不会在订阅后立即向观察者发出项目。相反，它将向观察者发出一个onsubscribe通知。\n观察者收到onsubscribe消息后, 会发送一个请求通知给被观察者, 指定需要数据的数量, 被观察者就会释放不多于该数量的数据. 当然, 被观察者也可以主动发出OnCompleted和OnError通知, 甚至在观察者发送请求通知前发出以结束订阅.\n\n对于没有实现背压的被观察者, 当它收到来自观察者的请求通知时, 应该回敬一个OnError通知, 说明自己并不支持背压\n\n请求是累积的: 如果一个观察者发出了三个请求通知, 分别请求3,5,10条数据, 则被观察者将会至多发送18条数据, 不会因为说刚发了两条时马上来了一个5条的请求就把原本剩下的那一条忽略掉.\n如果被观察者产生了多余请求数量的数据, 多出来的数据的处理方式完全看被观察者自己.\n\n### 热 , 冷 的被观察者\n\n- 热: 指的是被观察者从一开始就释放数据, 这样观察者从订阅开始就只能从中途获取数据\n- 冷: 指的是被观察者在被定于后才开始释放数据, 这样就能保证获取完整的数据\n- connectable: 这是在部分ReactiveX实现中的被观察者, 只有当connect方法被调用时才会释放数据, 而不管有没有观察者订阅他\n\n### 被观察者操作符的组合\n\n被观察者和观察者仅仅是ReactiveX的开始, 他们本身只是标准的观察者模式的轻量级扩展, 更适合处理一连串事件, 而不是单个回调\n其真正厉害的地方在于通过操作符转换, 组合, 运算由被观察者释放出来的一系列数据\n\n## Operators\n\n### 操作分类\n\n#### 创建被观察者\n\n- create: 通知显式调用订阅者方法来创建Observable\n- defer: 观察者订阅时才创建, 不订阅就不创建, 且为每个新的观察者创建一个新的被观察者\n- interval: 创建一个每隔一段时间释放一个数据的被观察者\n\n#### 处理操作\n\n- buffer: 被观察者一个一个地发送数据, 该操作设定缓存个数, 缓存满了之后将整个缓存一起释放\n- flatMap: 将多个被观察者释放的数据合并到一个被观察者中\n- groupBy: 将单个被观察者切分成多个被观察者, 每次只从原被观察者处释放一组\n- scan: 对每个释放的数据应用一个函数, 将结果释放出去, 一次运算释放的值会作为下一次运算的输入\n\n#### 过滤操作\n\n- debounce: 只释放这样的数据, 该数据被释放之后, 指定的一段时间内没有新数据的出现, 则释放该数据.否则对新释放的数据继续做此判断\n- elementAt: 只获取释放的第n个元素\n- first: 只释放第一个数据, 或满足条件的数据\n- last: 只释放最后一个数据\n- sample: 获取一段时间内被观察者释放的最后一个数据\n- take: 只获取头几个释放的数据\n- takeLast: 只获取最后几个释放的数据\n\n#### 组合操作\n\n将多个被观察者合并为一个被观察者\n\n- combineLatest: 将一个被观察者释放的数据和另一个被观察者释放的最近的一个数据组合起来\n\n![1564822583394](1564822583394.png)\n\n- join: 将两个被观察者释放的在一个时间窗中的数据进行合并\n\n![1564823248295](1564823248295.png)\n\n- merge: 直接将两个释放合并\n\n![1564823342178](1564823342178.png)\n\n- startWith: 在释放常规数据前, 先释放指定的数据\n\n![1564823975876](1564823975876.png)\n\n- switch: 将释放数据为Observable的几个被观察者转换成一个释放所有这些数据的被观察者\n\n![Switch](switch.c.png)\n\n- zip: 将多个被观察者释放的数据以一定的方法合并到一个被观察者上\n\n![1564824218864](1564824218864.png)\n\n#### 错误处理操作\n\n- catch: 从错误中恢复出来, 使原被观察者继续执行\n- retry: 被观察者抛出错误时, 重新订阅它\n\n#### 被观察者的工具操作\n\n- delay: 每个元素都延迟释放\n- doOnEach: 为每个元素执行一个操作\n- materialize: 将释放的消息和发送的通知都当做释放的消息\n- observeOn: 指定观察者将会在哪个schedudler上对被观察者进行观察\n- subscribe: 将被观察者绑定到观察者\n- timeInterval: 将一个释放普通元素的被观察者转换为释放元素之间的时间间隔的被观察者\n- timeout: 一个元素释放后的指定时间内不再释放新的元素时, 停止该被观察者\n- timestamp: 为每一个释放的元素绑定一个时间戳\n\n#### 条件和布尔操作\n\n- all: 判断是否释放的所有元素都满足给定条件\n- amb: 给定多个被观察者, 只获取最先释放数据的被观察者的所有数据\n- contains: 判断释放的元素是否包含指定元素\n- sequenceEqual: 判断两个被观察者是否释放了一样的数据流\n\n#### 数学和聚集操作\n\n- concat:  将两个被观察者连接起来, 一个被观察者释放完所有数据后, 另一个被观察者才继续释放它的所有数据\n- reduce: 对每个释放的数据应用某个函数, 并输出最终结果\n\n![1564825542157](1564825542157.png)\n\n#### 背压操作\n\n这是用来应对生产数据快过消费数据的情况\n\n#### Connectable Observable的操作\n\n- connect: 开始释放数据\n- publish: 将原本的observable转换成一个Connectable Observable\n- refcount: 使Connectable Observable向一个原始Observable一样工作\n- replay: 确保所有观察者都能够看到相同顺序的数据, 即使他们在不同时刻订阅\n\n#### Observable转换操作\n\n- to:  将一个Observable转换成其它对象或数据结构\n\n## Single\n\nSingle是Observable的一个变体, 不同于Observable是释放一系列数据, Single仅释放一个数据, 或触发一次错误.因此, Single中, 仅能使用OnSuccess与OnError同观察者交流. 当上述两个方法中任意一个被调用了, 另一个都不会再被调用, Single也停止了, 订阅关系也自动解除了.\n也就是说, Single没有结束一说, 只有成功和错误两个时机, 因此调用doOnCompleted是不会被触发的\n\n### Single中值得记住的方法\n\n- doOnSuccess/doOnError: 在调用OnSuccess和OnError方法时, 会同时触发该方法\n\n## Subject\n\nSubject在某些实现中有做, 它可以看做是一个桥梁或是一个代理, 能够同时充当订阅者, 获取其它被观察者的消息, 也能够充当被观察者, 向其它观察者发送消息.\n\nSubject有四种变形, 分别用在不同的场景下\n\n### AsyncSubject\n\nAsyncSubject在源Observable结束时, 释放源Observable的最后一个元素, 如果源Observable一个元素都没有释放, 则AsyncSubject也会什么都不释放, 然后结束. 如果源Observable发生错误, 则AsyncSubject会直接将该错误释放, 不会释放其它数据\n\n### BehaviorSubject\n\nBehaviorSubject会释放源Observable最近释放过的数据, 如果没有最近释放过的数据, 则返回指定的默认值.\n\n当源Observable发生错误时, BehaviorSubject不会释放任何数据. 而是直接释放该数据\n\n### PublishSubject\n\nPublishSubject直接将源Observable的数据进行原样释放, 源Observable来一个它就释放一个, 这意味着较晚订阅它的订阅者会丢失订阅之前的消息\n\n### ReplaySubject\n\nReplaySubject会将源Observable所释放的数据全部再次释放一遍.\n\n## Scheduler\n\nScheduler用于做线程调度.\n\n默认情况下, Observable及其操作链将会工作在subscribe调用时的线程上. 可以通过ObserveOn操作符改变该行为. 该方法指定一个线程调度器, Observable会在其上运行.\n\nSubscribeOn指定了Observable将会在哪个调度器上进行操作, 即观察者所在的线程.","slug":"读书笔记-RxJava","published":1,"updated":"2019-09-08T10:18:19.861Z","_id":"ck0atmo9h000z00bnhbbn61q5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h2><p> ReactiveX中, 应用的是观察者模式, 一个观察者订阅一个被观察者. 然后该观察者根据被观察者释放的任何信息进行反应. 这样能够使得并发称为可能, 观察者不必阻塞等待被观察者的响应内容, 而是创建一个哨兵, 并随时准备在未来的任何时候响应被观察者释放出的内容<br> <a id=\"more\"></a><br>Observable通过调用Observer的方法向其发送通知<br>如下图片能够展示一个被观察者释放的一系列数据, 以及对这些数据进行转换的操作</p>\n<p><img src=\"1564802038820.png\" alt=\"1564802038820\"></p>\n<p>本文中称的观察者, 在别的文档中有时也被称为订阅者, 也叫作反应器. 该模型对应于 反应式模型</p>\n<h3 id=\"建立一个Observable\"><a href=\"#建立一个Observable\" class=\"headerlink\" title=\"建立一个Observable\"></a>建立一个Observable</h3><ul>\n<li>定义一个结果处理的方法, 该方法是观察者的一部分</li>\n<li>将异步调用本身定义为被观察者</li>\n<li>通过订阅的方式, 将观察者附加到被观察者身上. </li>\n</ul>\n<h3 id=\"OnNext-OnCompleted-OnError\"><a href=\"#OnNext-OnCompleted-OnError\" class=\"headerlink\" title=\"OnNext, OnCompleted, OnError\"></a>OnNext, OnCompleted, OnError</h3><p>这些是观察者的一部分. 三个方法被调用的时机不同</p>\n<ul>\n<li><p>OnNext<br>被观察者每次释放一个数据都会调用它</p>\n</li>\n<li><p>OnError<br>当被观察者发生错误时会调用, 调用该方法后, OnNext和OnCompleted方法都不会再被调用</p>\n</li>\n<li><p>OnCompleted<br>在调用最后一次OnNext时会调用OnCompleted</p>\n</li>\n</ul>\n<p>我们管OnNext叫做释放数据, 管OnError和OnCompleted叫通知.</p>\n<h3 id=\"观察者约定-The-Observable-Contract\"><a href=\"#观察者约定-The-Observable-Contract\" class=\"headerlink\" title=\"观察者约定(The Observable Contract)\"></a>观察者约定(The Observable Contract)</h3><p>该约定尝试对被观察者做一个正式的定义, 他会出现在Rx文档的很多地方</p>\n<h4 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h4><p>一个被观察者通过如下方式和它的观察者们交流</p>\n<ul>\n<li>OnNext: 从被观察者向观察者传送一个item</li>\n<li>OnCompleted: 表明被观察者已经成功地完成, 并且不会再释放数据</li>\n<li>OnError: 表明被观察者已经被某个原因中止, 并且不会再释放数据</li>\n<li>OnSubscribe(背压): 表明被观察者已经准备好接收来自观察者的请求通知</li>\n</ul>\n<p>一个观察者通过如下方式和它的被观察者交流</p>\n<ul>\n<li>Subscribe: 表明观察者已经准备好接收来自被观察者的通知</li>\n<li>UnSubscribe: 表明观察者已经不想要再接收到被观察者的通知了</li>\n<li>Request(背压): 表明观察者只希望接收到不超过特定数量的来自被观察者的通知(通过OnNext发送过来的)</li>\n</ul>\n<h4 id=\"约定\"><a href=\"#约定\" class=\"headerlink\" title=\"约定\"></a>约定</h4><p>一个被观察者可能调用0次或多次OnNext, OnCompleted和OnError只会且一定会调用其一, 且其后不得再发送任何通知</p>\n<p>一个被观察者可能根本不会释放任何数据, 也可能因为永远不停止而不会发出OnCompleted和OnError. 即: 观察者可能不发出任何通知, 可能发出OnCompleted和OnError通知, 也可能仅发出OnNext通知</p>\n<p>一个被观察者发送给观察者的通知必须是串行的, 他们可以在不同的线程发出, 但必须有一个先行发生原则确保其顺序</p>\n<h4 id=\"被观察者的中止\"><a href=\"#被观察者的中止\" class=\"headerlink\" title=\"被观察者的中止\"></a>被观察者的中止</h4><p>如果被观察者没有发出完成或错误通知, 观察者会认为它仍然是活动的, 并且可能会给他发送通知(如unsubscribe和request通知等).<br>如果被观察者发出了完成或错误通知, 该被观察者会释放其资源, 其观察者不应试图与其有进一步的沟通<br>一个OnError通知必须包含错误原因, 就是说传入一个null的OnError是无效的<br>被观察者停止自己之前, 必须先向它的所有订阅者发出OnCompleted或OnError消息</p>\n<h4 id=\"订阅和取消订阅\"><a href=\"#订阅和取消订阅\" class=\"headerlink\" title=\"订阅和取消订阅\"></a>订阅和取消订阅</h4><p>被观察者可以在收到观察者发出的Subscribe通知后马上开始向其发送通知<br>当观察者发送UnSubscribe通知给被观察者时, 被观察者会试图停止向其发送通知, 但这是不被保证的,<br>被观察者发送OnCompleted或OnError通知给观察者时, 它们的订阅关系将会自动结束. 不需要再由观察者发送UnSubscribe消息给被观察者</p>\n<h4 id=\"多个订阅者\"><a href=\"#多个订阅者\" class=\"headerlink\" title=\"多个订阅者\"></a>多个订阅者</h4><p>如果第二个观察者订阅了一个已经向第一个观察者释放了一些数据的被观察者, 那么第二个观察者收到的消息可能如下</p>\n<ul>\n<li>从订阅开始, 所有订阅者将收到一样的消息,(即新的订阅者会收不到已经释放原来订阅者的消息)</li>\n<li>重新向新的订阅者发送完全相同的数据</li>\n<li>新的订阅者将会收到顺序完全不同的数据</li>\n</ul>\n<p>上面这些都是可能的, 具体哪一种取决于被观察者的实现. </p>\n<p>没有一个通用的约定说两个多个观察者能够得到一样顺序的消息</p>\n<h4 id=\"背压\"><a href=\"#背压\" class=\"headerlink\" title=\"背压\"></a>背压</h4><p>背压是可选的, 并非所有ReactiveX实现都包括背压.而且在哪些包括了背压的实现中, 也并非所有被观察者都支持背压.<br>如果一个被观察者实现了背压，并且它的观察者使用了背压，那么该被观察者不会在订阅后立即向观察者发出项目。相反，它将向观察者发出一个onsubscribe通知。<br>观察者收到onsubscribe消息后, 会发送一个请求通知给被观察者, 指定需要数据的数量, 被观察者就会释放不多于该数量的数据. 当然, 被观察者也可以主动发出OnCompleted和OnError通知, 甚至在观察者发送请求通知前发出以结束订阅.</p>\n<p>对于没有实现背压的被观察者, 当它收到来自观察者的请求通知时, 应该回敬一个OnError通知, 说明自己并不支持背压</p>\n<p>请求是累积的: 如果一个观察者发出了三个请求通知, 分别请求3,5,10条数据, 则被观察者将会至多发送18条数据, 不会因为说刚发了两条时马上来了一个5条的请求就把原本剩下的那一条忽略掉.<br>如果被观察者产生了多余请求数量的数据, 多出来的数据的处理方式完全看被观察者自己.</p>\n<h3 id=\"热-冷-的被观察者\"><a href=\"#热-冷-的被观察者\" class=\"headerlink\" title=\"热 , 冷 的被观察者\"></a>热 , 冷 的被观察者</h3><ul>\n<li>热: 指的是被观察者从一开始就释放数据, 这样观察者从订阅开始就只能从中途获取数据</li>\n<li>冷: 指的是被观察者在被定于后才开始释放数据, 这样就能保证获取完整的数据</li>\n<li>connectable: 这是在部分ReactiveX实现中的被观察者, 只有当connect方法被调用时才会释放数据, 而不管有没有观察者订阅他</li>\n</ul>\n<h3 id=\"被观察者操作符的组合\"><a href=\"#被观察者操作符的组合\" class=\"headerlink\" title=\"被观察者操作符的组合\"></a>被观察者操作符的组合</h3><p>被观察者和观察者仅仅是ReactiveX的开始, 他们本身只是标准的观察者模式的轻量级扩展, 更适合处理一连串事件, 而不是单个回调<br>其真正厉害的地方在于通过操作符转换, 组合, 运算由被观察者释放出来的一系列数据</p>\n<h2 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h2><h3 id=\"操作分类\"><a href=\"#操作分类\" class=\"headerlink\" title=\"操作分类\"></a>操作分类</h3><h4 id=\"创建被观察者\"><a href=\"#创建被观察者\" class=\"headerlink\" title=\"创建被观察者\"></a>创建被观察者</h4><ul>\n<li>create: 通知显式调用订阅者方法来创建Observable</li>\n<li>defer: 观察者订阅时才创建, 不订阅就不创建, 且为每个新的观察者创建一个新的被观察者</li>\n<li>interval: 创建一个每隔一段时间释放一个数据的被观察者</li>\n</ul>\n<h4 id=\"处理操作\"><a href=\"#处理操作\" class=\"headerlink\" title=\"处理操作\"></a>处理操作</h4><ul>\n<li>buffer: 被观察者一个一个地发送数据, 该操作设定缓存个数, 缓存满了之后将整个缓存一起释放</li>\n<li>flatMap: 将多个被观察者释放的数据合并到一个被观察者中</li>\n<li>groupBy: 将单个被观察者切分成多个被观察者, 每次只从原被观察者处释放一组</li>\n<li>scan: 对每个释放的数据应用一个函数, 将结果释放出去, 一次运算释放的值会作为下一次运算的输入</li>\n</ul>\n<h4 id=\"过滤操作\"><a href=\"#过滤操作\" class=\"headerlink\" title=\"过滤操作\"></a>过滤操作</h4><ul>\n<li>debounce: 只释放这样的数据, 该数据被释放之后, 指定的一段时间内没有新数据的出现, 则释放该数据.否则对新释放的数据继续做此判断</li>\n<li>elementAt: 只获取释放的第n个元素</li>\n<li>first: 只释放第一个数据, 或满足条件的数据</li>\n<li>last: 只释放最后一个数据</li>\n<li>sample: 获取一段时间内被观察者释放的最后一个数据</li>\n<li>take: 只获取头几个释放的数据</li>\n<li>takeLast: 只获取最后几个释放的数据</li>\n</ul>\n<h4 id=\"组合操作\"><a href=\"#组合操作\" class=\"headerlink\" title=\"组合操作\"></a>组合操作</h4><p>将多个被观察者合并为一个被观察者</p>\n<ul>\n<li>combineLatest: 将一个被观察者释放的数据和另一个被观察者释放的最近的一个数据组合起来</li>\n</ul>\n<p><img src=\"1564822583394.png\" alt=\"1564822583394\"></p>\n<ul>\n<li>join: 将两个被观察者释放的在一个时间窗中的数据进行合并</li>\n</ul>\n<p><img src=\"1564823248295.png\" alt=\"1564823248295\"></p>\n<ul>\n<li>merge: 直接将两个释放合并</li>\n</ul>\n<p><img src=\"1564823342178.png\" alt=\"1564823342178\"></p>\n<ul>\n<li>startWith: 在释放常规数据前, 先释放指定的数据</li>\n</ul>\n<p><img src=\"1564823975876.png\" alt=\"1564823975876\"></p>\n<ul>\n<li>switch: 将释放数据为Observable的几个被观察者转换成一个释放所有这些数据的被观察者</li>\n</ul>\n<p><img src=\"switch.c.png\" alt=\"Switch\"></p>\n<ul>\n<li>zip: 将多个被观察者释放的数据以一定的方法合并到一个被观察者上</li>\n</ul>\n<p><img src=\"1564824218864.png\" alt=\"1564824218864\"></p>\n<h4 id=\"错误处理操作\"><a href=\"#错误处理操作\" class=\"headerlink\" title=\"错误处理操作\"></a>错误处理操作</h4><ul>\n<li>catch: 从错误中恢复出来, 使原被观察者继续执行</li>\n<li>retry: 被观察者抛出错误时, 重新订阅它</li>\n</ul>\n<h4 id=\"被观察者的工具操作\"><a href=\"#被观察者的工具操作\" class=\"headerlink\" title=\"被观察者的工具操作\"></a>被观察者的工具操作</h4><ul>\n<li>delay: 每个元素都延迟释放</li>\n<li>doOnEach: 为每个元素执行一个操作</li>\n<li>materialize: 将释放的消息和发送的通知都当做释放的消息</li>\n<li>observeOn: 指定观察者将会在哪个schedudler上对被观察者进行观察</li>\n<li>subscribe: 将被观察者绑定到观察者</li>\n<li>timeInterval: 将一个释放普通元素的被观察者转换为释放元素之间的时间间隔的被观察者</li>\n<li>timeout: 一个元素释放后的指定时间内不再释放新的元素时, 停止该被观察者</li>\n<li>timestamp: 为每一个释放的元素绑定一个时间戳</li>\n</ul>\n<h4 id=\"条件和布尔操作\"><a href=\"#条件和布尔操作\" class=\"headerlink\" title=\"条件和布尔操作\"></a>条件和布尔操作</h4><ul>\n<li>all: 判断是否释放的所有元素都满足给定条件</li>\n<li>amb: 给定多个被观察者, 只获取最先释放数据的被观察者的所有数据</li>\n<li>contains: 判断释放的元素是否包含指定元素</li>\n<li>sequenceEqual: 判断两个被观察者是否释放了一样的数据流</li>\n</ul>\n<h4 id=\"数学和聚集操作\"><a href=\"#数学和聚集操作\" class=\"headerlink\" title=\"数学和聚集操作\"></a>数学和聚集操作</h4><ul>\n<li>concat:  将两个被观察者连接起来, 一个被观察者释放完所有数据后, 另一个被观察者才继续释放它的所有数据</li>\n<li>reduce: 对每个释放的数据应用某个函数, 并输出最终结果</li>\n</ul>\n<p><img src=\"1564825542157.png\" alt=\"1564825542157\"></p>\n<h4 id=\"背压操作\"><a href=\"#背压操作\" class=\"headerlink\" title=\"背压操作\"></a>背压操作</h4><p>这是用来应对生产数据快过消费数据的情况</p>\n<h4 id=\"Connectable-Observable的操作\"><a href=\"#Connectable-Observable的操作\" class=\"headerlink\" title=\"Connectable Observable的操作\"></a>Connectable Observable的操作</h4><ul>\n<li>connect: 开始释放数据</li>\n<li>publish: 将原本的observable转换成一个Connectable Observable</li>\n<li>refcount: 使Connectable Observable向一个原始Observable一样工作</li>\n<li>replay: 确保所有观察者都能够看到相同顺序的数据, 即使他们在不同时刻订阅</li>\n</ul>\n<h4 id=\"Observable转换操作\"><a href=\"#Observable转换操作\" class=\"headerlink\" title=\"Observable转换操作\"></a>Observable转换操作</h4><ul>\n<li>to:  将一个Observable转换成其它对象或数据结构</li>\n</ul>\n<h2 id=\"Single\"><a href=\"#Single\" class=\"headerlink\" title=\"Single\"></a>Single</h2><p>Single是Observable的一个变体, 不同于Observable是释放一系列数据, Single仅释放一个数据, 或触发一次错误.因此, Single中, 仅能使用OnSuccess与OnError同观察者交流. 当上述两个方法中任意一个被调用了, 另一个都不会再被调用, Single也停止了, 订阅关系也自动解除了.<br>也就是说, Single没有结束一说, 只有成功和错误两个时机, 因此调用doOnCompleted是不会被触发的</p>\n<h3 id=\"Single中值得记住的方法\"><a href=\"#Single中值得记住的方法\" class=\"headerlink\" title=\"Single中值得记住的方法\"></a>Single中值得记住的方法</h3><ul>\n<li>doOnSuccess/doOnError: 在调用OnSuccess和OnError方法时, 会同时触发该方法</li>\n</ul>\n<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><p>Subject在某些实现中有做, 它可以看做是一个桥梁或是一个代理, 能够同时充当订阅者, 获取其它被观察者的消息, 也能够充当被观察者, 向其它观察者发送消息.</p>\n<p>Subject有四种变形, 分别用在不同的场景下</p>\n<h3 id=\"AsyncSubject\"><a href=\"#AsyncSubject\" class=\"headerlink\" title=\"AsyncSubject\"></a>AsyncSubject</h3><p>AsyncSubject在源Observable结束时, 释放源Observable的最后一个元素, 如果源Observable一个元素都没有释放, 则AsyncSubject也会什么都不释放, 然后结束. 如果源Observable发生错误, 则AsyncSubject会直接将该错误释放, 不会释放其它数据</p>\n<h3 id=\"BehaviorSubject\"><a href=\"#BehaviorSubject\" class=\"headerlink\" title=\"BehaviorSubject\"></a>BehaviorSubject</h3><p>BehaviorSubject会释放源Observable最近释放过的数据, 如果没有最近释放过的数据, 则返回指定的默认值.</p>\n<p>当源Observable发生错误时, BehaviorSubject不会释放任何数据. 而是直接释放该数据</p>\n<h3 id=\"PublishSubject\"><a href=\"#PublishSubject\" class=\"headerlink\" title=\"PublishSubject\"></a>PublishSubject</h3><p>PublishSubject直接将源Observable的数据进行原样释放, 源Observable来一个它就释放一个, 这意味着较晚订阅它的订阅者会丢失订阅之前的消息</p>\n<h3 id=\"ReplaySubject\"><a href=\"#ReplaySubject\" class=\"headerlink\" title=\"ReplaySubject\"></a>ReplaySubject</h3><p>ReplaySubject会将源Observable所释放的数据全部再次释放一遍.</p>\n<h2 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h2><p>Scheduler用于做线程调度.</p>\n<p>默认情况下, Observable及其操作链将会工作在subscribe调用时的线程上. 可以通过ObserveOn操作符改变该行为. 该方法指定一个线程调度器, Observable会在其上运行.</p>\n<p>SubscribeOn指定了Observable将会在哪个调度器上进行操作, 即观察者所在的线程.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h2><p> ReactiveX中, 应用的是观察者模式, 一个观察者订阅一个被观察者. 然后该观察者根据被观察者释放的任何信息进行反应. 这样能够使得并发称为可能, 观察者不必阻塞等待被观察者的响应内容, 而是创建一个哨兵, 并随时准备在未来的任何时候响应被观察者释放出的内容<br>","more":"<br>Observable通过调用Observer的方法向其发送通知<br>如下图片能够展示一个被观察者释放的一系列数据, 以及对这些数据进行转换的操作</p>\n<p><img src=\"1564802038820.png\" alt=\"1564802038820\"></p>\n<p>本文中称的观察者, 在别的文档中有时也被称为订阅者, 也叫作反应器. 该模型对应于 反应式模型</p>\n<h3 id=\"建立一个Observable\"><a href=\"#建立一个Observable\" class=\"headerlink\" title=\"建立一个Observable\"></a>建立一个Observable</h3><ul>\n<li>定义一个结果处理的方法, 该方法是观察者的一部分</li>\n<li>将异步调用本身定义为被观察者</li>\n<li>通过订阅的方式, 将观察者附加到被观察者身上. </li>\n</ul>\n<h3 id=\"OnNext-OnCompleted-OnError\"><a href=\"#OnNext-OnCompleted-OnError\" class=\"headerlink\" title=\"OnNext, OnCompleted, OnError\"></a>OnNext, OnCompleted, OnError</h3><p>这些是观察者的一部分. 三个方法被调用的时机不同</p>\n<ul>\n<li><p>OnNext<br>被观察者每次释放一个数据都会调用它</p>\n</li>\n<li><p>OnError<br>当被观察者发生错误时会调用, 调用该方法后, OnNext和OnCompleted方法都不会再被调用</p>\n</li>\n<li><p>OnCompleted<br>在调用最后一次OnNext时会调用OnCompleted</p>\n</li>\n</ul>\n<p>我们管OnNext叫做释放数据, 管OnError和OnCompleted叫通知.</p>\n<h3 id=\"观察者约定-The-Observable-Contract\"><a href=\"#观察者约定-The-Observable-Contract\" class=\"headerlink\" title=\"观察者约定(The Observable Contract)\"></a>观察者约定(The Observable Contract)</h3><p>该约定尝试对被观察者做一个正式的定义, 他会出现在Rx文档的很多地方</p>\n<h4 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h4><p>一个被观察者通过如下方式和它的观察者们交流</p>\n<ul>\n<li>OnNext: 从被观察者向观察者传送一个item</li>\n<li>OnCompleted: 表明被观察者已经成功地完成, 并且不会再释放数据</li>\n<li>OnError: 表明被观察者已经被某个原因中止, 并且不会再释放数据</li>\n<li>OnSubscribe(背压): 表明被观察者已经准备好接收来自观察者的请求通知</li>\n</ul>\n<p>一个观察者通过如下方式和它的被观察者交流</p>\n<ul>\n<li>Subscribe: 表明观察者已经准备好接收来自被观察者的通知</li>\n<li>UnSubscribe: 表明观察者已经不想要再接收到被观察者的通知了</li>\n<li>Request(背压): 表明观察者只希望接收到不超过特定数量的来自被观察者的通知(通过OnNext发送过来的)</li>\n</ul>\n<h4 id=\"约定\"><a href=\"#约定\" class=\"headerlink\" title=\"约定\"></a>约定</h4><p>一个被观察者可能调用0次或多次OnNext, OnCompleted和OnError只会且一定会调用其一, 且其后不得再发送任何通知</p>\n<p>一个被观察者可能根本不会释放任何数据, 也可能因为永远不停止而不会发出OnCompleted和OnError. 即: 观察者可能不发出任何通知, 可能发出OnCompleted和OnError通知, 也可能仅发出OnNext通知</p>\n<p>一个被观察者发送给观察者的通知必须是串行的, 他们可以在不同的线程发出, 但必须有一个先行发生原则确保其顺序</p>\n<h4 id=\"被观察者的中止\"><a href=\"#被观察者的中止\" class=\"headerlink\" title=\"被观察者的中止\"></a>被观察者的中止</h4><p>如果被观察者没有发出完成或错误通知, 观察者会认为它仍然是活动的, 并且可能会给他发送通知(如unsubscribe和request通知等).<br>如果被观察者发出了完成或错误通知, 该被观察者会释放其资源, 其观察者不应试图与其有进一步的沟通<br>一个OnError通知必须包含错误原因, 就是说传入一个null的OnError是无效的<br>被观察者停止自己之前, 必须先向它的所有订阅者发出OnCompleted或OnError消息</p>\n<h4 id=\"订阅和取消订阅\"><a href=\"#订阅和取消订阅\" class=\"headerlink\" title=\"订阅和取消订阅\"></a>订阅和取消订阅</h4><p>被观察者可以在收到观察者发出的Subscribe通知后马上开始向其发送通知<br>当观察者发送UnSubscribe通知给被观察者时, 被观察者会试图停止向其发送通知, 但这是不被保证的,<br>被观察者发送OnCompleted或OnError通知给观察者时, 它们的订阅关系将会自动结束. 不需要再由观察者发送UnSubscribe消息给被观察者</p>\n<h4 id=\"多个订阅者\"><a href=\"#多个订阅者\" class=\"headerlink\" title=\"多个订阅者\"></a>多个订阅者</h4><p>如果第二个观察者订阅了一个已经向第一个观察者释放了一些数据的被观察者, 那么第二个观察者收到的消息可能如下</p>\n<ul>\n<li>从订阅开始, 所有订阅者将收到一样的消息,(即新的订阅者会收不到已经释放原来订阅者的消息)</li>\n<li>重新向新的订阅者发送完全相同的数据</li>\n<li>新的订阅者将会收到顺序完全不同的数据</li>\n</ul>\n<p>上面这些都是可能的, 具体哪一种取决于被观察者的实现. </p>\n<p>没有一个通用的约定说两个多个观察者能够得到一样顺序的消息</p>\n<h4 id=\"背压\"><a href=\"#背压\" class=\"headerlink\" title=\"背压\"></a>背压</h4><p>背压是可选的, 并非所有ReactiveX实现都包括背压.而且在哪些包括了背压的实现中, 也并非所有被观察者都支持背压.<br>如果一个被观察者实现了背压，并且它的观察者使用了背压，那么该被观察者不会在订阅后立即向观察者发出项目。相反，它将向观察者发出一个onsubscribe通知。<br>观察者收到onsubscribe消息后, 会发送一个请求通知给被观察者, 指定需要数据的数量, 被观察者就会释放不多于该数量的数据. 当然, 被观察者也可以主动发出OnCompleted和OnError通知, 甚至在观察者发送请求通知前发出以结束订阅.</p>\n<p>对于没有实现背压的被观察者, 当它收到来自观察者的请求通知时, 应该回敬一个OnError通知, 说明自己并不支持背压</p>\n<p>请求是累积的: 如果一个观察者发出了三个请求通知, 分别请求3,5,10条数据, 则被观察者将会至多发送18条数据, 不会因为说刚发了两条时马上来了一个5条的请求就把原本剩下的那一条忽略掉.<br>如果被观察者产生了多余请求数量的数据, 多出来的数据的处理方式完全看被观察者自己.</p>\n<h3 id=\"热-冷-的被观察者\"><a href=\"#热-冷-的被观察者\" class=\"headerlink\" title=\"热 , 冷 的被观察者\"></a>热 , 冷 的被观察者</h3><ul>\n<li>热: 指的是被观察者从一开始就释放数据, 这样观察者从订阅开始就只能从中途获取数据</li>\n<li>冷: 指的是被观察者在被定于后才开始释放数据, 这样就能保证获取完整的数据</li>\n<li>connectable: 这是在部分ReactiveX实现中的被观察者, 只有当connect方法被调用时才会释放数据, 而不管有没有观察者订阅他</li>\n</ul>\n<h3 id=\"被观察者操作符的组合\"><a href=\"#被观察者操作符的组合\" class=\"headerlink\" title=\"被观察者操作符的组合\"></a>被观察者操作符的组合</h3><p>被观察者和观察者仅仅是ReactiveX的开始, 他们本身只是标准的观察者模式的轻量级扩展, 更适合处理一连串事件, 而不是单个回调<br>其真正厉害的地方在于通过操作符转换, 组合, 运算由被观察者释放出来的一系列数据</p>\n<h2 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h2><h3 id=\"操作分类\"><a href=\"#操作分类\" class=\"headerlink\" title=\"操作分类\"></a>操作分类</h3><h4 id=\"创建被观察者\"><a href=\"#创建被观察者\" class=\"headerlink\" title=\"创建被观察者\"></a>创建被观察者</h4><ul>\n<li>create: 通知显式调用订阅者方法来创建Observable</li>\n<li>defer: 观察者订阅时才创建, 不订阅就不创建, 且为每个新的观察者创建一个新的被观察者</li>\n<li>interval: 创建一个每隔一段时间释放一个数据的被观察者</li>\n</ul>\n<h4 id=\"处理操作\"><a href=\"#处理操作\" class=\"headerlink\" title=\"处理操作\"></a>处理操作</h4><ul>\n<li>buffer: 被观察者一个一个地发送数据, 该操作设定缓存个数, 缓存满了之后将整个缓存一起释放</li>\n<li>flatMap: 将多个被观察者释放的数据合并到一个被观察者中</li>\n<li>groupBy: 将单个被观察者切分成多个被观察者, 每次只从原被观察者处释放一组</li>\n<li>scan: 对每个释放的数据应用一个函数, 将结果释放出去, 一次运算释放的值会作为下一次运算的输入</li>\n</ul>\n<h4 id=\"过滤操作\"><a href=\"#过滤操作\" class=\"headerlink\" title=\"过滤操作\"></a>过滤操作</h4><ul>\n<li>debounce: 只释放这样的数据, 该数据被释放之后, 指定的一段时间内没有新数据的出现, 则释放该数据.否则对新释放的数据继续做此判断</li>\n<li>elementAt: 只获取释放的第n个元素</li>\n<li>first: 只释放第一个数据, 或满足条件的数据</li>\n<li>last: 只释放最后一个数据</li>\n<li>sample: 获取一段时间内被观察者释放的最后一个数据</li>\n<li>take: 只获取头几个释放的数据</li>\n<li>takeLast: 只获取最后几个释放的数据</li>\n</ul>\n<h4 id=\"组合操作\"><a href=\"#组合操作\" class=\"headerlink\" title=\"组合操作\"></a>组合操作</h4><p>将多个被观察者合并为一个被观察者</p>\n<ul>\n<li>combineLatest: 将一个被观察者释放的数据和另一个被观察者释放的最近的一个数据组合起来</li>\n</ul>\n<p><img src=\"1564822583394.png\" alt=\"1564822583394\"></p>\n<ul>\n<li>join: 将两个被观察者释放的在一个时间窗中的数据进行合并</li>\n</ul>\n<p><img src=\"1564823248295.png\" alt=\"1564823248295\"></p>\n<ul>\n<li>merge: 直接将两个释放合并</li>\n</ul>\n<p><img src=\"1564823342178.png\" alt=\"1564823342178\"></p>\n<ul>\n<li>startWith: 在释放常规数据前, 先释放指定的数据</li>\n</ul>\n<p><img src=\"1564823975876.png\" alt=\"1564823975876\"></p>\n<ul>\n<li>switch: 将释放数据为Observable的几个被观察者转换成一个释放所有这些数据的被观察者</li>\n</ul>\n<p><img src=\"switch.c.png\" alt=\"Switch\"></p>\n<ul>\n<li>zip: 将多个被观察者释放的数据以一定的方法合并到一个被观察者上</li>\n</ul>\n<p><img src=\"1564824218864.png\" alt=\"1564824218864\"></p>\n<h4 id=\"错误处理操作\"><a href=\"#错误处理操作\" class=\"headerlink\" title=\"错误处理操作\"></a>错误处理操作</h4><ul>\n<li>catch: 从错误中恢复出来, 使原被观察者继续执行</li>\n<li>retry: 被观察者抛出错误时, 重新订阅它</li>\n</ul>\n<h4 id=\"被观察者的工具操作\"><a href=\"#被观察者的工具操作\" class=\"headerlink\" title=\"被观察者的工具操作\"></a>被观察者的工具操作</h4><ul>\n<li>delay: 每个元素都延迟释放</li>\n<li>doOnEach: 为每个元素执行一个操作</li>\n<li>materialize: 将释放的消息和发送的通知都当做释放的消息</li>\n<li>observeOn: 指定观察者将会在哪个schedudler上对被观察者进行观察</li>\n<li>subscribe: 将被观察者绑定到观察者</li>\n<li>timeInterval: 将一个释放普通元素的被观察者转换为释放元素之间的时间间隔的被观察者</li>\n<li>timeout: 一个元素释放后的指定时间内不再释放新的元素时, 停止该被观察者</li>\n<li>timestamp: 为每一个释放的元素绑定一个时间戳</li>\n</ul>\n<h4 id=\"条件和布尔操作\"><a href=\"#条件和布尔操作\" class=\"headerlink\" title=\"条件和布尔操作\"></a>条件和布尔操作</h4><ul>\n<li>all: 判断是否释放的所有元素都满足给定条件</li>\n<li>amb: 给定多个被观察者, 只获取最先释放数据的被观察者的所有数据</li>\n<li>contains: 判断释放的元素是否包含指定元素</li>\n<li>sequenceEqual: 判断两个被观察者是否释放了一样的数据流</li>\n</ul>\n<h4 id=\"数学和聚集操作\"><a href=\"#数学和聚集操作\" class=\"headerlink\" title=\"数学和聚集操作\"></a>数学和聚集操作</h4><ul>\n<li>concat:  将两个被观察者连接起来, 一个被观察者释放完所有数据后, 另一个被观察者才继续释放它的所有数据</li>\n<li>reduce: 对每个释放的数据应用某个函数, 并输出最终结果</li>\n</ul>\n<p><img src=\"1564825542157.png\" alt=\"1564825542157\"></p>\n<h4 id=\"背压操作\"><a href=\"#背压操作\" class=\"headerlink\" title=\"背压操作\"></a>背压操作</h4><p>这是用来应对生产数据快过消费数据的情况</p>\n<h4 id=\"Connectable-Observable的操作\"><a href=\"#Connectable-Observable的操作\" class=\"headerlink\" title=\"Connectable Observable的操作\"></a>Connectable Observable的操作</h4><ul>\n<li>connect: 开始释放数据</li>\n<li>publish: 将原本的observable转换成一个Connectable Observable</li>\n<li>refcount: 使Connectable Observable向一个原始Observable一样工作</li>\n<li>replay: 确保所有观察者都能够看到相同顺序的数据, 即使他们在不同时刻订阅</li>\n</ul>\n<h4 id=\"Observable转换操作\"><a href=\"#Observable转换操作\" class=\"headerlink\" title=\"Observable转换操作\"></a>Observable转换操作</h4><ul>\n<li>to:  将一个Observable转换成其它对象或数据结构</li>\n</ul>\n<h2 id=\"Single\"><a href=\"#Single\" class=\"headerlink\" title=\"Single\"></a>Single</h2><p>Single是Observable的一个变体, 不同于Observable是释放一系列数据, Single仅释放一个数据, 或触发一次错误.因此, Single中, 仅能使用OnSuccess与OnError同观察者交流. 当上述两个方法中任意一个被调用了, 另一个都不会再被调用, Single也停止了, 订阅关系也自动解除了.<br>也就是说, Single没有结束一说, 只有成功和错误两个时机, 因此调用doOnCompleted是不会被触发的</p>\n<h3 id=\"Single中值得记住的方法\"><a href=\"#Single中值得记住的方法\" class=\"headerlink\" title=\"Single中值得记住的方法\"></a>Single中值得记住的方法</h3><ul>\n<li>doOnSuccess/doOnError: 在调用OnSuccess和OnError方法时, 会同时触发该方法</li>\n</ul>\n<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><p>Subject在某些实现中有做, 它可以看做是一个桥梁或是一个代理, 能够同时充当订阅者, 获取其它被观察者的消息, 也能够充当被观察者, 向其它观察者发送消息.</p>\n<p>Subject有四种变形, 分别用在不同的场景下</p>\n<h3 id=\"AsyncSubject\"><a href=\"#AsyncSubject\" class=\"headerlink\" title=\"AsyncSubject\"></a>AsyncSubject</h3><p>AsyncSubject在源Observable结束时, 释放源Observable的最后一个元素, 如果源Observable一个元素都没有释放, 则AsyncSubject也会什么都不释放, 然后结束. 如果源Observable发生错误, 则AsyncSubject会直接将该错误释放, 不会释放其它数据</p>\n<h3 id=\"BehaviorSubject\"><a href=\"#BehaviorSubject\" class=\"headerlink\" title=\"BehaviorSubject\"></a>BehaviorSubject</h3><p>BehaviorSubject会释放源Observable最近释放过的数据, 如果没有最近释放过的数据, 则返回指定的默认值.</p>\n<p>当源Observable发生错误时, BehaviorSubject不会释放任何数据. 而是直接释放该数据</p>\n<h3 id=\"PublishSubject\"><a href=\"#PublishSubject\" class=\"headerlink\" title=\"PublishSubject\"></a>PublishSubject</h3><p>PublishSubject直接将源Observable的数据进行原样释放, 源Observable来一个它就释放一个, 这意味着较晚订阅它的订阅者会丢失订阅之前的消息</p>\n<h3 id=\"ReplaySubject\"><a href=\"#ReplaySubject\" class=\"headerlink\" title=\"ReplaySubject\"></a>ReplaySubject</h3><p>ReplaySubject会将源Observable所释放的数据全部再次释放一遍.</p>\n<h2 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h2><p>Scheduler用于做线程调度.</p>\n<p>默认情况下, Observable及其操作链将会工作在subscribe调用时的线程上. 可以通过ObserveOn操作符改变该行为. 该方法指定一个线程调度器, Observable会在其上运行.</p>\n<p>SubscribeOn指定了Observable将会在哪个调度器上进行操作, 即观察者所在的线程.</p>"},{"title":"通过几个问题了解Http协议","date":"2018-10-15T14:31:33.000Z","_content":"\n## Http全称？\n\n\t超文本传输协议：Hypertext Transfer protocol\n\n## 常用状态码\n\n```html\n- 200\t响应正常\n- 400\tBad Request，请求数据有问题\n- 401\tUnauthorized，权限不足，资源存在但不让访问\n- 403\tForbidden，你的IP被屏蔽时会出现\n- 404\t资源找不到\n- 301\t重定向\n- 500\t服务器内部错误\n```\n\n## 常用method\n\n```html\n- get\t\t用于获取资源\n- post\t\t用于发送数据到服务端，常用于提交表单数据\n- put\t\t用于修改资源属性\n- delete\t用于删除资源\n```\n\n## Http协议格式\n\n\t请求和响应的消息协议是一样的：起始行、消息头、消息体。三部分以CRLF分隔，最后一个消息头有两个CRLF，表示接下来是消息体的内容了。\n\n### 起始行\n\n\t请求的起始行称为请求行，格式：method uri http/version，如 get /index.html http/1.1\n\t\n\t响应的起始行称为状态行，格式 ：http/version code desc，如 http/1.1 200 ok。第三个字段是状态码的简单描述信息。\n\n### 消息头\n\n\t消息头由很多键值对组成，键值对之间以CRLF作为分隔。\n\n### 消息体\n\n\t消息体是一个字符串，字符串长度由消息头中的Content-length字段指定。没有指定则没有消息体。\n\n## 分块传送\n\n\t当浏览器向服务器请求一个资源时，该资源是一个动态资源，服务器无法预知该资源的大小。此时会采用分块传送。\n\t\n\t服务器先生成一个chunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。分块传送需要在请求头增加一个特殊的键值对transfer-encoding: chunked，那么消息体的内容便是分块传送的。\n\t\n\tchunked传输格式如下图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTIzNjg2NDEwMjEsMTU4MTE3ODM1MiZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png)\n\n## 持久连接的机制是怎样的\n\n\t早期的Http 1.0每个请求都会发起一个连接，每个页面数百个请求就会发起数百个连接，非常浪费服务器资源。因此在Http 1.1加入了持久连接的机制，Keep-Alive，使得一个连接可以连续服务多个请求。节省了资源\n\t\n\t持久连接并不会一直保持连接，而是通过设置 Keep Alive Timeout和Keep Alive Request限制单个连接的持续时长和最多的请求次数。\n\t\n\t如果 Keep Alive Timeout设置为0，则退化到非持久连接。如果Keep Alive Timeout设置为超长，当然也不会一直保持，各个浏览器都有相关的控制。\n\n## 什么叫Pipeline管线化\n\n\t这也是Http 1.1新引入的特性。之前的请求模式是：一个请求发起，服务器响应完了，再进行下一个请求的发起和响应，这样当请求一多时就会很慢\n\t\n\t改进的方式是，将多个请求按顺序打包一起发给服务器，服务器再按顺序将多个响应一起打包回复。这样就快很多了。如下图示很形象地描述了管线化前和管线化后\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTM0MDIwNDQ4MzgsNzAzNzIwMjE1JmZtPTE3MyZhcHA9MjUmZj1KUEVH?x-oss-process=image/format,png)\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmFpZHUuY29tLzZPTllzamlwMFFJWjh0eWhucS9pdC91PTEyOTc0NTkzNDksMTU2MTg5NTk3MSZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png)\n\n## 如何理解Http协议的无状态性\n\n\t无状态指的是服务器的协议层无需为不同请求之间建立任何相关关系。不过这是协议规定的，但建立在Http协议上的应用会通过Session的方式来达到状态保存的目录。\n\n## GET和POST的区别\n\n- GET用于获取资源，POST用于向服务器发送数据\n- GET将数据添加到URL后，POST则是将数据放在请求消息体中\n- 由第二点导致了如下三点的不同\n  - GET相对POST能让用户看到传输内容，不安全\n  - GET由于URL长度的限制传输内容有限，POST则好很多\n  - GET由于URL的编码限制只能传输ASCII码，而POST则可以传输正常编码格式的文件\n\n## 常见Http消息头字段\n\n### 通用头部字段\n\n```html\n- Date\t\t\t\t报文创建时间\n- Connection\t\t连接的管理：连续或是此次发送后关闭连接\n- Cache-Control\t\t缓存控制，如值为max-age=120，表示缓存120秒有效\n- Transfer-Encoding\t报文的传输编码格式\n```\n\n### 请求头部字段\n\n```html\n- Host\t\t\t\t请求资源所在服务器：主机+端口\n- User-Agent\t\t客户端将本地的操作系统、浏览器和其它属性发送给服务器，非必须，可修改\n- Accept\t\t\t客户端希望接收的媒体类型，如 image/webp,image/apng,image/*,*/*;q=0.8\n- Accept-Charset\t客户端可接收的字符集\n- Accept-Encoding\t客户端可接收的内容编码，如 gzip, deflate, br\n- Accept-Language\t客户端可接收的自然语言，如 zh-CN,zh;q=0.9\n- Authorization\t\t用于证明客户端有权查看某个资源\n- refer\t\t\t\t\n\n举例\nGET /form.html HTTP/1.1 (CRLF)\n\nAccept:image/gif,image/x-xbitmap,image/jpeg,application/msword,*/* (CRLF)\nAccept-Language:zh-cn (CRLF)\nAccept-Encoding:gzip,deflate (CRLF)\nIf-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)\nIf-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)\nUser-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)\nHost:www.guet.edu.cn (CRLF)\nConnection:Keep-Alive (CRLF)\n```\n\n### 响应头部字段\n\n```html\n- Accept-Ranges\t\t可接受的字节范围\n- Location\t\t\t让客户端重定向到的URL\n- Server\t\t\tHttp服务器的安装信息，如 Apache-Coyote/1.1\n```\n\n### 实体头部字段\n\n```html\n- Allow\t\t\t\t资源可支持的Http方法\n- Content-type\t\t实体内容的类型\n- Content-Encoding\t实体内容的编码方式\n- Content-Language\t实体内容的语言\n- Content-length\t实体内容的长度，单位是字节\n- Content-Range\t\t实体内容的位置范围，一般是发出部分请求时使用\n- Last-Modified\t\t请求资源最后修改时间\n```\n\n## 其它知识补充\n\n### 应用层协议\n\n- HTTP\n- FTP\n- SMTP\n- DNS\n- TELNET","source":"_posts/通过几个问题了解Http协议.md","raw":"---\ntitle: 通过几个问题了解Http协议\ndate: 2018-10-15 22:31:33\ntags: \n    - http\ncategories: \n    - http\n---\n\n## Http全称？\n\n\t超文本传输协议：Hypertext Transfer protocol\n\n## 常用状态码\n\n```html\n- 200\t响应正常\n- 400\tBad Request，请求数据有问题\n- 401\tUnauthorized，权限不足，资源存在但不让访问\n- 403\tForbidden，你的IP被屏蔽时会出现\n- 404\t资源找不到\n- 301\t重定向\n- 500\t服务器内部错误\n```\n\n## 常用method\n\n```html\n- get\t\t用于获取资源\n- post\t\t用于发送数据到服务端，常用于提交表单数据\n- put\t\t用于修改资源属性\n- delete\t用于删除资源\n```\n\n## Http协议格式\n\n\t请求和响应的消息协议是一样的：起始行、消息头、消息体。三部分以CRLF分隔，最后一个消息头有两个CRLF，表示接下来是消息体的内容了。\n\n### 起始行\n\n\t请求的起始行称为请求行，格式：method uri http/version，如 get /index.html http/1.1\n\t\n\t响应的起始行称为状态行，格式 ：http/version code desc，如 http/1.1 200 ok。第三个字段是状态码的简单描述信息。\n\n### 消息头\n\n\t消息头由很多键值对组成，键值对之间以CRLF作为分隔。\n\n### 消息体\n\n\t消息体是一个字符串，字符串长度由消息头中的Content-length字段指定。没有指定则没有消息体。\n\n## 分块传送\n\n\t当浏览器向服务器请求一个资源时，该资源是一个动态资源，服务器无法预知该资源的大小。此时会采用分块传送。\n\t\n\t服务器先生成一个chunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。分块传送需要在请求头增加一个特殊的键值对transfer-encoding: chunked，那么消息体的内容便是分块传送的。\n\t\n\tchunked传输格式如下图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTIzNjg2NDEwMjEsMTU4MTE3ODM1MiZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png)\n\n## 持久连接的机制是怎样的\n\n\t早期的Http 1.0每个请求都会发起一个连接，每个页面数百个请求就会发起数百个连接，非常浪费服务器资源。因此在Http 1.1加入了持久连接的机制，Keep-Alive，使得一个连接可以连续服务多个请求。节省了资源\n\t\n\t持久连接并不会一直保持连接，而是通过设置 Keep Alive Timeout和Keep Alive Request限制单个连接的持续时长和最多的请求次数。\n\t\n\t如果 Keep Alive Timeout设置为0，则退化到非持久连接。如果Keep Alive Timeout设置为超长，当然也不会一直保持，各个浏览器都有相关的控制。\n\n## 什么叫Pipeline管线化\n\n\t这也是Http 1.1新引入的特性。之前的请求模式是：一个请求发起，服务器响应完了，再进行下一个请求的发起和响应，这样当请求一多时就会很慢\n\t\n\t改进的方式是，将多个请求按顺序打包一起发给服务器，服务器再按顺序将多个响应一起打包回复。这样就快很多了。如下图示很形象地描述了管线化前和管线化后\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTM0MDIwNDQ4MzgsNzAzNzIwMjE1JmZtPTE3MyZhcHA9MjUmZj1KUEVH?x-oss-process=image/format,png)\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmFpZHUuY29tLzZPTllzamlwMFFJWjh0eWhucS9pdC91PTEyOTc0NTkzNDksMTU2MTg5NTk3MSZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png)\n\n## 如何理解Http协议的无状态性\n\n\t无状态指的是服务器的协议层无需为不同请求之间建立任何相关关系。不过这是协议规定的，但建立在Http协议上的应用会通过Session的方式来达到状态保存的目录。\n\n## GET和POST的区别\n\n- GET用于获取资源，POST用于向服务器发送数据\n- GET将数据添加到URL后，POST则是将数据放在请求消息体中\n- 由第二点导致了如下三点的不同\n  - GET相对POST能让用户看到传输内容，不安全\n  - GET由于URL长度的限制传输内容有限，POST则好很多\n  - GET由于URL的编码限制只能传输ASCII码，而POST则可以传输正常编码格式的文件\n\n## 常见Http消息头字段\n\n### 通用头部字段\n\n```html\n- Date\t\t\t\t报文创建时间\n- Connection\t\t连接的管理：连续或是此次发送后关闭连接\n- Cache-Control\t\t缓存控制，如值为max-age=120，表示缓存120秒有效\n- Transfer-Encoding\t报文的传输编码格式\n```\n\n### 请求头部字段\n\n```html\n- Host\t\t\t\t请求资源所在服务器：主机+端口\n- User-Agent\t\t客户端将本地的操作系统、浏览器和其它属性发送给服务器，非必须，可修改\n- Accept\t\t\t客户端希望接收的媒体类型，如 image/webp,image/apng,image/*,*/*;q=0.8\n- Accept-Charset\t客户端可接收的字符集\n- Accept-Encoding\t客户端可接收的内容编码，如 gzip, deflate, br\n- Accept-Language\t客户端可接收的自然语言，如 zh-CN,zh;q=0.9\n- Authorization\t\t用于证明客户端有权查看某个资源\n- refer\t\t\t\t\n\n举例\nGET /form.html HTTP/1.1 (CRLF)\n\nAccept:image/gif,image/x-xbitmap,image/jpeg,application/msword,*/* (CRLF)\nAccept-Language:zh-cn (CRLF)\nAccept-Encoding:gzip,deflate (CRLF)\nIf-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)\nIf-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)\nUser-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)\nHost:www.guet.edu.cn (CRLF)\nConnection:Keep-Alive (CRLF)\n```\n\n### 响应头部字段\n\n```html\n- Accept-Ranges\t\t可接受的字节范围\n- Location\t\t\t让客户端重定向到的URL\n- Server\t\t\tHttp服务器的安装信息，如 Apache-Coyote/1.1\n```\n\n### 实体头部字段\n\n```html\n- Allow\t\t\t\t资源可支持的Http方法\n- Content-type\t\t实体内容的类型\n- Content-Encoding\t实体内容的编码方式\n- Content-Language\t实体内容的语言\n- Content-length\t实体内容的长度，单位是字节\n- Content-Range\t\t实体内容的位置范围，一般是发出部分请求时使用\n- Last-Modified\t\t请求资源最后修改时间\n```\n\n## 其它知识补充\n\n### 应用层协议\n\n- HTTP\n- FTP\n- SMTP\n- DNS\n- TELNET","slug":"通过几个问题了解Http协议","published":1,"updated":"2019-09-08T03:00:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0atmo9i001300bnonaq36iq","content":"<h2 id=\"Http全称？\"><a href=\"#Http全称？\" class=\"headerlink\" title=\"Http全称？\"></a>Http全称？</h2><pre><code>超文本传输协议：Hypertext Transfer protocol</code></pre><h2 id=\"常用状态码\"><a href=\"#常用状态码\" class=\"headerlink\" title=\"常用状态码\"></a>常用状态码</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 200\t响应正常</span><br><span class=\"line\">- 400\tBad Request，请求数据有问题</span><br><span class=\"line\">- 401\tUnauthorized，权限不足，资源存在但不让访问</span><br><span class=\"line\">- 403\tForbidden，你的IP被屏蔽时会出现</span><br><span class=\"line\">- 404\t资源找不到</span><br><span class=\"line\">- 301\t重定向</span><br><span class=\"line\">- 500\t服务器内部错误</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n\n<h2 id=\"常用method\"><a href=\"#常用method\" class=\"headerlink\" title=\"常用method\"></a>常用method</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- get\t\t用于获取资源</span><br><span class=\"line\">- post\t\t用于发送数据到服务端，常用于提交表单数据</span><br><span class=\"line\">- put\t\t用于修改资源属性</span><br><span class=\"line\">- delete\t用于删除资源</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Http协议格式\"><a href=\"#Http协议格式\" class=\"headerlink\" title=\"Http协议格式\"></a>Http协议格式</h2><pre><code>请求和响应的消息协议是一样的：起始行、消息头、消息体。三部分以CRLF分隔，最后一个消息头有两个CRLF，表示接下来是消息体的内容了。</code></pre><h3 id=\"起始行\"><a href=\"#起始行\" class=\"headerlink\" title=\"起始行\"></a>起始行</h3><pre><code>请求的起始行称为请求行，格式：method uri http/version，如 get /index.html http/1.1\n\n响应的起始行称为状态行，格式 ：http/version code desc，如 http/1.1 200 ok。第三个字段是状态码的简单描述信息。</code></pre><h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><pre><code>消息头由很多键值对组成，键值对之间以CRLF作为分隔。</code></pre><h3 id=\"消息体\"><a href=\"#消息体\" class=\"headerlink\" title=\"消息体\"></a>消息体</h3><pre><code>消息体是一个字符串，字符串长度由消息头中的Content-length字段指定。没有指定则没有消息体。</code></pre><h2 id=\"分块传送\"><a href=\"#分块传送\" class=\"headerlink\" title=\"分块传送\"></a>分块传送</h2><pre><code>当浏览器向服务器请求一个资源时，该资源是一个动态资源，服务器无法预知该资源的大小。此时会采用分块传送。\n\n服务器先生成一个chunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。分块传送需要在请求头增加一个特殊的键值对transfer-encoding: chunked，那么消息体的内容便是分块传送的。\n\nchunked传输格式如下图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。</code></pre><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTIzNjg2NDEwMjEsMTU4MTE3ODM1MiZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png\" alt=\"img\"></p>\n<h2 id=\"持久连接的机制是怎样的\"><a href=\"#持久连接的机制是怎样的\" class=\"headerlink\" title=\"持久连接的机制是怎样的\"></a>持久连接的机制是怎样的</h2><pre><code>早期的Http 1.0每个请求都会发起一个连接，每个页面数百个请求就会发起数百个连接，非常浪费服务器资源。因此在Http 1.1加入了持久连接的机制，Keep-Alive，使得一个连接可以连续服务多个请求。节省了资源\n\n持久连接并不会一直保持连接，而是通过设置 Keep Alive Timeout和Keep Alive Request限制单个连接的持续时长和最多的请求次数。\n\n如果 Keep Alive Timeout设置为0，则退化到非持久连接。如果Keep Alive Timeout设置为超长，当然也不会一直保持，各个浏览器都有相关的控制。</code></pre><h2 id=\"什么叫Pipeline管线化\"><a href=\"#什么叫Pipeline管线化\" class=\"headerlink\" title=\"什么叫Pipeline管线化\"></a>什么叫Pipeline管线化</h2><pre><code>这也是Http 1.1新引入的特性。之前的请求模式是：一个请求发起，服务器响应完了，再进行下一个请求的发起和响应，这样当请求一多时就会很慢\n\n改进的方式是，将多个请求按顺序打包一起发给服务器，服务器再按顺序将多个响应一起打包回复。这样就快很多了。如下图示很形象地描述了管线化前和管线化后</code></pre><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTM0MDIwNDQ4MzgsNzAzNzIwMjE1JmZtPTE3MyZhcHA9MjUmZj1KUEVH?x-oss-process=image/format,png\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmFpZHUuY29tLzZPTllzamlwMFFJWjh0eWhucS9pdC91PTEyOTc0NTkzNDksMTU2MTg5NTk3MSZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png\" alt=\"img\"></p>\n<h2 id=\"如何理解Http协议的无状态性\"><a href=\"#如何理解Http协议的无状态性\" class=\"headerlink\" title=\"如何理解Http协议的无状态性\"></a>如何理解Http协议的无状态性</h2><pre><code>无状态指的是服务器的协议层无需为不同请求之间建立任何相关关系。不过这是协议规定的，但建立在Http协议上的应用会通过Session的方式来达到状态保存的目录。</code></pre><h2 id=\"GET和POST的区别\"><a href=\"#GET和POST的区别\" class=\"headerlink\" title=\"GET和POST的区别\"></a>GET和POST的区别</h2><ul>\n<li>GET用于获取资源，POST用于向服务器发送数据</li>\n<li>GET将数据添加到URL后，POST则是将数据放在请求消息体中</li>\n<li>由第二点导致了如下三点的不同<ul>\n<li>GET相对POST能让用户看到传输内容，不安全</li>\n<li>GET由于URL长度的限制传输内容有限，POST则好很多</li>\n<li>GET由于URL的编码限制只能传输ASCII码，而POST则可以传输正常编码格式的文件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"常见Http消息头字段\"><a href=\"#常见Http消息头字段\" class=\"headerlink\" title=\"常见Http消息头字段\"></a>常见Http消息头字段</h2><h3 id=\"通用头部字段\"><a href=\"#通用头部字段\" class=\"headerlink\" title=\"通用头部字段\"></a>通用头部字段</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Date\t\t\t\t报文创建时间</span><br><span class=\"line\">- Connection\t\t连接的管理：连续或是此次发送后关闭连接</span><br><span class=\"line\">- Cache-Control\t\t缓存控制，如值为max-age=120，表示缓存120秒有效</span><br><span class=\"line\">- Transfer-Encoding\t报文的传输编码格式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求头部字段\"><a href=\"#请求头部字段\" class=\"headerlink\" title=\"请求头部字段\"></a>请求头部字段</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Host\t\t\t\t请求资源所在服务器：主机+端口</span><br><span class=\"line\">- User-Agent\t\t客户端将本地的操作系统、浏览器和其它属性发送给服务器，非必须，可修改</span><br><span class=\"line\">- Accept\t\t\t客户端希望接收的媒体类型，如 image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class=\"line\">- Accept-Charset\t客户端可接收的字符集</span><br><span class=\"line\">- Accept-Encoding\t客户端可接收的内容编码，如 gzip, deflate, br</span><br><span class=\"line\">- Accept-Language\t客户端可接收的自然语言，如 zh-CN,zh;q=0.9</span><br><span class=\"line\">- Authorization\t\t用于证明客户端有权查看某个资源</span><br><span class=\"line\">- refer\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">举例</span><br><span class=\"line\">GET /form.html HTTP/1.1 (CRLF)</span><br><span class=\"line\"></span><br><span class=\"line\">Accept:image/gif,image/x-xbitmap,image/jpeg,application/msword,*/* (CRLF)</span><br><span class=\"line\">Accept-Language:zh-cn (CRLF)</span><br><span class=\"line\">Accept-Encoding:gzip,deflate (CRLF)</span><br><span class=\"line\">If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)</span><br><span class=\"line\">If-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)</span><br><span class=\"line\">User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)</span><br><span class=\"line\">Host:www.guet.edu.cn (CRLF)</span><br><span class=\"line\">Connection:Keep-Alive (CRLF)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"响应头部字段\"><a href=\"#响应头部字段\" class=\"headerlink\" title=\"响应头部字段\"></a>响应头部字段</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Accept-Ranges\t\t可接受的字节范围</span><br><span class=\"line\">- Location\t\t\t让客户端重定向到的URL</span><br><span class=\"line\">- Server\t\t\tHttp服务器的安装信息，如 Apache-Coyote/1.1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实体头部字段\"><a href=\"#实体头部字段\" class=\"headerlink\" title=\"实体头部字段\"></a>实体头部字段</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Allow\t\t\t\t资源可支持的Http方法</span><br><span class=\"line\">- Content-type\t\t实体内容的类型</span><br><span class=\"line\">- Content-Encoding\t实体内容的编码方式</span><br><span class=\"line\">- Content-Language\t实体内容的语言</span><br><span class=\"line\">- Content-length\t实体内容的长度，单位是字节</span><br><span class=\"line\">- Content-Range\t\t实体内容的位置范围，一般是发出部分请求时使用</span><br><span class=\"line\">- Last-Modified\t\t请求资源最后修改时间</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其它知识补充\"><a href=\"#其它知识补充\" class=\"headerlink\" title=\"其它知识补充\"></a>其它知识补充</h2><h3 id=\"应用层协议\"><a href=\"#应用层协议\" class=\"headerlink\" title=\"应用层协议\"></a>应用层协议</h3><ul>\n<li>HTTP</li>\n<li>FTP</li>\n<li>SMTP</li>\n<li>DNS</li>\n<li>TELNET</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Http全称？\"><a href=\"#Http全称？\" class=\"headerlink\" title=\"Http全称？\"></a>Http全称？</h2><pre><code>超文本传输协议：Hypertext Transfer protocol</code></pre><h2 id=\"常用状态码\"><a href=\"#常用状态码\" class=\"headerlink\" title=\"常用状态码\"></a>常用状态码</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 200\t响应正常</span><br><span class=\"line\">- 400\tBad Request，请求数据有问题</span><br><span class=\"line\">- 401\tUnauthorized，权限不足，资源存在但不让访问</span><br><span class=\"line\">- 403\tForbidden，你的IP被屏蔽时会出现</span><br><span class=\"line\">- 404\t资源找不到</span><br><span class=\"line\">- 301\t重定向</span><br><span class=\"line\">- 500\t服务器内部错误</span><br></pre></td></tr></table></figure>","more":"\n\n<h2 id=\"常用method\"><a href=\"#常用method\" class=\"headerlink\" title=\"常用method\"></a>常用method</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- get\t\t用于获取资源</span><br><span class=\"line\">- post\t\t用于发送数据到服务端，常用于提交表单数据</span><br><span class=\"line\">- put\t\t用于修改资源属性</span><br><span class=\"line\">- delete\t用于删除资源</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Http协议格式\"><a href=\"#Http协议格式\" class=\"headerlink\" title=\"Http协议格式\"></a>Http协议格式</h2><pre><code>请求和响应的消息协议是一样的：起始行、消息头、消息体。三部分以CRLF分隔，最后一个消息头有两个CRLF，表示接下来是消息体的内容了。</code></pre><h3 id=\"起始行\"><a href=\"#起始行\" class=\"headerlink\" title=\"起始行\"></a>起始行</h3><pre><code>请求的起始行称为请求行，格式：method uri http/version，如 get /index.html http/1.1\n\n响应的起始行称为状态行，格式 ：http/version code desc，如 http/1.1 200 ok。第三个字段是状态码的简单描述信息。</code></pre><h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><pre><code>消息头由很多键值对组成，键值对之间以CRLF作为分隔。</code></pre><h3 id=\"消息体\"><a href=\"#消息体\" class=\"headerlink\" title=\"消息体\"></a>消息体</h3><pre><code>消息体是一个字符串，字符串长度由消息头中的Content-length字段指定。没有指定则没有消息体。</code></pre><h2 id=\"分块传送\"><a href=\"#分块传送\" class=\"headerlink\" title=\"分块传送\"></a>分块传送</h2><pre><code>当浏览器向服务器请求一个资源时，该资源是一个动态资源，服务器无法预知该资源的大小。此时会采用分块传送。\n\n服务器先生成一个chunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。分块传送需要在请求头增加一个特殊的键值对transfer-encoding: chunked，那么消息体的内容便是分块传送的。\n\nchunked传输格式如下图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。</code></pre><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTIzNjg2NDEwMjEsMTU4MTE3ODM1MiZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png\" alt=\"img\"></p>\n<h2 id=\"持久连接的机制是怎样的\"><a href=\"#持久连接的机制是怎样的\" class=\"headerlink\" title=\"持久连接的机制是怎样的\"></a>持久连接的机制是怎样的</h2><pre><code>早期的Http 1.0每个请求都会发起一个连接，每个页面数百个请求就会发起数百个连接，非常浪费服务器资源。因此在Http 1.1加入了持久连接的机制，Keep-Alive，使得一个连接可以连续服务多个请求。节省了资源\n\n持久连接并不会一直保持连接，而是通过设置 Keep Alive Timeout和Keep Alive Request限制单个连接的持续时长和最多的请求次数。\n\n如果 Keep Alive Timeout设置为0，则退化到非持久连接。如果Keep Alive Timeout设置为超长，当然也不会一直保持，各个浏览器都有相关的控制。</code></pre><h2 id=\"什么叫Pipeline管线化\"><a href=\"#什么叫Pipeline管线化\" class=\"headerlink\" title=\"什么叫Pipeline管线化\"></a>什么叫Pipeline管线化</h2><pre><code>这也是Http 1.1新引入的特性。之前的请求模式是：一个请求发起，服务器响应完了，再进行下一个请求的发起和响应，这样当请求一多时就会很慢\n\n改进的方式是，将多个请求按顺序打包一起发给服务器，服务器再按顺序将多个响应一起打包回复。这样就快很多了。如下图示很形象地描述了管线化前和管线化后</code></pre><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmFpZHUuY29tLzZPTldzamlwMFFJWjh0eWhucS9pdC91PTM0MDIwNDQ4MzgsNzAzNzIwMjE1JmZtPTE3MyZhcHA9MjUmZj1KUEVH?x-oss-process=image/format,png\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmFpZHUuY29tLzZPTllzamlwMFFJWjh0eWhucS9pdC91PTEyOTc0NTkzNDksMTU2MTg5NTk3MSZmbT0xNzMmYXBwPTI1JmY9SlBFRw?x-oss-process=image/format,png\" alt=\"img\"></p>\n<h2 id=\"如何理解Http协议的无状态性\"><a href=\"#如何理解Http协议的无状态性\" class=\"headerlink\" title=\"如何理解Http协议的无状态性\"></a>如何理解Http协议的无状态性</h2><pre><code>无状态指的是服务器的协议层无需为不同请求之间建立任何相关关系。不过这是协议规定的，但建立在Http协议上的应用会通过Session的方式来达到状态保存的目录。</code></pre><h2 id=\"GET和POST的区别\"><a href=\"#GET和POST的区别\" class=\"headerlink\" title=\"GET和POST的区别\"></a>GET和POST的区别</h2><ul>\n<li>GET用于获取资源，POST用于向服务器发送数据</li>\n<li>GET将数据添加到URL后，POST则是将数据放在请求消息体中</li>\n<li>由第二点导致了如下三点的不同<ul>\n<li>GET相对POST能让用户看到传输内容，不安全</li>\n<li>GET由于URL长度的限制传输内容有限，POST则好很多</li>\n<li>GET由于URL的编码限制只能传输ASCII码，而POST则可以传输正常编码格式的文件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"常见Http消息头字段\"><a href=\"#常见Http消息头字段\" class=\"headerlink\" title=\"常见Http消息头字段\"></a>常见Http消息头字段</h2><h3 id=\"通用头部字段\"><a href=\"#通用头部字段\" class=\"headerlink\" title=\"通用头部字段\"></a>通用头部字段</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Date\t\t\t\t报文创建时间</span><br><span class=\"line\">- Connection\t\t连接的管理：连续或是此次发送后关闭连接</span><br><span class=\"line\">- Cache-Control\t\t缓存控制，如值为max-age=120，表示缓存120秒有效</span><br><span class=\"line\">- Transfer-Encoding\t报文的传输编码格式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求头部字段\"><a href=\"#请求头部字段\" class=\"headerlink\" title=\"请求头部字段\"></a>请求头部字段</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Host\t\t\t\t请求资源所在服务器：主机+端口</span><br><span class=\"line\">- User-Agent\t\t客户端将本地的操作系统、浏览器和其它属性发送给服务器，非必须，可修改</span><br><span class=\"line\">- Accept\t\t\t客户端希望接收的媒体类型，如 image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class=\"line\">- Accept-Charset\t客户端可接收的字符集</span><br><span class=\"line\">- Accept-Encoding\t客户端可接收的内容编码，如 gzip, deflate, br</span><br><span class=\"line\">- Accept-Language\t客户端可接收的自然语言，如 zh-CN,zh;q=0.9</span><br><span class=\"line\">- Authorization\t\t用于证明客户端有权查看某个资源</span><br><span class=\"line\">- refer\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">举例</span><br><span class=\"line\">GET /form.html HTTP/1.1 (CRLF)</span><br><span class=\"line\"></span><br><span class=\"line\">Accept:image/gif,image/x-xbitmap,image/jpeg,application/msword,*/* (CRLF)</span><br><span class=\"line\">Accept-Language:zh-cn (CRLF)</span><br><span class=\"line\">Accept-Encoding:gzip,deflate (CRLF)</span><br><span class=\"line\">If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)</span><br><span class=\"line\">If-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)</span><br><span class=\"line\">User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)</span><br><span class=\"line\">Host:www.guet.edu.cn (CRLF)</span><br><span class=\"line\">Connection:Keep-Alive (CRLF)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"响应头部字段\"><a href=\"#响应头部字段\" class=\"headerlink\" title=\"响应头部字段\"></a>响应头部字段</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Accept-Ranges\t\t可接受的字节范围</span><br><span class=\"line\">- Location\t\t\t让客户端重定向到的URL</span><br><span class=\"line\">- Server\t\t\tHttp服务器的安装信息，如 Apache-Coyote/1.1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实体头部字段\"><a href=\"#实体头部字段\" class=\"headerlink\" title=\"实体头部字段\"></a>实体头部字段</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Allow\t\t\t\t资源可支持的Http方法</span><br><span class=\"line\">- Content-type\t\t实体内容的类型</span><br><span class=\"line\">- Content-Encoding\t实体内容的编码方式</span><br><span class=\"line\">- Content-Language\t实体内容的语言</span><br><span class=\"line\">- Content-length\t实体内容的长度，单位是字节</span><br><span class=\"line\">- Content-Range\t\t实体内容的位置范围，一般是发出部分请求时使用</span><br><span class=\"line\">- Last-Modified\t\t请求资源最后修改时间</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其它知识补充\"><a href=\"#其它知识补充\" class=\"headerlink\" title=\"其它知识补充\"></a>其它知识补充</h2><h3 id=\"应用层协议\"><a href=\"#应用层协议\" class=\"headerlink\" title=\"应用层协议\"></a>应用层协议</h3><ul>\n<li>HTTP</li>\n<li>FTP</li>\n<li>SMTP</li>\n<li>DNS</li>\n<li>TELNET</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/Spring-Webflow-第一个Flow/20180906212548121.png","post":"ck0atmo9c000i00bn1wocenn3","slug":"20180906212548121.png","modified":1,"renderable":1},{"_id":"source/_posts/Spring-Webflow-第一个Flow/20180906213226568.png","post":"ck0atmo9c000i00bn1wocenn3","slug":"20180906213226568.png","modified":1,"renderable":1},{"_id":"source/_posts/读书笔记-RxJava/1564802038820.png","post":"ck0atmo9h000z00bnhbbn61q5","slug":"1564802038820.png","modified":1,"renderable":1},{"_id":"source/_posts/读书笔记-RxJava/1564822583394.png","post":"ck0atmo9h000z00bnhbbn61q5","slug":"1564822583394.png","modified":1,"renderable":1},{"_id":"source/_posts/读书笔记-RxJava/1564823248295.png","post":"ck0atmo9h000z00bnhbbn61q5","slug":"1564823248295.png","modified":1,"renderable":1},{"_id":"source/_posts/读书笔记-RxJava/1564823342178.png","post":"ck0atmo9h000z00bnhbbn61q5","slug":"1564823342178.png","modified":1,"renderable":1},{"_id":"source/_posts/读书笔记-RxJava/1564823975876.png","post":"ck0atmo9h000z00bnhbbn61q5","slug":"1564823975876.png","modified":1,"renderable":1},{"_id":"source/_posts/读书笔记-RxJava/1564824218864.png","post":"ck0atmo9h000z00bnhbbn61q5","slug":"1564824218864.png","modified":1,"renderable":1},{"_id":"source/_posts/读书笔记-RxJava/1564825542157.png","post":"ck0atmo9h000z00bnhbbn61q5","slug":"1564825542157.png","modified":1,"renderable":1},{"_id":"source/_posts/读书笔记-RxJava/switch.c.png","post":"ck0atmo9h000z00bnhbbn61q5","slug":"switch.c.png","modified":1,"renderable":1},{"_id":"source/_posts/Spring-Webflow-第一个Flow/20180906215538433.jpeg","slug":"20180906215538433.jpeg","post":"ck0atmo9c000i00bn1wocenn3","modified":1,"renderable":0}],"PostCategory":[{"post_id":"ck0atmo8w000000bn97j2objf","category_id":"ck0atmo93000400bn38felm9q","_id":"ck0atmo9b000f00bnw88tig8q"},{"post_id":"ck0atmo99000d00bn9cgxam4d","category_id":"ck0atmo98000b00bn0uaz3awb","_id":"ck0atmo9d000l00bnliueetb3"},{"post_id":"ck0atmo90000200bnlyk0h98n","category_id":"ck0atmo98000b00bn0uaz3awb","_id":"ck0atmo9f000q00bnn7q9oe7o"},{"post_id":"ck0atmo9a000e00bn1k0z1u3b","category_id":"ck0atmo98000b00bn0uaz3awb","_id":"ck0atmo9g000s00bnbrt5thua"},{"post_id":"ck0atmo9c000i00bn1wocenn3","category_id":"ck0atmo98000b00bn0uaz3awb","_id":"ck0atmo9h000x00bncinr7u9e"},{"post_id":"ck0atmo94000600bnic4csw6b","category_id":"ck0atmo9c000g00bnuo05sois","_id":"ck0atmo9i001000bnpgchlee1"},{"post_id":"ck0atmo9f000p00bnvar4wsgj","category_id":"ck0atmo98000b00bn0uaz3awb","_id":"ck0atmo9j001400bngtgo15k5"},{"post_id":"ck0atmo96000800bnfzw8823r","category_id":"ck0atmo98000b00bn0uaz3awb","_id":"ck0atmo9j001700bncb5eiul5"},{"post_id":"ck0atmo97000a00bn2m4e2akf","category_id":"ck0atmo98000b00bn0uaz3awb","_id":"ck0atmo9j001a00bnhqgm9q7p"},{"post_id":"ck0atmo9d000k00bne2d0txyq","category_id":"ck0atmo9i001100bnuj25cb53","_id":"ck0atmo9k001c00bnh9umshks"},{"post_id":"ck0atmo9f000r00bnusyzryhj","category_id":"ck0atmo9j001900bnz30zwhcz","_id":"ck0atmo9k001h00bnn0vdy3o3"},{"post_id":"ck0atmo9h000w00bnc93j4y6o","category_id":"ck0atmo9k001d00bn3e51iw7q","_id":"ck0atmo9l001l00bno2laxtcg"},{"post_id":"ck0atmo9h000z00bnhbbn61q5","category_id":"ck0atmo9l001j00bn5lw17xrf","_id":"ck0atmo9m001q00bnx523lww6"},{"post_id":"ck0atmo9i001300bnonaq36iq","category_id":"ck0atmo9l001m00bnaw2un142","_id":"ck0atmo9m001s00bnyzslvnyw"}],"PostTag":[{"post_id":"ck0atmo8w000000bn97j2objf","tag_id":"ck0atmo94000500bnp3ktu8sk","_id":"ck0atmo9d000j00bnbyht7upv"},{"post_id":"ck0atmo8w000000bn97j2objf","tag_id":"ck0atmo98000c00bnx3icbgvy","_id":"ck0atmo9d000m00bn745p8jpo"},{"post_id":"ck0atmo9f000p00bnvar4wsgj","tag_id":"ck0atmo9c000h00bnw9ndgyw9","_id":"ck0atmo9g000u00bnbfqyvlup"},{"post_id":"ck0atmo9f000p00bnvar4wsgj","tag_id":"ck0atmo9e000o00bntr4vktv1","_id":"ck0atmo9h000y00bn1dg9lcco"},{"post_id":"ck0atmo90000200bnlyk0h98n","tag_id":"ck0atmo9c000h00bnw9ndgyw9","_id":"ck0atmo9i001200bn3mwrrga4"},{"post_id":"ck0atmo90000200bnlyk0h98n","tag_id":"ck0atmo9e000o00bntr4vktv1","_id":"ck0atmo9j001600bnhutm29u2"},{"post_id":"ck0atmo94000600bnic4csw6b","tag_id":"ck0atmo9g000v00bncq0vdm6d","_id":"ck0atmo9j001800bn63wgykvt"},{"post_id":"ck0atmo96000800bnfzw8823r","tag_id":"ck0atmo9c000h00bnw9ndgyw9","_id":"ck0atmo9k001f00bnp7sdq2eg"},{"post_id":"ck0atmo96000800bnfzw8823r","tag_id":"ck0atmo9e000o00bntr4vktv1","_id":"ck0atmo9k001g00bneg8nu1wc"},{"post_id":"ck0atmo97000a00bn2m4e2akf","tag_id":"ck0atmo9c000h00bnw9ndgyw9","_id":"ck0atmo9l001n00bnqnjyddwh"},{"post_id":"ck0atmo97000a00bn2m4e2akf","tag_id":"ck0atmo9e000o00bntr4vktv1","_id":"ck0atmo9m001o00bnhvlrbdzq"},{"post_id":"ck0atmo99000d00bn9cgxam4d","tag_id":"ck0atmo9c000h00bnw9ndgyw9","_id":"ck0atmo9m001t00bn6w8sdf34"},{"post_id":"ck0atmo99000d00bn9cgxam4d","tag_id":"ck0atmo9e000o00bntr4vktv1","_id":"ck0atmo9m001u00bntwtw96g0"},{"post_id":"ck0atmo9a000e00bn1k0z1u3b","tag_id":"ck0atmo9c000h00bnw9ndgyw9","_id":"ck0atmo9n001x00bnvwyyega1"},{"post_id":"ck0atmo9a000e00bn1k0z1u3b","tag_id":"ck0atmo9e000o00bntr4vktv1","_id":"ck0atmo9n001y00bnw21ocrl7"},{"post_id":"ck0atmo9c000i00bn1wocenn3","tag_id":"ck0atmo9c000h00bnw9ndgyw9","_id":"ck0atmo9n002000bnk0o2fx03"},{"post_id":"ck0atmo9c000i00bn1wocenn3","tag_id":"ck0atmo9e000o00bntr4vktv1","_id":"ck0atmo9n002100bnoxt7hxs0"},{"post_id":"ck0atmo9d000k00bne2d0txyq","tag_id":"ck0atmo9n001z00bn5qkb5409","_id":"ck0atmo9n002300bn13qxkpqx"},{"post_id":"ck0atmo9f000r00bnusyzryhj","tag_id":"ck0atmo9n002200bnip68jjmu","_id":"ck0atmo9o002600bnd7grwcvr"},{"post_id":"ck0atmo9f000r00bnusyzryhj","tag_id":"ck0atmo9o002400bnlgrula7g","_id":"ck0atmo9o002700bnxp621nni"},{"post_id":"ck0atmo9h000w00bnc93j4y6o","tag_id":"ck0atmo9o002500bnmh7g8pjp","_id":"ck0atmo9o002b00bnv90cqoji"},{"post_id":"ck0atmo9h000w00bnc93j4y6o","tag_id":"ck0atmo9o002800bns7iv4vul","_id":"ck0atmo9o002c00bn6f2gpiq3"},{"post_id":"ck0atmo9h000w00bnc93j4y6o","tag_id":"ck0atmo9o002900bn1irwrmoo","_id":"ck0atmo9p002e00bnnfxl0bgv"},{"post_id":"ck0atmo9h000z00bnhbbn61q5","tag_id":"ck0atmo9o002a00bna6b7ob2d","_id":"ck0atmo9p002f00bnvxuv0wyt"},{"post_id":"ck0atmo9i001300bnonaq36iq","tag_id":"ck0atmo9o002d00bnjb372586","_id":"ck0atmo9p002g00bnvcnhsx9c"}],"Tag":[{"name":"fileupload","_id":"ck0atmo94000500bnp3ktu8sk"},{"name":"apache","_id":"ck0atmo98000c00bnx3icbgvy"},{"name":"Spring","_id":"ck0atmo9c000h00bnw9ndgyw9"},{"name":"Webflow","_id":"ck0atmo9e000o00bntr4vktv1"},{"name":"git","_id":"ck0atmo9g000v00bncq0vdm6d"},{"name":"django","_id":"ck0atmo9n001z00bn5qkb5409"},{"name":"随笔","_id":"ck0atmo9n002200bnip68jjmu"},{"name":"博客","_id":"ck0atmo9o002400bnlgrula7g"},{"name":"推荐","_id":"ck0atmo9o002500bnmh7g8pjp"},{"name":"长尾","_id":"ck0atmo9o002800bns7iv4vul"},{"name":"马太效应","_id":"ck0atmo9o002900bn1irwrmoo"},{"name":"RxJava","_id":"ck0atmo9o002a00bna6b7ob2d"},{"name":"http","_id":"ck0atmo9o002d00bnjb372586"}]}}